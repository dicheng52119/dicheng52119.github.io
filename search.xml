<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title><![CDATA[Session和Cookie的区别与联系]]></title>
      <url>/2018/01/07/Session%E5%92%8CCookie%E7%9A%84%E5%8C%BA%E5%88%AB%E4%B8%8E%E8%81%94%E7%B3%BB/</url>
      <content type="html"><![CDATA[<h3 id="概念理解"><a href="#概念理解" class="headerlink" title="概念理解"></a>概念理解</h3><p>你可能有留意到当你浏览网页时，会有一些推送消息，大多数是你最近留意过的同类东西，比如你想买桌子，上淘宝搜了一下，结果连着几天会有各种各样的桌子的链接。这是因为</p>
<p>你浏览某个网页的时候，WEB 服务器会先送一些资料放在你的计算机上，类似于你打的文字，选的一些东西什么的，Cookie 会帮你都纪录下来。当下次你再光临同一个网站，WEB</p>
<p>服务器会先看看有没有它上次留下的 Cookie 资料，有的话，就会依据 Cookie里的内容来判断使用者，送出特定的网页内容给你。 Cookie 的使用很普遍，许多有提供个人化服务的</p>
<p>网站，都是利用 Cookie来辨认使用者，以方便送出使用者量身定做的内容。</p>
<p>然而，cookie是什么呢？session又是什么？</p>
<p>先来了解几个概念。</p>
<a id="more"></a>
<ol>
<li><p>无状态的HTTP协议：协议是指计算机通信网络中两台计算机之间进行通信所必须共同遵守的规定或规则，超文本传输协议(HTTP)是一种通信协议，它允许将超文本标记语言(HTML)文档从Web服务器传送到客户端的浏览器。</p>
<p> HTTP协议是无状态的协议。一旦数据交换完毕，客户端与服务器端的连接就会关闭，再次交换数据需要建立新的连接。<strong>这就意味着服务器无法从连接上跟踪会话。</strong></p>
</li>
<li><p>会话（Session）跟踪：会话，指用户登录网站后的一系列动作，比如浏览商品添加到购物车并购买。会话（Session）跟踪是Web程序中常用的技术，用来跟踪用户的整个会话。常用的会话跟踪技术是Cookie与Session。<strong>Cookie通过在客户端记录信息确定用户身份，Session通过在服务器端记录信息确定用户身份。</strong></p>
</li>
</ol>
<h3 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h3><p>由于HTTP是一种无状态的协议，服务器单从网络连接上无从知道客户身份。用户A购买了一件商品放入购物车内，当再次购买商品时服务器已经无法判断该购买行为是属于用户A的会话还是用户B的会话了。怎么办呢？就给客户端们颁发一个通行证吧，每人一个，无论谁访问都必须携带自己通行证。这样服务器就能从通行证上确认客户身份了。这就是Cookie的工作原理。</p>
<p>Cookie实际上是一小段的文本信息。客户端请求服务器，如果服务器需要记录该用户状态，就使用response向客户端浏览器颁发一个Cookie。客户端会把Cookie保存起来。</p>
<p>当浏览器再请求该网站时，浏览器把请求的网址连同该Cookie一同提交给服务器。服务器检查该Cookie，以此来辨认用户状态。服务器还可以根据需要修改Cookie的内容。</p>
<ol>
<li><p>cookie的内容主要包括：名字，值，过期时间，路径和域。路径与域一起构成cookie的作用范围。</p>
<ul>
<li>Name 和 Value属性由程序设定,默认值都是空引用。</li>
<li>Domain属性的默认值为当前URL的域名部分，不管发出这个cookie的页面在哪个目录下的。</li>
<li>Path属性的默认值是根目录，即 ”/” ，不管发出这个cookie的页面在哪个目录下的。可以由程序设置为一定的路径来进一步限制此cookie的作用范围。</li>
<li><p>Expires 属性，这个属性设置此Cookie 的过期日期和时间。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">HttpCookie cookie = <span class="keyword">new</span> HttpCookie(<span class="string">"MyCook"</span>);<span class="comment">//初使化并设置Cookie的名称</span></span><br><span class="line">DateTime dt = DateTime.Now;</span><br><span class="line">TimeSpan ts = <span class="keyword">new</span> TimeSpan(<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>);<span class="comment">//过期时间为1分钟</span></span><br><span class="line">cookie.Expires = dt.Add(ts);<span class="comment">//设置过期时间</span></span><br><span class="line">cookie.Values.Add(<span class="string">"userid"</span>, <span class="string">"value"</span>);</span><br><span class="line">cookie.Values.Add(<span class="string">"userid2"</span>, <span class="string">"value2"</span>);</span><br><span class="line">Response.AppendCookie(cookie);</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>Path和Domain属性</p>
<p> –path:</p>
<p> 如果<a href="http://www.china.com/test/index.html" target="_blank" rel="noopener">http://www.china.com/test/index.html</a> 建立了一个cookie，那么在<a href="http://www.china.com/test/目录里的所有页面，以及该目录下面任何子目录里" target="_blank" rel="noopener">http://www.china.com/test/目录里的所有页面，以及该目录下面任何子目录里</a></p>
<p>的页面都可以访问这个cookie。这就是说，在<a href="http://www.china.com/test/test2/test3" target="_blank" rel="noopener">http://www.china.com/test/test2/test3</a> 里的任何页面都可以访问<a href="http://www.china.com/test/index.html" target="_blank" rel="noopener">http://www.china.com/test/index.html</a></p>
<p>建立的cookie。但是，如果<a href="http://www.china.com/test/" target="_blank" rel="noopener">http://www.china.com/test/</a> 需要访问<a href="http://www.china.com/test/index.html设置的cookes，该怎么办？" target="_blank" rel="noopener">http://www.china.com/test/index.html设置的cookes，该怎么办？</a></p>
<p>这时，我们要把cookies的path属性设置成“/”。在指定路径的时候，凡是来自同一服务器，URL里有相同路径的所有WEB页面都可以共享cookies。</p>
<p>–Domain:</p>
<p>比如： <a href="http://www.baidu.com/xxx/login.aspx" target="_blank" rel="noopener">http://www.baidu.com/xxx/login.aspx</a> 页面中发出一个cookie，Domain属性缺省就是www.baidu.com ，可以由程序设置此属性为需要的值。　　</p>
<p>值是域名，比如www.china.com。这是对path路径属性的一个延伸。如果我们想让 www.china.com能够访问bbs.china.com设置的cookies，该怎么办? 我们可以把</p>
<p>domain属性设置成“china.com”， 并把path属性设置成“/”。</p>
</li>
<li><p>会话Cookie和持久Cookie</p>
<p> 若不设置过期时间，则表示这个cookie的生命期为浏览器会话期间，关闭浏览器窗口，cookie就消失。这种生命期为浏览器会话期的cookie被称为会话cookie。会话cookie一般不存储在硬盘上而是保存在内存里，当然这种行为并不是规范规定的。</p>
<p> 若设置了过期时间，浏览器就会把cookie保存到硬盘上，关闭后再次打开浏览器，这些cookie仍然有效直到超过设定的过期时间。存储在硬盘上的cookie可以在浏览器的不同进程间共享。这种称为持久Cookie。 </p>
</li>
<li><p>应用场景</p>
<ul>
<li>判断用户是否登陆过网站，以便下次登录时能够直接登录。如果我们删除cookie，则每次登录必须从新填写登录的相关信息。</li>
<li>另一个重要的应用是“购物车”中类的处理和设计。用户可能在一段时间内在同一家网站的不同页面选择不同的商品，可以将这些信息都写入cookie，在最后付款时从cookie中提取这些信息，当然这里面有了安全和性能问题需要我们考虑了。</li>
</ul>
</li>
</ol>
<h3 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h3><p>Session是另一种记录客户状态的机制，不同的是Cookie保存在客户端浏览器中，而Session保存在服务器上。客户端浏览器访问服务器的时候，服务器把客户端信息以某种形式记录在服务器上。这就是Session。客户端浏览器再次访问时只需要从该Session中查找该客户的状态就可以了。</p>
<p>每个用户访问服务器都会建立一个session，那服务器是怎么标识用户的唯一身份呢？事实上，用户与服务器建立连接的同时，服务器会自动为其分配一个SessionId。</p>
<ol>
<li><p>两个问题：</p>
<p> 1）什么东西可以让你每次请求都把SessionId自动带到服务器呢？显然就是cookie了，如果你想为用户建立一次会话，可以在用户授权成功时给他一个唯一的cookie。当一个用户提交了表单时，浏览器会将用户的SessionId自动附加在HTTP头信息中，（这是浏览器的自动功能，用户不会察觉到），当服务器处理完这个表单后，将结果返回给SessionId<br>所对应的用户。试想，如果没有SessionId，当有两个用户同时进行注册时，服务器怎样才能知道到底是哪个用户提交了哪个表单呢。</p>
<p> 2）储存需要的信息。服务器通过SessionId作为key，读写到对应的value，这就达到了保持会话信息的目的。</p>
</li>
<li><p>session的创建：</p>
<p> 当程序需要为某个客户端的请求创建一个session时，服务器首先检查这个客户端的请求里是否已包含了sessionId，如果已包含则说明以前已经为此客户端创建过session，服务器就按照sessionId把这个session检索出来使用（检索不到，会新建一个），如果客户端请求不包含sessionId，则为此客户端创建一个session并且生成一个与此session相关联的sessionId，sessionId的值是一个既不会重复，又不容易被找到规律以仿造的字符串，这个sessionId将被在本次响应中返回给客户端保存。</p>
</li>
<li><p>禁用cookie：</p>
<p> 如果客户端禁用了cookie，通常有两种方法实现session而不依赖cookie。</p>
<p> 1）URL重写，就是把sessionId直接附加在URL路径的后面。</p>
<p> 2）表单隐藏字段。就是服务器会自动修改表单，添加一个隐藏字段，以便在表单提交时能够把session id传递回服务器。比如： </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;form name=<span class="string">"testform"</span> action=<span class="string">"/xxx"</span>&gt; </span><br><span class="line">    &lt;input type=<span class="string">"hidden"</span> name=<span class="string">"jsessionid"</span> value=<span class="string">"ByOK3vjFD75aPnrF7C2HmdnV6QZcEbzWoWiBYEnLerjQ99zWpBng!-145788764"</span>&gt; </span><br><span class="line">    &lt;input type=<span class="string">"text"</span>&gt; </span><br><span class="line">&lt;<span class="regexp">/form&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>Session共享：</p>
<p> 对于多网站(同一父域不同子域)单服务器，我们需要解决的就是来自不同网站之间SessionId的共享。由于域名不同(aaa.test.com和bbb.test.com)，而SessionId又分别储存在各自的cookie中，因此服务器会认为对于两个子站的访问,是来自不同的会话。解决的方法是通过修改cookies的域名为父域名达到cookie共享的目的,从而实现SessionId的共享。带来的弊端就是，子站间的cookie信息也同时被共享了。</p>
</li>
</ol>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol>
<li>存放位置：cookie数据存放在客户的浏览器上，session数据放在服务器上。</li>
<li>安全性：cookie不是很安全，别人可以分析存放在本地的cookie并进行cookie欺骗，考虑到安全应当使用session。</li>
<li>性能：session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能，考虑到减轻服务器性能方面，应当使用cookie。</li>
<li>大小：单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个cookie。</li>
<li>应用场景：可以考虑将登陆信息等重要信息存放为session，其他信息如果需要保留，可以放在cookie中。</li>
</ol>
]]></content>
      
        <categories>
            
            <category> Session </category>
            
        </categories>
        
        
        <tags>
            
            <tag> technology </tag>
            
            <tag> session </tag>
            
            <tag> cookie </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[基于redis分布式锁实现“秒杀]]></title>
      <url>/2018/01/07/%E5%9F%BA%E4%BA%8Eredis%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E5%AE%9E%E7%8E%B0%E2%80%9C%E7%A7%92%E6%9D%80/</url>
      <content type="html"><![CDATA[<p>最近在项目中遇到了类似“秒杀”的业务场景，在本篇博客中，我将用一个非常简单的demo，阐述实现所谓“秒杀”的基本思路。</p>
<h3 id="业务场景"><a href="#业务场景" class="headerlink" title="业务场景"></a>业务场景</h3><p>所谓秒杀，从业务角度看，是短时间内多个用户“争抢”资源，这里的资源在大部分秒杀场景里是商品；将业务抽象，技术角度看，秒杀就是多个线程对资源进行操作，所以实现秒杀，就必须控制线程对资源的争抢，既要保证高效并发，也要保证操作的正确。</p>
<h3 id="一些可能的实现"><a href="#一些可能的实现" class="headerlink" title="一些可能的实现"></a>一些可能的实现</h3><p>刚才提到过，实现秒杀的关键点是控制线程对资源的争抢，根据基本的线程知识，可以不加思索的想到下面的一些方法： </p>
<ol>
<li>秒杀在技术层面的抽象应该就是一个方法，在这个方法里可能的操作是将商品库存-1，将商品加入用户的购物车等等，在不考虑缓存的情况下应该是要操作数据库的。那么最简单直接的实现就是在这个方法上加上synchronized关键字，通俗的讲就是锁住整个方法； </li>
<li>锁住整个方法这个策略简单方便，但是似乎有点粗暴。可以稍微优化一下，只锁住秒杀的代码块，比如写数据库的部分； </li>
<li>既然有并发问题，那我就让他“不并发”，将所有的线程用一个队列管理起来，使之变成串行操作，自然不会有并发问题。</li>
</ol>
<p>上面所述的方法都是有效的，但是都不好。为什么？第一和第二种方法本质上是“加锁”，但是锁粒度依然比较高。什么意思？试想一下，如果两个线程同时执行秒杀方法，这两个线程操作的是不同的商品,从业务上讲应该是可以同时进行的，但是如果采用第一二种方法，这两个线程也会去争抢同一个锁，这其实是不必要的。第三种方法也没有解决上面说的问题。</p>
<p>那么如何将锁控制在更细的粒度上呢？可以考虑为每个商品设置一个互斥锁，以和商品ID相关的字符串为唯一标识，这样就可以做到只有争抢同一件商品的线程互斥，不会导致所有的线程互斥。分布式锁恰好可以帮助我们解决这个问题。</p>
<a id="more"></a>
<h3 id="何为分布式锁"><a href="#何为分布式锁" class="headerlink" title="何为分布式锁"></a>何为分布式锁</h3><p>分布式锁是控制分布式系统之间同步访问共享资源的一种方式。在分布式系统中，常常需要协调他们的动作。如果不同的系统或是同一个系统的不同主机之间共享了一个或一组资源，那么访问这些资源的时候，往往需要互斥来防止彼此干扰来保证一致性，在这种情况下，便需要使用到分布式锁。</p>
<p>我们来假设一个最简单的秒杀场景：数据库里有一张表，column分别是商品ID，和商品ID对应的库存量，秒杀成功就将此商品库存量-1。现在假设有1000个线程来秒杀两件商品，500个线程秒杀第一个商品，500个线程秒杀第二个商品。我们来根据这个简单的业务场景来解释一下分布式锁。 </p>
<p>通常具有秒杀场景的业务系统都比较复杂，承载的业务量非常巨大，并发量也很高。这样的系统往往采用分布式的架构来均衡负载。那么这1000个并发就会是从不同的地方过来，商品库存就是共享的资源，也是这1000个并发争抢的资源，这个时候我们需要将并发互斥管理起来。这就是分布式锁的应用。 </p>
<p>而key-value存储系统，如redis，因为其一些特性，是实现分布式锁的重要工具。</p>
<h3 id="具体的实现"><a href="#具体的实现" class="headerlink" title="具体的实现"></a>具体的实现</h3><p>先来看看一些redis的基本命令：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">SETNX key value</span><br></pre></td></tr></table></figure></p>
<p>如果key不存在，就设置key对应字符串value。在这种情况下，该命令和SET一样。当key已经存在时，就不做任何操作。SETNX是”SET if Not eXists”。 </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">expire KEY seconds</span><br></pre></td></tr></table></figure>
<p>设置key的过期时间。如果key已过期，将会被自动删除。 </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">del KEY</span><br></pre></td></tr></table></figure>
<p>删除key </p>
<h3 id="需要考虑的问题"><a href="#需要考虑的问题" class="headerlink" title="需要考虑的问题"></a>需要考虑的问题</h3><ol>
<li>用什么操作redis？幸亏redis已经提供了jedis客户端用于java应用程序，直接调用jedis API即可。 </li>
<li>怎么实现加锁？“锁”其实是一个抽象的概念，将这个抽象概念变为具体的东西，就是一个存储在redis里的key-value对，key是于商品ID相关的字符串来唯一标识，value其实并不重要，因为只要这个唯一的key-value存在，就表示这个商品已经上锁。 </li>
<li>如何释放锁？既然key-value对存在就表示上锁，那么释放锁就自然是在redis里删除key-value对。 </li>
<li>阻塞还是非阻塞？笔者采用了阻塞式的实现，若线程发现已经上锁，会在特定时间内轮询锁。 </li>
<li>如何处理异常情况？比如一个线程把一个商品上了锁，但是由于各种原因，没有完成操作（在上面的业务场景里就是没有将库存-1写入数据库），自然没有释放锁，这个情况笔者加入了锁超时机制，利用redis的expire命令为key设置超时时长，过了超时时间redis就会将这个key自动删除，即强制释放锁（可以认为超时释放锁是一个异步操作，由redis完成，应用程序只需要根据系统特点设置超时时间即可）。</li>
</ol>
<h3 id="talk-is-cheap-show-me-the-code"><a href="#talk-is-cheap-show-me-the-code" class="headerlink" title="talk is cheap,show me the code"></a>talk is cheap,show me the code</h3><p>在代码实现层面，注解有并发的方法和参数，通过动态代理获取注解的方法和参数，在代理中加锁，执行完被代理的方法后释放锁。</p>
<p>几个注解定义： </p>
<p>cachelock是方法级的注解，用于注解会产生并发问题的方法:<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target</span>(ElementType.METHOD)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> CacheLock &#123;</span><br><span class="line">    <span class="function">String <span class="title">lockedPrefix</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;<span class="comment">//redis 锁key的前缀</span></span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="title">timeOut</span><span class="params">()</span> <span class="keyword">default</span> 2000</span>;<span class="comment">//轮询锁的时间</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">expireTime</span><span class="params">()</span> <span class="keyword">default</span> 1000</span>;<span class="comment">//key在redis里存在的时间，1000S</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>lockedObject是参数级的注解，用于注解商品ID等基本类型的参数：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target</span>(ElementType.PARAMETER)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> LockedObject &#123;</span><br><span class="line">    <span class="comment">//不需要值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>LockedComplexObject也是参数级的注解，用于注解自定义类型的参数：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target</span>(ElementType.PARAMETER)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> LockedComplexObject &#123;</span><br><span class="line">    <span class="function">String <span class="title">field</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;<span class="comment">//含有成员变量的复杂对象中需要加锁的成员变量，如一个商品对象的商品ID</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>CacheLockInterceptor实现InvocationHandler接口，在invoke方法中获取注解的方法和参数，在执行注解的方法前加锁，执行被注解的方法后释放锁：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CacheLockInterceptor</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> ERROR_COUNT  = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> Object proxied;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CacheLockInterceptor</span><span class="params">(Object proxied)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.proxied = proxied;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line"></span><br><span class="line">        CacheLock cacheLock = method.getAnnotation(CacheLock.class);</span><br><span class="line">        <span class="comment">//没有cacheLock注解，pass</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">null</span> == cacheLock)&#123;</span><br><span class="line">            System.out.println(<span class="string">"no cacheLock annotation"</span>);          </span><br><span class="line">            <span class="keyword">return</span> method.invoke(proxied, args);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//获得方法中参数的注解</span></span><br><span class="line">        Annotation[][] annotations = method.getParameterAnnotations();</span><br><span class="line">        <span class="comment">//根据获取到的参数注解和参数列表获得加锁的参数</span></span><br><span class="line">        Object lockedObject = getLockedObject(annotations,args);</span><br><span class="line">        String objectValue = lockedObject.toString();</span><br><span class="line">        <span class="comment">//新建一个锁</span></span><br><span class="line">        RedisLock lock = <span class="keyword">new</span> RedisLock(cacheLock.lockedPrefix(), objectValue);</span><br><span class="line">        <span class="comment">//加锁</span></span><br><span class="line">        <span class="keyword">boolean</span> result = lock.lock(cacheLock.timeOut(), cacheLock.expireTime());</span><br><span class="line">        <span class="keyword">if</span>(!result)&#123;<span class="comment">//取锁失败</span></span><br><span class="line">            ERROR_COUNT += <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> CacheLockException(<span class="string">"get lock fail"</span>);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">//加锁成功，执行方法</span></span><br><span class="line">            <span class="keyword">return</span> method.invoke(proxied, args);</span><br><span class="line">        &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">            lock.unlock();<span class="comment">//释放锁</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> annotations</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> args</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> CacheLockException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Object <span class="title">getLockedObject</span><span class="params">(Annotation[][] annotations,Object[] args)</span> <span class="keyword">throws</span> CacheLockException</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">null</span> == args || args.length == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> CacheLockException(<span class="string">"方法参数为空，没有被锁定的对象"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">null</span> == annotations || annotations.length == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> CacheLockException(<span class="string">"没有被注解的参数"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//不支持多个参数加锁，只支持第一个注解为lockedObject或者lockedComplexObject的参数</span></span><br><span class="line">        <span class="keyword">int</span> index = -<span class="number">1</span>;<span class="comment">//标记参数的位置指针</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; annotations.length;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; annotations[i].length;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(annotations[i][j] <span class="keyword">instanceof</span> LockedComplexObject)&#123;<span class="comment">//注解为LockedComplexObject</span></span><br><span class="line">                    index = i;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="keyword">return</span> args[i].getClass().getField(((LockedComplexObject)annotations[i][j]).field());</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (NoSuchFieldException | SecurityException e) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> CacheLockException(<span class="string">"注解对象中没有该属性"</span> + ((LockedComplexObject)annotations[i][j]).field());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(annotations[i][j] <span class="keyword">instanceof</span> LockedObject)&#123;</span><br><span class="line">                    index = i;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//找到第一个后直接break，不支持多参数加锁</span></span><br><span class="line">            <span class="keyword">if</span>(index != -<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(index == -<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> CacheLockException(<span class="string">"请指定被锁定参数"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> args[index];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>最关键的RedisLock类中的lock方法和unlock方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 加锁</span></span><br><span class="line"><span class="comment">     * 使用方式为：</span></span><br><span class="line"><span class="comment">     * lock();</span></span><br><span class="line"><span class="comment">     * try&#123;</span></span><br><span class="line"><span class="comment">     *    executeMethod();</span></span><br><span class="line"><span class="comment">     * &#125;finally&#123;</span></span><br><span class="line"><span class="comment">     *   unlock();</span></span><br><span class="line"><span class="comment">     * &#125;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> timeout timeout的时间范围内轮询锁</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> expire 设置锁超时时间</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 成功 or 失败</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">lock</span><span class="params">(<span class="keyword">long</span> timeout,<span class="keyword">int</span> expire)</span></span>&#123;</span><br><span class="line">        <span class="keyword">long</span> nanoTime = System.nanoTime();</span><br><span class="line">        timeout *= MILLI_NANO_TIME;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//在timeout的时间范围内不断轮询锁</span></span><br><span class="line">            <span class="keyword">while</span> (System.nanoTime() - nanoTime &lt; timeout) &#123;</span><br><span class="line">                <span class="comment">//锁不存在的话，设置锁并设置锁过期时间，即加锁</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">this</span>.redisClient.setnx(<span class="keyword">this</span>.key, LOCKED) == <span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="keyword">this</span>.redisClient.expire(key, expire);<span class="comment">//设置锁过期时间是为了在没有释放</span></span><br><span class="line">                    <span class="comment">//锁的情况下锁过期后消失，不会造成永久阻塞</span></span><br><span class="line">                    <span class="keyword">this</span>.lock = <span class="keyword">true</span>;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">this</span>.lock;</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">"出现锁等待"</span>);</span><br><span class="line">                <span class="comment">//短暂休眠，避免可能的活锁</span></span><br><span class="line">                Thread.sleep(<span class="number">3</span>, RANDOM.nextInt(<span class="number">30</span>));</span><br><span class="line">            &#125; </span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"locking error"</span>,e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">this</span>.lock)&#123;</span><br><span class="line">                redisClient.delKey(key);<span class="comment">//直接删除</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>上述的代码是框架性的代码，现在来讲解如何使用上面的简单框架来写一个秒杀函数。 </p>
<p>先定义一个接口，接口里定义了一个秒杀方法：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">SeckillInterface</span> </span>&#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*现在暂时只支持在接口方法上注解</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    <span class="comment">//cacheLock注解可能产生并发的方法</span></span><br><span class="line">    <span class="meta">@CacheLock</span>(lockedPrefix=<span class="string">"TEST_PREFIX"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">secKill</span><span class="params">(String userID,@LockedObject Long commidityID)</span></span>;<span class="comment">//最简单的秒杀方法，参数是用户ID和商品ID。可能有多个线程争抢一个商品，所以商品ID加上LockedObject注解</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上述SeckillInterface接口的实现类，即秒杀的具体实现：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SecKillImpl</span> <span class="keyword">implements</span> <span class="title">SeckillInterface</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> Map&lt;Long, Long&gt; inventory ;</span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        inventory = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        inventory.put(<span class="number">10000001L</span>, <span class="number">10000l</span>);</span><br><span class="line">        inventory.put(<span class="number">10000002L</span>, <span class="number">10000l</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">secKill</span><span class="params">(String arg1, Long arg2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//最简单的秒杀，这里仅作为demo示例</span></span><br><span class="line">        reduceInventory(arg2);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//模拟秒杀操作，姑且认为一个秒杀就是将库存减一，实际情景要复杂的多</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Long <span class="title">reduceInventory</span><span class="params">(Long commodityId)</span></span>&#123;</span><br><span class="line">        inventory.put(commodityId,inventory.get(commodityId) - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> inventory.get(commodityId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>模拟秒杀场景，1000个线程来争抢两个商品：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSecKill</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> threadCount = <span class="number">1000</span>;</span><br><span class="line">        <span class="keyword">int</span> splitPoint = <span class="number">500</span>;</span><br><span class="line">        CountDownLatch endCount = <span class="keyword">new</span> CountDownLatch(threadCount);</span><br><span class="line">        CountDownLatch beginCount = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</span><br><span class="line">        SecKillImpl testClass = <span class="keyword">new</span> SecKillImpl();</span><br><span class="line"></span><br><span class="line">        Thread[] threads = <span class="keyword">new</span> Thread[threadCount];</span><br><span class="line">        <span class="comment">//起500个线程，秒杀第一个商品</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i= <span class="number">0</span>;i &lt; splitPoint;i++)&#123;</span><br><span class="line">            threads[i] = <span class="keyword">new</span> Thread(<span class="keyword">new</span>  Runnable() &#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">//等待在一个信号量上，挂起</span></span><br><span class="line">                        beginCount.await();</span><br><span class="line">                        <span class="comment">//用动态代理的方式调用secKill方法</span></span><br><span class="line">                        SeckillInterface proxy = (SeckillInterface) Proxy.newProxyInstance(SeckillInterface.class.getClassLoader(), </span><br><span class="line">                            <span class="keyword">new</span> Class[]&#123;SeckillInterface.class&#125;, <span class="keyword">new</span> CacheLockInterceptor(testClass));</span><br><span class="line">                        proxy.secKill(<span class="string">"test"</span>, commidityId1);</span><br><span class="line">                        endCount.countDown();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            threads[i].start();</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//再起500个线程，秒杀第二件商品</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i= splitPoint;i &lt; threadCount;i++)&#123;</span><br><span class="line">            threads[i] = <span class="keyword">new</span> Thread(<span class="keyword">new</span>  Runnable() &#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">//等待在一个信号量上，挂起</span></span><br><span class="line">                        beginCount.await();</span><br><span class="line">                        <span class="comment">//用动态代理的方式调用secKill方法</span></span><br><span class="line">                        SeckillInterface proxy = (SeckillInterface) Proxy.newProxyInstance(SeckillInterface.class.getClassLoader(), </span><br><span class="line">                            <span class="keyword">new</span> Class[]&#123;SeckillInterface.class&#125;, <span class="keyword">new</span> CacheLockInterceptor(testClass));</span><br><span class="line">                        proxy.secKill(<span class="string">"test"</span>, commidityId2);</span><br><span class="line">                        <span class="comment">//testClass.testFunc("test", 10000001L);</span></span><br><span class="line">                        endCount.countDown();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            threads[i].start();</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> startTime = System.currentTimeMillis();</span><br><span class="line">        <span class="comment">//主线程释放开始信号量，并等待结束信号量，这样做保证1000个线程做到完全同时执行，保证测试的正确性</span></span><br><span class="line">        beginCount.countDown();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//主线程等待结束信号量</span></span><br><span class="line">            endCount.await();</span><br><span class="line">            <span class="comment">//观察秒杀结果是否正确</span></span><br><span class="line">            System.out.println(SecKillImpl.inventory.get(commidityId1));</span><br><span class="line">            System.out.println(SecKillImpl.inventory.get(commidityId2));</span><br><span class="line">            System.out.println(<span class="string">"error count"</span> + CacheLockInterceptor.ERROR_COUNT);</span><br><span class="line">            System.out.println(<span class="string">"total cost "</span> + (System.currentTimeMillis() - startTime));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>在正确的预想下，应该每个商品的库存都减少了500，在多次试验后，实际情况符合预想。如果不采用锁机制，会出现库存减少499，498的情况。 </p>
<p>这里采用了动态代理的方法，利用注解和反射机制得到分布式锁ID，进行加锁和释放锁操作。当然也可以直接在方法进行这些操作，采用动态代理也是为了能够将锁操作代码集中在代理中，便于维护。 </p>
<p>通常秒杀场景发生在web项目中，可以考虑利用spring的AOP特性将锁操作代码置于切面中，当然AOP本质上也是动态代理。</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>这篇文章从业务场景出发，从抽象到实现阐述了如何利用redis实现分布式锁，完成简单的秒杀功能，也记录了笔者思考的过程，希望能给阅读到本篇文章的人一些启发。</p>
]]></content>
      
        <categories>
            
            <category> Redis </category>
            
        </categories>
        
        
        <tags>
            
            <tag> technology </tag>
            
            <tag> redis thread </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Redis数据类型介绍]]></title>
      <url>/2018/01/07/Redis%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%BB%8B%E7%BB%8D/</url>
      <content type="html"><![CDATA[<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>redis常用五种数据类型:string,hash,list,set,zset(sorted set).</p>
<h3 id="String类型"><a href="#String类型" class="headerlink" title="String类型"></a>String类型</h3><p>String是最简单的类型，一个key对应一个value。</p>
<p>String类型的数据最大1G。 </p>
<p>String类型的值可以被视作integer，从而可以让“INCR”命令族操作(incrby、decr、decrby),这种情况下，该integer的值限制在64位有符号数。 </p>
<p>在list、set和zset中包含的独立的元素类型都是Redis String类型。</p>
<h3 id="List类型"><a href="#List类型" class="headerlink" title="List类型"></a>List类型</h3><p>链表类型，主要功能是push、pop、获取一个范围的所有值等。其中的key可以理解为链表的名字。</p>
<p>在Redis中，list就是Redis String的列表，按照插入顺序排序。比如使用LPUSH命令在list头插入一个元素，使用RPUSH命令在list的尾插入一个元素。当这两个命令之一作用于一个空的key时，一个新的list就创建出来了。</p>
<p>List的最大长度是2^32-1个元素。</p>
<a id="more"></a>
<h3 id="Set类型"><a href="#Set类型" class="headerlink" title="Set类型"></a>Set类型</h3><p>集合，和数学中的集合概念相似。操作中的key理解为集合的名字。</p>
<p>在Redis中，set就是Redis String的无序集合，不允许有重复元素。</p>
<p>Set的最大元素数是2^32-1。</p>
<p>Redis中对set的操作还有交集、并集、差集等。</p>
<h3 id="ZSet-Sorted-Set-类型"><a href="#ZSet-Sorted-Set-类型" class="headerlink" title="ZSet(Sorted Set)类型"></a>ZSet(Sorted Set)类型</h3><p>Zset是set的一个升级版本，在set的基础上增加了一个顺序属性，这一属性在添加修改元素时可以指定，每次指定后zset会自动安装指定值重新调整顺序。可以理解为一张表，一列存value，一列存顺序。操作中的key理解为zset的名字。</p>
<p>Zset的最大元素数是2^32-1。</p>
<p>对于已经有序的zset，仍然可以使用SORT命令，通过指定ASC|DESC参数对其进行排序。</p>
<h3 id="hash类型"><a href="#hash类型" class="headerlink" title="hash类型"></a>hash类型</h3><p>hash是最接近关系数据库结构的数据类型，可以将数据库一条记录或程序中一个对象转换成hashmap存放在redis中。</p>
<h3 id="jedis操作命令："><a href="#jedis操作命令：" class="headerlink" title="jedis操作命令："></a>jedis操作命令：</h3><ul>
<li><p>对value操作的命令</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">exists(key)：确认一个key是否存在</span><br><span class="line"></span><br><span class="line">del(key)：删除一个key</span><br><span class="line"></span><br><span class="line">type(key)：返回值的类型</span><br><span class="line"></span><br><span class="line">keys(pattern)：返回满足给定pattern的所有key</span><br><span class="line"></span><br><span class="line">randomkey：随机返回key空间的一个key</span><br><span class="line"></span><br><span class="line">rename(oldname, newname)：将key由oldname重命名为newname，若newname存在则删除newname表示的key</span><br><span class="line"></span><br><span class="line">dbsize：返回当前数据库中key的数目</span><br><span class="line"></span><br><span class="line">expire：设定一个key的活动时间（s）</span><br><span class="line"></span><br><span class="line">ttl：获得一个key的活动时间</span><br><span class="line"></span><br><span class="line">select(index)：按索引查询</span><br><span class="line"></span><br><span class="line">move(key, dbindex)：将当前数据库中的key转移到有dbindex索引的数据库</span><br><span class="line"></span><br><span class="line">flushdb：删除当前选择数据库中的所有key</span><br><span class="line"></span><br><span class="line">flushall：删除所有数据库中的所有key</span><br></pre></td></tr></table></figure>
</li>
<li><p>对String操作的命令</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">set(key, value)：给数据库中名称为key的string赋予值value</span><br><span class="line"></span><br><span class="line">get(key)：返回数据库中名称为key的string的value</span><br><span class="line"></span><br><span class="line">getset(key, value)：给名称为key的string赋予上一次的value</span><br><span class="line"></span><br><span class="line">mget(key1, key2,…, key N)：返回库中多个string（它们的名称为key1，key2…）的value     s</span><br><span class="line"></span><br><span class="line">setnx(key, value)：如果不存在名称为key的string，则向库中添加string，名称为key，值为value</span><br><span class="line"></span><br><span class="line">setex(key, time, value)：向库中添加string（名称为key，值为value）同时，设定过期时间time</span><br><span class="line"></span><br><span class="line">mset(key1, value1, key2, value2,…key N, value N)：同时给多个string赋值，名称为key i的string赋值value i</span><br><span class="line"></span><br><span class="line">msetnx(key1, value1, key2, value2,…key N, value N)：如果所有名称为key i的string都不存在，则向库中添加string，名称           key i赋值为value i</span><br><span class="line"></span><br><span class="line">incr(key)：名称为key的string增<span class="number">1</span>操作</span><br><span class="line"></span><br><span class="line">incrby(key, integer)：名称为key的string增加integer</span><br><span class="line"></span><br><span class="line">decr(key)：名称为key的string减<span class="number">1</span>操作</span><br><span class="line"></span><br><span class="line">decrby(key, integer)：名称为key的string减少integer</span><br><span class="line"></span><br><span class="line">append(key, value)：名称为key的string的值附加value</span><br><span class="line"></span><br><span class="line">substr(key, start, end)：返回名称为key的string的value的子串</span><br></pre></td></tr></table></figure>
</li>
<li><p>对List操作的命令</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">rpush(key, value)：在名称为key的list尾添加一个值为value的元素  </span><br><span class="line"></span><br><span class="line">lpush(key, value)：在名称为key的list头添加一个值为value的 元素</span><br><span class="line"></span><br><span class="line">llen(key)：返回名称为key的list的长度</span><br><span class="line"></span><br><span class="line">lrange(key, start, end)：返回名称为key的list中start至end之间的元素（下标从<span class="number">0</span>开始，下同）</span><br><span class="line"></span><br><span class="line">ltrim(key, start, end)：截取名称为key的list，保留start至end之间的元素</span><br><span class="line"></span><br><span class="line">lindex(key, index)：返回名称为key的list中index位置的元素</span><br><span class="line"></span><br><span class="line">lset(key, index, value)：给名称为key的list中index位置的元素赋值为value</span><br><span class="line"></span><br><span class="line">lrem(key, count, value)：删除count个名称为key的list中值为value的元素。count为<span class="number">0</span>，删除所有值为value的元素，count&gt;<span class="number">0</span>      从头至尾删除count个值为value的元素，count&lt;<span class="number">0</span>从尾到头删除|count|个值为value的元素。</span><br><span class="line"></span><br><span class="line">lpop(key)：返回并删除名称为key的list中的首元素</span><br><span class="line"></span><br><span class="line">rpop(key)：返回并删除名称为key的list中的尾元素</span><br><span class="line"></span><br><span class="line">blpop(key1, key2,… key N, timeout)：lpop 命令的block版本。即当timeout为<span class="number">0</span>时，若遇到名称为key i的list不存在或该list为空，则命令结束。如果 timeout&gt;<span class="number">0</span>，则遇到上述情况时，等待timeout秒，如果问题没有解决，则对key i+<span class="number">1</span>开始的list执行pop操作。</span><br><span class="line"></span><br><span class="line">brpop(key1, key2,… key N, timeout)：rpop的block版本。参考上一命令。</span><br><span class="line"></span><br><span class="line">rpoplpush(srckey, dstkey)：返回并删除名称为srckey的list的尾元素，并将该元素添加到名称为dstkey的list的头部</span><br></pre></td></tr></table></figure>
</li>
<li><p>对Set操作的命令</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">sadd(key, member)：向名称为key的set中添加元素member</span><br><span class="line"></span><br><span class="line">srem(key, member) ：删除名称为key的set中的元素member</span><br><span class="line"></span><br><span class="line">spop(key) ：随机返回并删除名称为key的set中一个元素  </span><br><span class="line"></span><br><span class="line">smove(srckey, dstkey, member) ：将member元素从名称为srckey的集合移到名称为dstkey的集合</span><br><span class="line"></span><br><span class="line">scard(key) ：返回名称为key的set的基数        </span><br><span class="line"></span><br><span class="line">sismember(key, member) ：测试member是否是名称为key的set的元素</span><br><span class="line"></span><br><span class="line">sinter(key1, key2,…key N) ：求交集</span><br><span class="line"></span><br><span class="line">sinterstore(dstkey, key1, key2,…key N) ：求交集并将交集保存到dstkey的集合</span><br><span class="line"></span><br><span class="line">sunion(key1, key2,…key N) ：求并集</span><br><span class="line"></span><br><span class="line">sunionstore(dstkey, key1, key2,…key N) ：求并集并将并集保存到dstkey的集合</span><br><span class="line"></span><br><span class="line">sdiff(key1, key2,…key N) ：求差集</span><br><span class="line"></span><br><span class="line">sdiffstore(dstkey, key1, key2,…key N) ：求差集并将差集保存到dstkey的集合</span><br><span class="line"></span><br><span class="line">smembers(key) ：返回名称为key的set的所有元素</span><br><span class="line"></span><br><span class="line">srandmember(key) ：随机返回名称为key的set的一个元素</span><br></pre></td></tr></table></figure>
</li>
<li><p>对zset（sorted set）操作的命令</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">zadd(key, score, member)：向名称为key的zset中添加元素member，score用于排序。如果该元素已经存在，则根据score更新该元素的顺序。</span><br><span class="line"></span><br><span class="line">zrem(key, member) ：删除名称为key的zset中的元素member</span><br><span class="line"></span><br><span class="line">zincrby(key, increment, member) ：如果在名称为key的zset中已经存在元素member，则该元素的score增加increment；否则向集合中添加该元素，其score的值为increment</span><br><span class="line"></span><br><span class="line">zrank(key, member) ：返回名称为key的zset（元素已按score从小到大排序）中member元素的rank（即index，从<span class="number">0</span>开始），若没有member元素，返回“nil”</span><br><span class="line"></span><br><span class="line">zrevrank(key, member) ：返回名称为key的zset（元素已按score从大到小排序）中member元素的rank（即index，从<span class="number">0</span>开始），若没有member元素，返回“nil”</span><br><span class="line"></span><br><span class="line">zrange(key, start, end)：返回名称为key的zset（元素已按score从小到大排序）中的index从start到end的所有元素</span><br><span class="line"></span><br><span class="line">zrevrange(key, start, end)：返回名称为key的zset（元素已按score从大到小排序）中的index从start到end的所有元素</span><br><span class="line"></span><br><span class="line">zrangebyscore(key, min, max)：返回名称为key的zset中score &gt;= min且score &lt;= max的所有元素</span><br><span class="line"></span><br><span class="line">zcard(key)：返回名称为key的zset的基数</span><br><span class="line"></span><br><span class="line">zscore(key, element)：返回名称为key的zset中元素element的score</span><br><span class="line"></span><br><span class="line">zremrangebyrank(key, min, max)：删除名称为key的zset中rank &gt;= min且rank &lt;= max的所有元素</span><br><span class="line"></span><br><span class="line">zremrangebyscore(key, min, max) ：删除名称为key的zset中score &gt;= min且score &lt;= max的所有元素</span><br><span class="line"></span><br><span class="line">zunionstore / zinterstore(dstkeyN, key1,…,keyN, WEIGHTS w1,…wN, AGGREGATE SUM|MIN|MAX)：对N个zset求并集和交集，并将最后的集合保存在dstkeyN中。对于集合中每一个元素的score，在进行AGGREGATE运算前，都要乘以对于的WEIGHT参数。如果没有提供WEIGHT，默认为<span class="number">1</span>。默认的AGGREGATE是SUM，即结果集合中元素的score是所有集合对应元素进行 SUM运算的值，而MIN和MAX是指，结果集合中元素的score是所有集合对应元素中最小值和最大值。</span><br></pre></td></tr></table></figure>
</li>
<li><p>对Hash操作的命令</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">hset(key, field, value)：向名称为key的hash中添加元素field&lt;—&gt;value</span><br><span class="line"></span><br><span class="line">hget(key, field)：返回名称为key的hash中field对应的value</span><br><span class="line"></span><br><span class="line">hmget(key, field1, …,field N)：返回名称为key的hash中field i对应的value</span><br><span class="line"></span><br><span class="line">hmset(key, field1, value1,…,field N, value N)：向名称为key的hash中添加元素field i&lt;—&gt;value i</span><br><span class="line"></span><br><span class="line">hincrby(key, field, integer)：将名称为key的hash中field的value增加integer</span><br><span class="line"></span><br><span class="line">hexists(key, field)：名称为key的hash中是否存在键为field的域</span><br><span class="line"></span><br><span class="line">hdel(key, field)：删除名称为key的hash中键为field的域</span><br><span class="line"></span><br><span class="line">hlen(key)：返回名称为key的hash中元素个数</span><br><span class="line"></span><br><span class="line">hkeys(key)：返回名称为key的hash中所有键</span><br><span class="line"></span><br><span class="line">hvals(key)：返回名称为key的hash中所有键对应的value</span><br><span class="line"></span><br><span class="line">hgetall(key)：返回名称为key的hash中所有的键（field）及其对应的value</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="各种数据类型所对应的应用场景"><a href="#各种数据类型所对应的应用场景" class="headerlink" title="各种数据类型所对应的应用场景"></a>各种数据类型所对应的应用场景</h3><ul>
<li><p><strong>String类型的应用场景</strong></p>
<p>String是最常用的一种数据类型,普通的key/value存储.</p>
</li>
<li><p><strong>list类型的应用场景</strong></p>
<p>比较适用于列表式存储且顺序相对比较固定，例如：</p>
<p>省份、城市列表</p>
<p>品牌、厂商、车系、车型等列表</p>
<p>拆车坊专题列表…</p>
</li>
<li><p><strong>set类型的应用场景</strong></p>
<p>Set对外提供的功能与list类似,当需要存储一个列表数据,又不希望出现重复数据时,可选用set</p>
</li>
<li><p><strong>zset(sorted set)类型的应用场景</strong></p>
<p>zset的使用场景与set类似,区别是set不是自动有序的,而zset可以通过用户额外提供一个优先级(score)的参数来为成员排序,并且是插入有序的,即自动排序.当你需要一个有序的并且不重复的集合列表,那么可以选择zset数据结构。例如:</p>
<p>根据PV排序的热门车系车型列表</p>
<p>根据时间排序的新闻列表</p>
</li>
<li><p><strong>hash类型的应用场景</strong></p>
<p>类似于表记录的存储</p>
<p>页面视图所需数据的存储</p>
</li>
</ul>
]]></content>
      
        <categories>
            
            <category> Redis </category>
            
        </categories>
        
        
        <tags>
            
            <tag> technology </tag>
            
            <tag> redis type </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[MySQL事务隔离级别详解]]></title>
      <url>/2018/01/07/MySQL%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E8%AF%A6%E8%A7%A3/</url>
      <content type="html"><![CDATA[<h3 id="四大特性"><a href="#四大特性" class="headerlink" title="四大特性"></a>四大特性</h3><ul>
<li><strong>原子性</strong><br>事务必须是原子工作单元；对于其数据修改，要么全都执行，要么全都不执行。通常，与某个事务关联的操作具有共同的目标，并且是相互依赖的。如果系统只执行这些操作的一个子集，则可能会破坏事务的总体目标。原子性消除了系统处理操作子集的可能性。  </li>
<li><strong>一致性</strong><br>事务在完成时，必须使所有的数据都保持一致状态。在相关数据库中，所有规则都必须应用于事务的修改，以保持所有数据的完整性。事务结束时，所有的内部数据结构（如 B 树索引或双向链表）都必须是正确的。某些维护一致性的责任由应用程序开发人员承担，他们必须确保应用程序已强制所有已知的完整性约束。例如，当开发用于转帐的应用程序时，应避免在转帐过程中任意移动小数点。  </li>
<li><strong>隔离性</strong><br>由并发事务所作的修改必须与任何其它并发事务所作的修改隔离。事务查看数据时数据所处的状态，要么是另一并发事务修改它之前的状态，要么是另一事务修改它之后的状态，事务不会查看中间状态的数据。这称为可串行性，因为它能够重新装载起始数据，并且重播一系列事务，以使数据结束时的状态与原始事务执行的状态相同。当事务可序列化时将获得最高的隔离级别。在此级别上，从一组可并行执行的事务获得的结果与通过连续运行每个事务所获得的结果相同。由于高度隔离会限制可并行执行的事务数，所以一些应用程序降低隔离级别以换取更大的吞吐量。  </li>
<li><strong>持久性</strong><br>事务完成之后，它对于系统的影响是永久性的。该修改即使出现致命的系统故障也将一直保持。  </li>
</ul>
<p>主要说说这个描述很抽象一致性，举个例子：A向B转账，假设转账之前这两个用户的钱加起来总共是2000，那么A向B转账之后，不管这两个账户怎么转，A用户的钱和B用户的钱加起来的总额还是2000，这个就是事务的一致性。</p>
<p>小结：原子性是事务隔离的基础，隔离性和持久性是手段，最终目的是为了保持数据的一致性。</p>
<a id="more"></a>
<h3 id="事务的并发问题"><a href="#事务的并发问题" class="headerlink" title="事务的并发问题"></a>事务的并发问题</h3><ul>
<li><p>脏读：事务A读取了事务B更新的数据，然后B回滚操作，那么A读取到的数据是脏数据</p>
</li>
<li><p>不可重复读：事务 A 多次读取同一数据，事务 B 在事务A多次读取的过程中，对数据作了更新并提交，导致事务A多次读取同一数据时，结果 不一致。</p>
</li>
<li><p>幻读：系统管理员A将数据库中所有学生的成绩从具体分数改为ABCDE等级，但是系统管理员B就在这个时候插入了一条具体分数的记录，当系统管理员A改结束后发现还有一条记录没有改过来，就好像发生了幻觉一样，这就叫幻读。</p>
</li>
</ul>
<p><strong>幻读和不可重复读的区别</strong></p>
<p><strong>不可重复读：</strong></p>
<p>不可重复读的重点是修改:同样的条件, 你读取过的数据, 再次读取出来发现值不一样了。</p>
<p>例子：</p>
<p>在事务1中，Mary 读取了自己的工资为1000,操作并没有完成 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">con1 = getConnection();  </span><br><span class="line">select salary from employee empId =<span class="string">"Mary"</span>;</span><br></pre></td></tr></table></figure>
<p>在事务2中，这时财务人员修改了Mary的工资为2000,并提交了事务. </p>
<p>con2 = getConnection();<br>update employee set salary = 2000;<br>con2.commit();  </p>
<p>在事务1中，Mary 再次读取自己的工资时，工资变为了2000 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//con1  </span></span><br><span class="line">select salary from employee empId =<span class="string">"Mary"</span>;</span><br></pre></td></tr></table></figure>
<p>在一个事务中前后两次读取的结果并不致，导致了不可重复读。</p>
<p><strong>幻读：</strong></p>
<p>幻读的重点在于新增或者删除同样的条件, 第1次和第2次读出来的记录数不一样</p>
<p>例子：</p>
<p>目前工资为1000的员工有10人。 事务1,读取所有工资为1000的员工。 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">con1 = getConnection();  </span><br><span class="line">Select * from employee where salary =<span class="number">1000</span>;</span><br></pre></td></tr></table></figure>
<p>共读取10条记录 </p>
<p>这时另一个事务向employee表插入了一条员工记录，工资也为1000 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">con2 = getConnection();  </span><br><span class="line"><span class="function">Insert into <span class="title">employee</span><span class="params">(empId,salary)</span> <span class="title">values</span><span class="params">(<span class="string">"Lili"</span>,<span class="number">1000</span>)</span></span>;  </span><br><span class="line">con2.commit();</span><br></pre></td></tr></table></figure>
<p>事务1再次读取所有工资为1000的员工 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//con1  </span></span><br><span class="line">select * from employee where salary =<span class="number">1000</span>;</span><br></pre></td></tr></table></figure>
<p>共读取到了11条记录，这就产生了幻像读。 </p>
<h3 id="四种隔离级别"><a href="#四种隔离级别" class="headerlink" title="四种隔离级别"></a>四种隔离级别</h3><ul>
<li><p><strong>Read Uncommitted（读取未提交内容）</strong><br>在该隔离级别，所有事务都可以看到其他未提交事务的执行结果。本隔离级别很少用于实际应用，因为它的性能也不比其他级别好多少。读取未提交的数据，也被称之为脏读（Dirty Read）。</p>
</li>
<li><p><strong>Read Committed（读取提交内容）</strong><br>这是大多数数据库系统的默认隔离级别（但不是MySQL默认的）。它满足了隔离的简单定义：一个事务只能看见已经提交事务所做的改变。这种隔离级别 也支持所谓的不可重复读（Nonrepeatable Read），因为同一事务的其他实例在该实例处理其间可能会有新的commit，所以同一select可能返回不同结果。</p>
</li>
<li><p><strong>Repeatable Read（可重读）</strong><br>这是MySQL的默认事务隔离级别，它确保同一事务的多个实例在并发读取数据时，会看到同样的数据行。不过理论上，这会导致另一个棘手的问题：幻读 （Phantom Read）。简单的说，幻读指当用户读取某一范围的数据行时，另一个事务又在该范围内插入了新行，当用户再读取该范围的数据行时，会发现有新的“幻影” 行。InnoDB和Falcon存储引擎通过多版本并发控制（MVCC，Multiversion Concurrency Control）机制解决了该问题。</p>
</li>
<li><p><strong>Serializable（可串行化）</strong><br>这是最高的隔离级别，它通过强制事务排序，使之不可能相互冲突，从而解决幻读问题。简言之，它是在每个读的数据行上加上共享锁。在这个级别，可能导致大量的超时现象和锁竞争。</p>
</li>
</ul>
<p>这四种隔离级别采取不同的锁类型来实现，若读取的是同一个数据的话，就容易发生问题。例如：<br>脏读(Drity Read)：某个事务已更新一份数据，另一个事务在此时读取了同一份数据，由于某些原因，前一个RollBack了操作，则后一个事务所读取的数据就会是不正确的。</p>
<p>不可重复读(Non-repeatable read):在一个事务的两次查询之中数据不一致，这可能是两次查询过程中间插入了一个事务更新的原有的数据。</p>
<p>幻读(Phantom Read):在一个事务的两次查询中数据笔数不一致，例如有一个事务查询了几列(Row)数据，而另一个事务却在此时插入了新的几列数据，先前的事务在接下来的查询中，就会发现有几列数据是它先前所没有的。</p>
<p>在MySQL中，实现了这四种隔离级别，分别有可能产生问题如下所示：</p>
<table>
<thead>
<tr>
<th>隔离级别</th>
<th>脏读</th>
<th>不可重复读</th>
<th>幻读</th>
</tr>
</thead>
<tbody>
<tr>
<td>读未提交(Read uncommitted)</td>
<td>√</td>
<td>√</td>
<td>√</td>
</tr>
<tr>
<td>读已提交(Read committed)</td>
<td>×</td>
<td>√</td>
<td>√</td>
</tr>
<tr>
<td>可重复读(Repeatable read)</td>
<td>×</td>
<td>×</td>
<td>√</td>
</tr>
<tr>
<td>可串行化(Serializable)</td>
<td>×</td>
<td>×</td>
<td>×</td>
</tr>
</tbody>
</table>
<h3 id="数据库的各种锁的总结"><a href="#数据库的各种锁的总结" class="headerlink" title="数据库的各种锁的总结"></a>数据库的各种锁的总结</h3><ul>
<li><p><strong>共享锁（又称读锁）、排它锁（又称写锁）</strong></p>
<p>  InnoDB引擎的锁机制：InnoDB支持事务，支持行锁和表锁用的比较多，Myisam不支持事务，只支持表锁。</p>
<p>  说明：</p>
<p>  1）共享锁和排他锁都是行锁，意向锁都是表锁，应用中我们只会使用到共享锁和排他锁，意向锁是mysql内部使用的，不需要用户干预。</p>
<p>  2）对于UPDATE、DELETE和INSERT语句，InnoDB会自动给涉及数据集加排他锁（X)；对于普通SELECT语句，InnoDB不会加任何锁，事务可以通过以下语句显示给记录集加共享锁或排他锁。</p>
<p>  共享锁（S）：SELECT <em> FROM table_name WHERE … LOCK IN SHARE MODE。<br>  排他锁（X)：SELECT </em> FROM table_name WHERE … FOR UPDATE。</p>
<p>  对于锁定行记录后需要进行更新操作的应用，应该使用Select…For update 方式，获取排它锁。（用共享锁，在读了之后再写会阻塞，会导致死锁）</p>
<p>  这里说说Myisam：MyISAM在执行查询语句(SELECT)前，会自动给涉及的所有表加读锁，在执行更新操作(UPDATE、DELETE、INSERT等)前，会自动给涉及的表加写锁。</p>
<p>  3）InnoDB行锁是通过给索引上的索引项加锁来实现的，因此InnoDB这种行锁实现特点意味着：只有通过索引条件检索数据，InnoDB才使用行级锁，否则，InnoDB将使用表锁！</p>
</li>
<li><p><strong>乐观锁、悲观锁</strong></p>
<p>  <strong>悲观锁：</strong><br>  悲观锁，正如其名，它指的是对数据被外界（包括本系统当前的其他事务，以及来自外部系统的事务处理）修改持保守态度，因此，在整个数据处理过程中，将数据处于锁定状态。悲观锁的实现，往往依靠数据库提供的锁机制（也只有数据库层提供的锁机制才能真正保证数据访问的排他性，否则，即使在本系统中实现了加锁机制，也无法保证外部系统不会修改数据）</p>
<p>  1）使用悲观锁，我们必须关闭mysql数据库的自动提交属性，采用手动提交事务的方式，因为MySQL默认使用autocommit模式，也就是说，当你执行一个更新操作后，MySQL会立刻将结果进行提交。</p>
<p>  2）需要注意的是，在事务中，只有SELECT … FOR UPDATE 或LOCK IN SHARE MODE 同一笔数据时会等待其它事务结束后才执行，一般SELECT … 则不受此影响。对于UPDATE、DELETE和INSERT语句，InnoDB会自动给涉及数据集加排他锁（X)。</p>
<p>  3）补充：MySQL select…for update的Row Lock与Table Lock</p>
<p>  使用select…for update会把数据给锁住，不过我们需要注意一些锁的级别，MySQL InnoDB默认Row-Level Lock，所以只有「明确」地指定主键（或有索引的地方），MySQL 才会执行Row lock (只锁住被选取的数据) ，否则MySQL 将会执行Table Lock (将整个数据表单给锁住)。</p>
<p>  <strong>乐观锁：</strong><br>  乐观锁（ Optimistic Locking ） 相对悲观锁而言，乐观锁假设认为数据一般情况下不会造成冲突，所以在数据进行提交更新的时候，才会正式对数据的冲突与否进行检测，如果发现冲突了，则让返回用户错误的信息，让用户决定如何去做（一般是回滚事务）。那么我们如何实现乐观锁呢，一般来说有以下2种方式：</p>
<p>  1）.使用数据版本（Version）记录机制实现，这是乐观锁最常用的一种实现方式。何谓数据版本？即为数据增加一个版本标识，一般是通过为数据库表增加一个数字类型的 “version” 字段来实现。当读取数据时，将version字段的值一同读出，数据每更新一次，对此version值加一。当我们提交更新的时候，判断数据库表对应记录的当前版本信息与第一次取出来的version值进行比对，如果数据库表当前版本号与第一次取出来的version值相等，则予以更新，否则认为是过期数据。</p>
<p>  2）.乐观锁定的第二种实现方式和第一种差不多，同样是在需要乐观锁控制的table中增加一个字段，名称无所谓，字段类型使用时间戳（timestamp）, 和上面的version类似，也是在更新提交的时候检查当前数据库中数据的时间戳和自己更新前取到的时间戳进行对比，如果一致则OK，否则就是版本冲突。</p>
<p>  <strong>总结：</strong><br>  两种锁各有优缺点，不可认为一种好于另一种，像乐观锁适用于写比较少的情况下，即冲突真的很少发生的时候，这样可以省去了锁的开销，加大了系统的整个吞吐量。但如果经常产生冲突，上层应用会不断的进行retry，这样反倒是降低了性能，所以这种情况下用悲观锁就比较合适。</p>
<p>  另外，高并发情况下个人认为乐观锁要好于悲观锁，因为悲观锁的机制使得各个线程等待时间过长，极其影响效率，乐观锁可以在一定程度上提高并发度。</p>
</li>
<li><p><strong>表锁、行锁</strong></p>
<p>  表级锁(table-level locking)：MyISAM和MEMORY存储引擎</p>
<p>  行级锁(row-level locking) ：InnoDB存储引擎</p>
<p>  页面锁(page-level-locking)：BDB存储引擎</p>
<p>  表级锁：开销小，加锁快;不会出现死锁;锁定粒度大，发生锁冲突的概率最高,并发度最低。</p>
<p>  行级锁：开销大，加锁慢;会出现死锁;锁定粒度最小，发生锁冲突的概率最低,并发度也最高。</p>
<p>  页面锁：开销和加锁时间界于表锁和行锁之间;会出现死锁;锁定粒度界于表锁和行锁之间，并发度一般。</p>
</li>
</ul>
]]></content>
      
        <categories>
            
            <category> Mysql </category>
            
        </categories>
        
        
        <tags>
            
            <tag> technology </tag>
            
            <tag> mysql transaction </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Mysql索引]]></title>
      <url>/2018/01/07/Mysql%E7%B4%A2%E5%BC%95/</url>
      <content type="html"><![CDATA[<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>首先:先假设有一张表,表的数据有10W条数据,其中有一条数据是nickname=’css’,如果要拿这条数据的话需要些的sql是 SELECT * FROM award WHERE nickname = ‘css’</p>
<p>一般情况下,在没有建立索引的时候,mysql需要扫描全表及扫描10W条数据找这条数据,如果我在nickname上建立索引,那么mysql只需要扫描一行数据及为我们找到这条nickname=’css’的数据,是不是感觉性能提升了好多咧….</p>
<h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><p>mysql的索引分为单列索引(主键索引,唯索引,普通索引)和组合索引。</p>
<p>单列索引:一个索引只包含一个列,一个表可以有多个单列索引。</p>
<p>组合索引:一个组合索引包含两个或两个以上的列。</p>
<h3 id="案例使用的表"><a href="#案例使用的表" class="headerlink" title="案例使用的表"></a>案例使用的表</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`award`</span> (</span><br><span class="line">   <span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT <span class="keyword">COMMENT</span> <span class="string">'用户id'</span>,</span><br><span class="line">   <span class="string">`aty_id`</span> <span class="built_in">varchar</span>(<span class="number">100</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">''</span> <span class="keyword">COMMENT</span> <span class="string">'活动场景id'</span>,</span><br><span class="line">   <span class="string">`nickname`</span> <span class="built_in">varchar</span>(<span class="number">12</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">''</span> <span class="keyword">COMMENT</span> <span class="string">'用户昵称'</span>,</span><br><span class="line">   <span class="string">`is_awarded`</span> tinyint(<span class="number">1</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="number">0</span> <span class="keyword">COMMENT</span> <span class="string">'用户是否领奖'</span>,</span><br><span class="line">   <span class="string">`award_time`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="number">0</span> <span class="keyword">COMMENT</span> <span class="string">'领奖时间'</span>,</span><br><span class="line">   <span class="string">`account`</span> <span class="built_in">varchar</span>(<span class="number">12</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">''</span> <span class="keyword">COMMENT</span> <span class="string">'帐号'</span>,</span><br><span class="line">   <span class="string">`password`</span> <span class="built_in">char</span>(<span class="number">32</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">''</span> <span class="keyword">COMMENT</span> <span class="string">'密码'</span>,</span><br><span class="line">   <span class="string">`message`</span> <span class="built_in">varchar</span>(<span class="number">255</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">''</span> <span class="keyword">COMMENT</span> <span class="string">'获奖信息'</span>,</span><br><span class="line">   <span class="string">`created_time`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="number">0</span> <span class="keyword">COMMENT</span> <span class="string">'创建时间'</span>,</span><br><span class="line">   <span class="string">`updated_time`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="number">0</span> <span class="keyword">COMMENT</span> <span class="string">'更新时间'</span>,</span><br><span class="line">   PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>)</span><br><span class="line"> ) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> AUTO_INCREMENT=<span class="number">1</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8 <span class="keyword">COMMENT</span>=<span class="string">'获奖信息表'</span>;</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h3 id="索引的创建"><a href="#索引的创建" class="headerlink" title="索引的创建"></a>索引的创建</h3><ul>
<li><p><strong>单列索引</strong></p>
<ol>
<li><p>普通索引,这个是最基本的索引。</p>
<p>其sql格式是 CREATE INDEX IndexName ON <code>TableName</code>(<code>字段名</code>(length)) 或者 ALTER TABLE TableName ADD INDEX IndexName(<code>字段名</code>(length))</p>
<p><strong>第一种方式 :</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">INDEX</span> account_Index <span class="keyword">ON</span> <span class="string">`award`</span>(<span class="string">`account`</span>);</span><br></pre></td></tr></table></figure>
<p><strong>第二种方式: </strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> award <span class="keyword">ADD</span> <span class="keyword">INDEX</span> account_Index(<span class="string">`account`</span>)</span><br></pre></td></tr></table></figure>
<p>如果是CHAR,VARCHAR,类型,length可以小于字段的实际长度,如果是BLOB和TEXT类型就必须指定长度。</p>
</li>
<li><p>唯一索引,与普通索引类似,但是不同的是唯一索引要求所有的类的值是唯一的,这一点和主键索引一样.但是他允许有空值。</p>
<p>其sql格式是 CREATE UNIQUE INDEX IndexName ON <code>TableName</code>(<code>字段名</code>(length)); 或者 ALTER TABLE TableName ADD UNIQUE (column_list)  </p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">UNIQUE</span> <span class="keyword">INDEX</span> account_UNIQUE_Index <span class="keyword">ON</span> <span class="string">`award`</span>(<span class="string">`account`</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>主键索引,不允许有空值,(在B+TREE中的InnoDB引擎中,主键索引起到了至关重要的地位)</p>
<p>主键索引建立的规则是 int优于varchar,一般在建表的时候创建,最好是与表的其他字段不相关的列或者是业务不相关的列.一般会设为 int 而且是 AUTO_INCREMENT自增类型的</p>
</li>
</ol>
</li>
<li><p><strong>组合索引</strong></p>
<p>  一个表中含有多个单列索引不代表是组合索引,通俗一点讲 组合索引是:包含多个字段但是只有索引名称。</p>
<p>  其sql格式是 CREATE INDEX IndexName On <code>TableName</code>(<code>字段名</code>(length),<code>字段名</code>(length),…);</p>
  <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">INDEX</span> nickname_account_createdTime_Index <span class="keyword">ON</span> <span class="string">`award`</span>(<span class="string">`nickname`</span>, <span class="string">`account`</span>, <span class="string">`created_time`</span>);</span><br></pre></td></tr></table></figure>
<p>  如果你建立了 组合索引(nickname_account_createdTime_Index) 那么他实际包含的是3个索引 (nickname) (nickname,account)(nickname,account,created_time)</p>
<p>  在使用查询的时候遵循mysql组合索引的”最左前缀”,下面我们来分析一下 什么是最左前缀:及索引where时的条件要按照建立索引的时候字段的排序方式。</p>
<ol>
<li><p>不按索引最左列开始查询（多列索引） 例如index(‘c1’, ‘c2’, ‘c3’) where ‘c2’ = ‘aaa’ 不使用索引,where <code>c2</code> = <code>aaa</code> and <code>c3</code>=<code>sss</code> 不能使用索引</p>
</li>
<li><p>查询中某个列有范围查询，则其右边的所有列都无法使用查询（多列查询）</p>
<p>Where c1= ‘xxx’ and c2 like = ‘aa%’ and c3=’sss’ 改查询只会使用索引中的前两列,因为like是范围查询</p>
</li>
<li><p>不能跳过某个字段来进行查询,这样利用不到索引,比如我的sql 是 </p>
<p>explain select * from <code>award</code> where nickname &gt; ‘rSUQFzpkDz3R’ and account = ‘DYxJoqZq2rd7’ and created_time = 1449567822; 那么这时候他使用不到其组合索引.</p>
<p>因为我的索引是 (nickname, account, created_time),如果第一个字段出现 范围符号的查找,那么将不会用到索引,如果我是第二个或者第三个字段使用范围符号的查找,那么他会利用索引,利用的索引是(nickname),</p>
<p>因为上面说了建立组合索引(nickname, account, created_time), 会出现三个索引</p>
</li>
</ol>
</li>
<li><p><strong>全文索引</strong></p>
<p>  文本字段上(text)如果建立的是普通索引,那么只有对文本的字段内容前面的字符进行索引,其字符大小根据索引建立索引时申明的大小来规定.</p>
<p>  如果文本中出现多个一样的字符,而且需要查找的话,那么其条件只能是 where column lick ‘%xxxx%’ 这样做会让索引失效</p>
<p>  这个时候全文索引就祈祷了作用了</p>
  <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> tablename <span class="keyword">ADD</span> FULLTEXT(column1, column2)</span><br></pre></td></tr></table></figure>
<p>  有了全文索引，就可以用SELECT查询命令去检索那些包含着一个或多个给定单词的数据记录了。</p>
  <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">ELECT * FROM tablename</span><br><span class="line">WHERE MATCH(column1, column2) AGAINST(‘xxx′, ‘sss′, ‘ddd′)</span><br></pre></td></tr></table></figure>
<p>  这条命令将把column1和column2字段里有xxx、sss和ddd的数据记录全部查询出来。</p>
</li>
</ul>
<h3 id="索引的删除"><a href="#索引的删除" class="headerlink" title="索引的删除"></a>索引的删除</h3><p>删除索引的mysql格式 : DORP INDEX IndexName ON <code>TableName</code></p>
<h3 id="使用索引的优点"><a href="#使用索引的优点" class="headerlink" title="使用索引的优点"></a>使用索引的优点</h3><ol>
<li>可以通过建立唯一索引或者主键索引,保证数据库表中每一行数据的唯一性.</li>
<li>建立索引可以大大提高检索的数据,以及减少表的检索行数</li>
<li>在表连接的连接条件 可以加速表与表直接的相连 </li>
<li>在分组和排序字句进行数据检索,可以减少查询时间中 分组 和 排序时所消耗的时间(数据库的记录会重新排序)</li>
<li>建立索引,在查询中使用索引 可以提高性能</li>
</ol>
<h3 id="使用索引的缺点"><a href="#使用索引的缺点" class="headerlink" title="使用索引的缺点"></a>使用索引的缺点</h3><ol>
<li>在创建索引和维护索引 会耗费时间,随着数据量的增加而增加</li>
<li>索引文件会占用物理空间,除了数据表需要占用物理空间之外,每一个索引还会占用一定的物理空间</li>
<li>当对表的数据进行 INSERT,UPDATE,DELETE 的时候,索引也要动态的维护,这样就会降低数据的维护速度,(建立索引会占用磁盘空间的索引文件。一般情况这个问题不太严重，但如果你在一个大表上创建了多种组合索引，索引文件的会膨胀很快)。</li>
</ol>
<h3 id="使用索引需要注意的地方"><a href="#使用索引需要注意的地方" class="headerlink" title="使用索引需要注意的地方"></a>使用索引需要注意的地方</h3><p>在建立索引的时候应该考虑索引应该建立在数据库表中的某些列上面 哪一些索引需要建立,哪一些索引是多余的.</p>
<p>一般来说：</p>
<ol>
<li>在经常需要搜索的列上,可以加快索引的速度</li>
<li>主键列上可以确保列的唯一性</li>
<li>在表与表的而连接条件上加上索引,可以加快连接查询的速度</li>
<li>在经常需要排序(order by),分组(group by)和distinct 列上加索引 可以加快排序查询的时间,  (单独order by 用不了索引，索引考虑加where 或加limit)</li>
<li>在一些where 之后的 &lt; &lt;= &gt; &gt;= BETWEEN IN 以及某个情况下的like 建立字段的索引(B-TREE)</li>
<li>like语句的 如果你对nickname字段建立了一个索引.当查询的时候的语句是 nickname like ‘%ABC%’ 那么这个索引讲不会起到作用.而nickname like ‘ABC%’ 那么将可以用到索引</li>
<li>索引不会包含NULL列,如果列中包含NULL值都将不会被包含在索引中,复合索引中如果有一列含有NULL值那么这个组合索引都将失效,一般需要给默认值0或者 ‘ ‘字符串</li>
<li>使用短索引,如果你的一个字段是Char(32)或者int(32),在创建索引的时候指定前缀长度 比如前10个字符 (前提是多数值是唯一的..)那么短索引可以提高查询速度,并且可以减少磁盘的空间,也可以减少I/0操作.</li>
<li>不要在列上进行运算,这样会使得mysql索引失效,也会进行全表扫描</li>
<li>选择越小的数据类型越好,因为通常越小的数据类型通常在磁盘,内存,cpu,缓存中 占用的空间很少,处理起来更快</li>
</ol>
<h3 id="什么情况下不创建索引"><a href="#什么情况下不创建索引" class="headerlink" title="什么情况下不创建索引"></a>什么情况下不创建索引</h3><ol>
<li>查询中很少使用到的列 不应该创建索引,如果建立了索引然而还会降低mysql的性能和增大了空间需求.</li>
<li>很少数据的列也不应该建立索引,比如 一个性别字段 0或者1,在查询中,结果集的数据占了表中数据行的比例比较大,mysql需要扫描的行数很多,增加索引,并不能提高效率</li>
<li>定义为text和image和bit数据类型的列不应该增加索引,</li>
<li>当表的修改(UPDATE,INSERT,DELETE)操作远远大于检索(SELECT)操作时不应该创建索引,这两个操作是互斥的关系</li>
</ol>
]]></content>
      
        <categories>
            
            <category> Mysql </category>
            
        </categories>
        
        
        <tags>
            
            <tag> technology </tag>
            
            <tag> mysql index </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[装饰者模式]]></title>
      <url>/2018/01/07/%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
      <content type="html"><![CDATA[<h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>装饰者模式：在不改变原类文件以及不使用继承的情况下，动态地将责任附加到对象上，从而实现动态拓展一个对象的功能。它是通过创建一个包装对象，也就是装饰来包裹真实的对象。</p>
<h3 id="设计原则"><a href="#设计原则" class="headerlink" title="设计原则"></a>设计原则</h3><p>要使用装饰者模式，需要满足以下设计原则：</p>
<ol>
<li>多用组合，少用继承</li>
<li>开放-关闭原则：类应该对拓展开放，对修改关闭</li>
</ol>
<h3 id="UML类图"><a href="#UML类图" class="headerlink" title="UML类图"></a>UML类图</h3><p>我们先来看看装饰者模式的类图，再来详细讲述：</p>
<a id="more"></a>
<p><img src="https://github.com/dicheng52119/dicheng52119.github.io/blob/master/images/design-mode/%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8FUML%E7%B1%BB%E5%9B%BE.png?raw=true" alt=""></p>
<p>由上自下：</p>
<ol>
<li><strong>Component</strong>是基类。通常是一个抽象类或者一个接口，定义了属性或者方法，方法的实现可以由子类实现或者自己实现。通常不会直接使用该类，而是通过继承该类来实现特定的功能，它约束了整个继承树的行为。比如说，如果Component代表人，即使通过装饰也不会使人变成别的动物。</li>
<li><strong>ConcreteComponent</strong>是Component的子类，实现了相应的方法，它充当了“被装饰者”的角色。</li>
<li><strong>Decorator</strong>也是Component的子类，它是装饰者共同实现的抽象类（也可以是接口）。比如说，Decorator代表衣服这一类装饰者，那么它的子类应该是T恤、裙子这样的具体的装饰者。</li>
<li><strong>ConcreteDecorator</strong>是Decorator的子类，是具体的装饰者，由于它同时也是Component的子类，因此它能方便地拓展Component的状态（比如添加新的方法）。每个装饰者都应该有一个实例变量用以保存某个Component的引用，这也是利用了组合的特性。在持有Component的引用后，由于其自身也是Component的子类，那么，相当于ConcreteDecorator包裹了Component，不但有Component的特性，同时自身也可以有别的特性，也就是所谓的<strong>装饰</strong>。</li>
</ol>
<h3 id="A-Sample"><a href="#A-Sample" class="headerlink" title="A Sample"></a>A Sample</h3><p>为了更加深刻地理解装饰者模式，我们来看一个简单的栗子。首先，我们假设现在有这样一个需求：你有一家服装店，卖各式各样的衣服，现在需要用一个系统来记录客户所要购买的衣服的总价，以便方便地结算。那么在这个例子里面，我们可以用装饰者模式，把客户当做被装饰者，衣服是装饰者，这很直观形象吧，接着我们来一步步实现需求。</p>
<p><strong>创建Component基类</strong></p>
<p>因为总体对象是人，所以我们可以把人抽象为基类，新建Person.java<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    String description = <span class="string">"Unkonwn"</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getDescription</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> description;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">double</span> <span class="title">cost</span><span class="params">()</span></span>; <span class="comment">//子类应该实现的方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>创建被装饰者——ConcreteComponent</strong></p>
<p>客户分为很多种，有儿童、青少年、成年人等，因此我们可以创建不同的被装饰者，这里我们创建青少年的被装饰者，新建Teenager.java<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Teenager</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Teenager</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        description = <span class="string">"Shopping List:"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">cost</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//什么都没买，不用钱</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>创建Decorator</strong></p>
<p>由于不同的部位有不同的衣物，不能混为一谈，比如说，衣服、帽子、鞋子等，那么这里我们创建的Decorator为衣服和帽子，分别新建ClothingDecorator.java和HatDecorator.java<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ClothingDecorator</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> String <span class="title">getDescription</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">HatDecorator</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> String <span class="title">getDescription</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>创建ConcreteDecorator</strong></p>
<p>上面既然已经创建了两种Decorator，那么我们基于它们进行拓展，创建出不同的装饰者，对于Clothing，我们新建Shirt.java，对于Hat，我们新建Casquette，其实可以根据不同类型的衣物创建更多不同的装饰者，这里只是作为演示而创建了两种。代码如下所示：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Shirt</span> <span class="keyword">extends</span> <span class="title">ClothingDecorator</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//用实例变量保存Person的引用</span></span><br><span class="line">    Person person;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Shirt</span><span class="params">(Person person)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.person = person;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getDescription</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> person.getDescription() + <span class="string">"a shirt  "</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">cost</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">100</span> + person.cost(); <span class="comment">//实现了cost()方法，并调用了person的cost()方法，目的是获得所有累加值</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Casquette</span> <span class="keyword">extends</span> <span class="title">HatDecorator</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    Person person;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Casquette</span><span class="params">(Person person)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.person = person;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getDescription</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> person.getDescription() + <span class="string">"a casquette  "</span>; <span class="comment">//鸭舌帽</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">cost</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">75</span> + person.cost();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后我们在测试类内测试我们的代码：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Shopping</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Person person = <span class="keyword">new</span> Teenager();</span><br><span class="line">        </span><br><span class="line">        person = <span class="keyword">new</span> Shirt(person);</span><br><span class="line">        person = <span class="keyword">new</span> Casquette(person);</span><br><span class="line">        </span><br><span class="line">        System.out.println(person.getDescription() + <span class="string">" ￥ "</span> +person.cost());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>先创建一个Teenager对象，接着用Shirt装饰它，就变成了穿着Shirt的Teenager，再用Casquette装饰，就变成了戴着Casquette的穿着Shirt的Teenager。运行结果如下所示：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Shopping List:a shirt  a casquette ¥175.0</span><br></pre></td></tr></table></figure></p>
<p>我们梳理一下以上的逻辑，画出如下所示的韦恩图：</p>
<p><img src="https://github.com/dicheng52119/dicheng52119.github.io/blob/master/images/design-mode/%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F%E9%9F%A6%E6%81%A9%E5%9B%BE.png?raw=true" alt=""></p>
<p>Teenager、Shirt、Casquette都是继承自Person基类，但是具体实现不同，Teenager是Person的直接子类，表示了被装饰者；Teenager、Shirt是装饰者，保存了Person的引用，实现了cost()方法，并且在cost()方法内部，不但实现了自己的逻辑，同时也调用了Person引用的cost()方法，即获取了被装饰者的信息，这是装饰者的一个特点，保存引用的目的就是为了获取被装饰者的状态信息，以便将自身的特性加以组合。</p>
<h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><p>以上就是装饰者模式的一个小栗子，讲述了装饰者的基本用法。通过上述的例子，我们可以总结一下装饰者模式的特点。</p>
<ol>
<li>装饰者和被装饰者有相同的接口（或有相同的父类）。</li>
<li>装饰者保存了一个被装饰者的引用。</li>
<li>装饰者接受所有客户端的请求，并且这些请求最终都会返回给被装饰者（参见韦恩图）。</li>
<li>在运行时动态地为对象添加属性，不必改变对象的结构。</li>
</ol>
<p>使用装饰者模式的最大好处就是其拓展性十分良好，通过使用不同的装饰类来使得对象具有多种多样的属性，灵活性比直接继承好。然而它也有缺点，那就是会出现很多小类，即装饰类，使程序变得复杂。</p>
<h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><p>学习了装饰者模式用法、特点以及优缺点后，我们再来看看装饰者模式在实际开发过程的应用。装饰者模式在Java中经常出现的地方就是JavaIO。提到JavaIO，脑海中就冒出了大量的类：InputStream、FileInputStream、BufferedInputStream……等，真是头都大了，其实，这里面大部分都是装饰类，只要弄清楚这一点就容易理解了。我们来看看JavaIO是怎样使用装饰者模式的。</p>
<p>从字符流来分析，我们知道，有两个基类，分别是InputStream和OutputStream，它们也就是我们上面所述的Component基类。接着，它有如下子类：FileInputStream、StringBufferInputStream等，它们就代表了上面所述的ConcreteComponent，即装饰对象。此外，InputStream还有FilterInputStream这个子类，它就是一个抽象装饰者，即Decorator，那么它的子类：BufferedInputStream、DataInputStream等就是具体的装饰者了。那么，从装饰者模式的角度来看JavaIO，是不是更加容易理解了呢？</p>
<p>下面，我们来自己实现自己的JavaIO的装饰者。要实现的功能是：把一段话里面的每个单词的首字母大写。我们先新建一个类：UpperFirstWordInputStream.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UpperFirstWordInputStream</span> <span class="keyword">extends</span> <span class="title">FilterInputStream</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> cBefore = <span class="number">32</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">UpperFirstWordInputStream</span><span class="params">(InputStream in)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//由于FilterInputStream已经保存了装饰对象的引用，这里直接调用super即可</span></span><br><span class="line">        <span class="keyword">super</span>(in);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">        <span class="comment">//根据前一个字符是否是空格来判断是否要大写</span></span><br><span class="line">        <span class="keyword">int</span> c = <span class="keyword">super</span>.read();</span><br><span class="line">        <span class="keyword">if</span>(cBefore == <span class="number">32</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cBefore = c;</span><br><span class="line">            <span class="keyword">return</span> (c == -<span class="number">1</span> ? c: Character.toUpperCase((<span class="keyword">char</span>) c));</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            cBefore = c;</span><br><span class="line">            <span class="keyword">return</span> c;</span><br><span class="line">        &#125;</span><br><span class="line">            </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接着编写一个测试类：InputTest.java<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InputTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> c;</span><br><span class="line">        StringBuffer sb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//这里用了两个装饰者，分别是BufferedInputStream和我们的UpperFirstWordInputStream</span></span><br><span class="line">            InputStream in = <span class="keyword">new</span> UpperFirstWordInputStream(<span class="keyword">new</span> BufferedInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">"test.txt"</span>)));</span><br><span class="line">            <span class="keyword">while</span>((c = in.read()) &gt;= <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                sb.append((<span class="keyword">char</span>) c);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(sb);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>（注意：上面的test.txt文件需要你自行创建，放到同一个文件夹内即可，内容可随意填写。）<br>最后，我们看下运行结果：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Here Are Some Words.</span><br></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> Design Pattern </category>
            
        </categories>
        
        
        <tags>
            
            <tag> technology </tag>
            
            <tag> design pattern </tag>
            
            <tag> Decorator </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[适配器模式]]></title>
      <url>/2018/01/07/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/</url>
      <content type="html"><![CDATA[<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>适配器就是一种适配中间件，它存在于不匹配的二者之间，用于连接二者，将不匹配变得匹配，简单点理解就是平常所见的转接头，转换器之类的存在。</p>
<p>适配器模式有三种：类适配器、对象适配器、接口适配器</p>
<p>前二者在实现上有些许区别，作用一样，第三个接口适配器差别较大。</p>
<h3 id="类适配器模式"><a href="#类适配器模式" class="headerlink" title="类适配器模式"></a>类适配器模式</h3><p>原理：通过继承来实现适配器功能。</p>
<p>当我们要访问的接口A中没有我们想要的方法，却在另一个接口B中发现了合适的方法，我们又不能改变访问接口A，在这种情况下，我们可以定义一个适配器p来进行中转，这个适配器p要实现我们访问的接口A，这样我们就能继续访问当前接口A中的方法（虽然它目前不是我们的菜），然后再继承接口B的实现类BB，这样我们可以在适配器P中访问接口B的方法了，这时我们在适配器P中的接口A方法中直接引用BB中的合适方法，这样就完成了一个简单的类适配器。</p>
<p>详见下方实例：我们以ps2与usb的转接为例</p>
<a id="more"></a>
<p>ps2接口：Ps2<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Ps2</span> </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">void</span> <span class="title">isPs2</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>USB接口：Usb<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Usb</span> </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">void</span> <span class="title">isUsb</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>USB接口实现类：Usber<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Usber</span> <span class="keyword">implements</span> <span class="title">Usb</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">isUsb</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"USB口"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>适配器：Adapter<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Adapter</span> <span class="keyword">extends</span> <span class="title">Usber</span> <span class="keyword">implements</span> <span class="title">Ps2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">isPs2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        isUsb();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>测试方法：Clienter<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Clienter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Ps2 p = <span class="keyword">new</span> Adapter();</span><br><span class="line">        p.isPs2();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>显示结果：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">USB口</span><br></pre></td></tr></table></figure></p>
<p>实例讲解：</p>
<p>我手中有个ps2插头的设备，但是主机上只有usb插头的插口，怎么办呢？弄个转换器，将ps2插头转换成为USB插头就可以使用了。</p>
<p>接口Ps2：描述ps2接口格式</p>
<p>接口Usb：描述USB接口格式</p>
<p>类Usber：是接口Usb的实现类，是具体的USB接口格式</p>
<p>Adapter：用于将ps2接口格式转换成为USB接口格式</p>
<h3 id="对象适配器模式"><a href="#对象适配器模式" class="headerlink" title="对象适配器模式"></a>对象适配器模式</h3><p>原理：通过组合来实现适配器功能。</p>
<p>当我们要访问的接口A中没有我们想要的方法 ，却在另一个接口B中发现了合适的方法，我们又不能改变访问接口A，在这种情况下，我们可以定义一个适配器p来进行中转，这个适配器p要实现我们访问的接口A，这样我们就能继续访问当前接口A中的方法（虽然它目前不是我们的菜），然后在适配器P中定义私有变量C（对象）（B接口指向变量名），再定义一个带参数的构造器用来为对象C赋值，再在A接口的方法实现中使用对象C调用其来源于B接口的方法。</p>
<p>详见下方实例：我们仍然以ps2与usb的转接为例</p>
<p>ps2接口：Ps2<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Ps2</span> </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">void</span> <span class="title">isPs2</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>USB接口：Usb<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Usb</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">isUsb</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>USB接口实现类：Usber<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Usber</span> <span class="keyword">implements</span> <span class="title">Usb</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">isUsb</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"USB口"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>适配器：Adapter<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Adapter</span> <span class="keyword">implements</span> <span class="title">Ps2</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> Usb usb;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Adapter</span><span class="params">(Usb usb)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.usb = usb;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">isPs2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        usb.isUsb();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>测试类：Clienter<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Clienter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Ps2 p = <span class="keyword">new</span> Adapter(<span class="keyword">new</span> Usber());</span><br><span class="line">        p.isPs2();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>结果显示：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">USB口</span><br></pre></td></tr></table></figure></p>
<p>实例讲解：</p>
<p>我手中有个ps2插头的设备，但是主机上只有usb插头的插口，怎么办呢？弄个转换器，将ps2插头转换成为USB插头就可以使用了。</p>
<p>接口Ps2：描述ps2接口格式</p>
<p>接口Usb：描述USB接口格式</p>
<p>类Usber：是接口Usb的实现类，是具体的USB接口格式</p>
<p>Adapter：用于将ps2接口格式转换成为USB接口格式
　　</p>
<h3 id="接口适配器模式"><a href="#接口适配器模式" class="headerlink" title="接口适配器模式"></a>接口适配器模式</h3><p>原理：通过抽象类来实现适配，这种适配稍别于上面所述的适配。</p>
<p>当存在这样一个接口，其中定义了N多的方法，而我们现在却只想使用其中的一个到几个方法，如果我们直接实现接口，那么我们要对所有的方法进行实现，哪怕我们仅仅是对不需要的方法进行置空（只写一对大括号，不做具体方法实现）也会导致这个类变得臃肿，调用也不方便，这时我们可以使用一个抽象类作为中间件，即适配器，用这个抽象类实现接口，而在抽象类中所有的方法都进行置空，那么我们在创建抽象类的继承类，而且重写我们需要使用的那几个方法即可。</p>
<p>目标接口：A<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">a</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">b</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">c</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">d</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">e</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>适配器：Adapter<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Adapter</span> <span class="keyword">implements</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">a</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">b</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">c</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">d</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">e</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>实现类：Ashili<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Ashili</span> <span class="keyword">extends</span> <span class="title">Adapter</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">a</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"实现A方法被调用"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">d</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"实现d方法被调用"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>测试类：Clienter<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Clienter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        A a = <span class="keyword">new</span> Ashili();</span><br><span class="line">        a.a();</span><br><span class="line">        a.d();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="适配器模式应用场景"><a href="#适配器模式应用场景" class="headerlink" title="适配器模式应用场景"></a>适配器模式应用场景</h3><p>类适配器与对象适配器的使用场景一致，仅仅是实现手段稍有区别，二者主要用于如下场景：</p>
<ol>
<li>想要使用一个已经存在的类，但是它却不符合现有的接口规范，导致无法直接去访问，这时创建一个适配器就能间接去访问这个类中的方法。</li>
<li>我们有一个类，想将其设计为可重用的类（可被多处访问），我们可以创建适配器来将这个类来适配其他没有提供合适接口的类。</li>
</ol>
<p>以上两个场景其实就是从两个角度来描述一类问题，那就是要访问的方法不在合适的接口里，一个从接口出发（被访问），一个从访问出发（主动访问）。</p>
<p>接口适配器使用场景：</p>
<ol>
<li>想要使用接口中的某个或某些方法，但是接口中有太多方法，我们要使用时必须实现接口并实现其中的所有方法，可以使用抽象类来实现接口，并不对方法进行实现（仅置空），然后我们再继承这个抽象类来通过重写想用的方法的方式来实现。这个抽象类就是适配器。</li>
</ol>
]]></content>
      
        <categories>
            
            <category> Design Pattern </category>
            
        </categories>
        
        
        <tags>
            
            <tag> technology </tag>
            
            <tag> design pattern </tag>
            
            <tag> Adapter </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[代理模式]]></title>
      <url>/2018/01/07/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/</url>
      <content type="html"><![CDATA[<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>代理(Proxy)是一种设计模式,提供了对目标对象另外的访问方式;即通过代理对象访问目标对象.这样做的好处是:可以在目标对象实现的基础上,增强额外的功能操作,即扩展目标对象的功能。</p>
<p>这里使用到编程中的一个思想:不要随意去修改别人已经写好的代码或者方法,如果需改修改,可以通过代理的方式来扩展该方法。</p>
<p>举个例子来说明代理的作用:假设我们想邀请一位明星,那么并不是直接连接明星,而是联系明星的经纪人,来达到同样的目的.明星就是一个目标对象,他只要负责活动中的节目,而其他琐碎的事情就交给他的代理人(经纪人)来解决.这就是代理思想在现实中的一个例子。</p>
<p>用图表示如下:</p>
<p><img src="https://github.com/dicheng52119/dicheng52119.github.io/blob/master/images/design-mode/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%E5%9B%BE%E8%A7%A3.png?raw=true" alt=""></p>
<p>代理模式的关键点是:代理对象与目标对象。代理对象是对目标对象的扩展,并会调用目标对象。</p>
<a id="more"></a>
<h3 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h3><ul>
<li><p><strong>静态代理</strong></p>
<p>  静态代理在使用时,需要定义接口或者父类,被代理对象与代理对象一起实现相同的接口或者是继承相同父类。</p>
<p>  下面举个案例来解释:</p>
<p>  模拟保存动作,定义一个保存动作的接口:IUserDao.java,然后目标对象实现这个接口的方法UserDao.java,此时如果使用静态代理方式,就需要在代理对象(UserDaoProxy.java)中也实现IUserDao接口.调用的时候通过调用代理对象的方法来调用目标对象。</p>
<p>  需要注意的是,代理对象与目标对象要实现相同的接口,然后通过调用相同的方法来调用目标对象的方法。</p>
<p>  代码示例：</p>
<p>  接口:IUserDao.java</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 接口</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IUserDao</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">save</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  目标对象:UserDao.java</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 接口实现</span></span><br><span class="line"><span class="comment">* 目标对象</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDao</span> <span class="keyword">implements</span> <span class="title">IUserDao</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"----已经保存数据!----"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  代理对象:UserDaoProxy.java</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 代理对象,静态代理</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDaoProxy</span> <span class="keyword">implements</span> <span class="title">IUserDao</span></span>&#123;</span><br><span class="line">    <span class="comment">//接收保存目标对象</span></span><br><span class="line">    <span class="keyword">private</span> IUserDao target;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UserDaoProxy</span><span class="params">(IUserDao target)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.target=target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"开始事务..."</span>);</span><br><span class="line">        target.save();<span class="comment">//执行目标对象的方法</span></span><br><span class="line">        System.out.println(<span class="string">"提交事务..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  测试类:App.java</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 测试类</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">App</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//目标对象</span></span><br><span class="line">        UserDao target = <span class="keyword">new</span> UserDao();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//代理对象,把目标对象传给代理对象,建立代理关系</span></span><br><span class="line">        UserDaoProxy proxy = <span class="keyword">new</span> UserDaoProxy(target);</span><br><span class="line"></span><br><span class="line">        proxy.save();<span class="comment">//执行的是代理的方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  <strong>静态代理总结:</strong></p>
<ol>
<li>可以做到在不修改目标对象的功能前提下,对目标功能扩展。</li>
<li><p>因为代理对象需要与目标对象实现一样的接口,所以会有很多代理类,类太多.同时,一旦接口增加方法,目标对象与代理对象都要维护。</p>
<p>如何解决静态代理中的缺点呢?答案是可以使用动态代理方式。</p>
</li>
</ol>
</li>
<li><p><strong>动态代理</strong></p>
<ul>
<li><strong>动态代理有以下特点:</strong></li>
</ul>
<ol>
<li>代理对象,不需要实现接口</li>
<li>代理对象的生成,是利用JDK的API,动态的在内存中构建代理对象(需要我们指定创建代理对象/目标对象实现的接口的类型)</li>
<li>动态代理也叫做:JDK代理,接口代理</li>
</ol>
<ul>
<li><p><strong>JDK中生成代理对象的API</strong></p>
<p>代理类所在包:java.lang.reflect.Proxy</p>
<p>JDK实现代理只需要使用newProxyInstance方法,但是该方法需要接收三个参数,完整的写法是:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> Object <span class="title">newProxyInstance</span><span class="params">(ClassLoader loader, Class&lt;?&gt;[] interfaces,InvocationHandler h )</span></span></span><br></pre></td></tr></table></figure>
<p>注意该方法是在Proxy类中是静态方法,且接收的三个参数依次为:</p>
</li>
</ul>
<ol>
<li>ClassLoader loader:指定当前目标对象使用类加载器,获取加载器的方法是固定的。</li>
<li>Class&lt;?&gt;[] interfaces：目标对象实现的接口的类型,使用泛型方式确认类型。</li>
<li><p>InvocationHandler h：事件处理,执行目标对象的方法时,会触发事件处理器的方法,会把当前执行目标对象的方法作为参数传入。</p>
<p>代码示例：</p>
<p>接口类IUserDao.java以及接口实现类,目标对象UserDao是一样的,没有做修改.在这个基础上,增加一个代理工厂类(ProxyFactory.java),将代理类写在这个地方,然后在测试类(需要使用到代理的代码)中先建立目标对象和代理对象的联系,然后代用代理对象的中同名方法。</p>
<p>代理工厂类: ProxyFactory.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 创建动态代理对象</span></span><br><span class="line"><span class="comment">* 动态代理不需要实现接口,但是需要指定接口类型</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyFactory</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//维护一个目标对象</span></span><br><span class="line">    <span class="keyword">private</span> Object target;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ProxyFactory</span><span class="params">(Object target)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.target=target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//给目标对象生成代理对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getProxyInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Proxy.newProxyInstance(</span><br><span class="line">                target.getClass().getClassLoader(),</span><br><span class="line">                target.getClass().getInterfaces(),</span><br><span class="line">                <span class="keyword">new</span> InvocationHandler() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">                        System.out.println(<span class="string">"开始事务2"</span>);</span><br><span class="line">                        <span class="comment">//执行目标对象方法</span></span><br><span class="line">                        Object returnValue = method.invoke(target, args);</span><br><span class="line">                        System.out.println(<span class="string">"提交事务2"</span>);</span><br><span class="line">                        <span class="keyword">return</span> returnValue;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试类:App.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 测试类</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">App</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 目标对象</span></span><br><span class="line">        IUserDao target = <span class="keyword">new</span> UserDao();</span><br><span class="line">        <span class="comment">// 【原始的类型 class cn.itcast.b_dynamic.UserDao】</span></span><br><span class="line">        System.out.println(target.getClass());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 给目标对象，创建代理对象</span></span><br><span class="line">        IUserDao proxy = (IUserDao) <span class="keyword">new</span> ProxyFactory(target).getProxyInstance();</span><br><span class="line">        <span class="comment">// class $Proxy0   内存中动态生成的代理对象</span></span><br><span class="line">        System.out.println(proxy.getClass());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 执行方法   【代理对象】</span></span><br><span class="line">        proxy.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ul>
<li><strong>总结:</strong><br>代理对象不需要实现接口,但是目标对象一定要实现接口,否则不能用动态代理。</li>
</ul>
</li>
<li><p><strong>Cglib代理</strong></p>
<p>  上面的静态代理和动态代理模式都是要求目标对象是实现一个接口的目标对象,但是有时候目标对象只是一个单独的对象,并没有实现任何的接口,这个时候就可以使用以目标对象子类的方式类实现代理,这种方法就叫做:Cglib代理。</p>
<p>  Cglib代理,也叫作子类代理,它是在内存中构建一个子类对象从而实现对目标对象功能的扩展。</p>
<ol>
<li>JDK的动态代理有一个限制,就是使用动态代理的对象必须实现一个或多个接口,如果想代理没有实现接口的类,就可以使用Cglib实现。</li>
<li>Cglib是一个强大的高性能的代码生成包,它可以在运行期扩展java类与实现java接口.它广泛的被许多AOP的框架使用,例如Spring AOP和synaop,为他们提供方法的interception(拦截)。</li>
<li><p>Cglib包的底层是通过使用一个小而块的字节码处理框架ASM来转换字节码并生成新的类.不鼓励直接使用ASM,因为它要求你必须对JVM内部结构包括class文件的格式和指令集都很熟悉。</p>
<p>Cglib子类代理实现方法:</p>
</li>
<li><p>需要引入cglib的jar文件,但是Spring的核心包中已经包括了Cglib功能,所以直接引入spring-core-3.2.5.jar即可。</p>
</li>
<li>引入功能包后,就可以在内存中动态构建子类。</li>
<li>代理的类不能为final,否则报错</li>
<li><p>目标对象的方法如果为final/static,那么就不会被拦截,即不会执行目标对象额外的业务方法。</p>
<p>代码示例：</p>
<p>目标对象类:UserDao.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 目标对象,没有实现任何接口</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDao</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"----已经保存数据!----"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Cglib代理工厂: ProxyFactory.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Cglib子类代理工厂</span></span><br><span class="line"><span class="comment">* 对UserDao在内存中动态构建一个子类对象</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyFactory</span> <span class="keyword">implements</span> <span class="title">MethodInterceptor</span></span>&#123;</span><br><span class="line">    <span class="comment">//维护目标对象</span></span><br><span class="line">    <span class="keyword">private</span> Object target;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ProxyFactory</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//给目标对象创建一个代理对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getProxyInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//1.工具类</span></span><br><span class="line">        Enhancer en = <span class="keyword">new</span> Enhancer();</span><br><span class="line">        <span class="comment">//2.设置父类</span></span><br><span class="line">        en.setSuperclass(target.getClass());</span><br><span class="line">        <span class="comment">//3.设置回调函数</span></span><br><span class="line">        en.setCallback(<span class="keyword">this</span>);</span><br><span class="line">        <span class="comment">//4.创建子类(代理对象)</span></span><br><span class="line">        <span class="keyword">return</span> en.create();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object obj, Method method, Object[] args, MethodProxy proxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"开始事务..."</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//执行目标对象的方法</span></span><br><span class="line">        Object returnValue = method.invoke(target, args);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"提交事务..."</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> returnValue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试类:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">App</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//目标对象</span></span><br><span class="line">        UserDao target = <span class="keyword">new</span> UserDao();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//代理对象</span></span><br><span class="line">        UserDao proxy = (UserDao)<span class="keyword">new</span> ProxyFactory(target).getProxyInstance();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//执行代理对象的方法</span></span><br><span class="line">        proxy.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>应用场景：</strong><br>在Spring的AOP编程中:<br>如果加入容器的目标对象有实现接口,用JDK代理;<br>如果目标对象没有实现接口,用Cglib代理。</p>
</li>
</ol>
</li>
</ul>
]]></content>
      
        <categories>
            
            <category> Design Pattern </category>
            
        </categories>
        
        
        <tags>
            
            <tag> technology </tag>
            
            <tag> Proxy </tag>
            
            <tag> JDK Proxy </tag>
            
            <tag> Cglib Proxy </tag>
            
            <tag> design pattern </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[工厂设计模式]]></title>
      <url>/2018/01/07/%E5%B7%A5%E5%8E%82%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
      <content type="html"><![CDATA[<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>主要用来实例化有共同接口的类，工厂模式可以动态决定应该实例化那一个类。</p>
<h3 id="工厂模式的形态"><a href="#工厂模式的形态" class="headerlink" title="工厂模式的形态"></a>工厂模式的形态</h3><ol>
<li>简单工厂（Simple Factory）。又称为静态工厂方法(Static Factory Method)模式</li>
<li>工厂方法（Factory Method）。</li>
<li>抽象工厂（Abstract Factory）。</li>
</ol>
<h3 id="简单工厂-（Simple-Factory）"><a href="#简单工厂-（Simple-Factory）" class="headerlink" title="简单工厂 （Simple Factory）"></a>简单工厂 （Simple Factory）</h3><p>又叫静态工厂，是工厂模式三中状态中结构最为简单的。主要有一个静态方法，用来接受参数，并根据参数来决定返回实现同一接口的不同类的实例。我们来看一个具体的例子：</p>
<p>假设一家工厂，有生产洗衣机，有生产冰箱，还有空调等等..</p>
<p>我们先为所有产品定义一个共同的产品接口<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Product</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure></p>
<p>接着我们让这个工厂的所有产品都必须实现此接口</p>
<a id="more"></a>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Washer</span> <span class="keyword">implements</span> <span class="title">Product</span></span>&#123; </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">Washer</span><span class="params">()</span></span>&#123; </span><br><span class="line">       System.out.println(<span class="string">"洗衣机被制造了"</span>); </span><br><span class="line">   &#125; </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Icebox</span> <span class="keyword">implements</span> <span class="title">Product</span></span>&#123; </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">Icebox</span><span class="params">()</span></span>&#123; </span><br><span class="line">       System.out.println(<span class="string">"冰箱被制造了"</span>); </span><br><span class="line">   &#125; </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AirCondition</span> <span class="keyword">implements</span> <span class="title">Product</span></span>&#123; </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">Icebox</span><span class="params">()</span></span>&#123; </span><br><span class="line">       System.out.println(<span class="string">"空调被制造了"</span>); </span><br><span class="line">   &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来我们来写一个工厂类，由它来负责生产以上的产品<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleFactory</span> </span>&#123; </span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Product <span class="title">factory</span><span class="params">(String productName)</span> <span class="keyword">throws</span> Exception</span>&#123; </span><br><span class="line">        <span class="keyword">if</span>(productName.equals(<span class="string">"Washer"</span>))&#123; </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Washer(); </span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(productName.equals(<span class="string">"Icebox"</span>))&#123; </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Icebox(); </span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(productName.equals(<span class="string">"AirCondition"</span>))&#123; </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> AirCondition(); </span><br><span class="line">        &#125;<span class="keyword">else</span>&#123; </span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">"没有该产品"</span>); </span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>好了，有了这个工厂类，我们就可以开始下定单了，SimpleFactory将根据不同的定单类决定生产什么产品。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">try</span> &#123; </span><br><span class="line">              SimpleFactory.factory(<span class="string">"Washer"</span>); </span><br><span class="line">              SimpleFactory.factory(<span class="string">"Icebox"</span>); </span><br><span class="line">              SimpleFactory.factory(<span class="string">"AirCondition"</span>); </span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123; </span><br><span class="line">        e.printStackTrace(); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>由上面的代码可以看出，简单工厂的核心就是一个SimpleFactory类，他拥有必要的逻辑判断能力和所有产品的创建权利，我们只需要向把定单给他，就能得到我们想要的产品。这使用起来似乎非常方便。</p>
<p>但，实际上，这个SimpleFactory有很多的局限。首先，我们每次想要增加一种新产品的时候，都必须修改SimpleFactory的原代码。其次，当我们拥有很多很多产品的时候，而且产品之间又存在复杂的层次关系的时候，这个类必须拥有复杂的逻辑判断能力，其代码量也将不断地激增，这对以后的维护简直就是恐怖两个字…<br>还有就是，整个系统都严重依赖SimpleFactory类，只要SimpleFactory类一出问题，系统就进入不能工作的状态，这也是最为致命的一点….</p>
<p>以上的不足将在工厂模式的另外两种状态中得到解决。</p>
<h3 id="工厂方法（Factory-Method）"><a href="#工厂方法（Factory-Method）" class="headerlink" title="工厂方法（Factory Method）"></a>工厂方法（Factory Method）</h3><p>上面的代码告诉我们，简单工厂并不简单，它是整个模式的核心，一旦他出了问题，整个模式都将受影响而不能工作，为了降低风险和为日后的维护、扩展做准备，我们需要对它进行重构，引入工厂方法。</p>
<p>工厂方法为工厂类定义了接口，用多态来削弱了工厂类的职能，以下是工厂接口的定义：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Factory</span></span>&#123; </span><br><span class="line">  <span class="function"><span class="keyword">public</span> Product <span class="title">create</span><span class="params">()</span></span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们再来定义一个产品接口<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Product</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure></p>
<p>以下是实现了产品接口的产品类<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Washer</span> <span class="keyword">implements</span> <span class="title">Product</span></span>&#123; </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">Washer</span><span class="params">()</span></span>&#123; </span><br><span class="line">       System.out.println(<span class="string">"洗衣机被制造了"</span>); </span><br><span class="line">   &#125; </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Icebox</span> <span class="keyword">implements</span> <span class="title">Product</span></span>&#123; </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">Icebox</span><span class="params">()</span></span>&#123; </span><br><span class="line">       System.out.println(<span class="string">"冰箱被制造了"</span>); </span><br><span class="line">   &#125; </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AirCondition</span> <span class="keyword">implements</span> <span class="title">Product</span></span>&#123; </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">Icebox</span><span class="params">()</span></span>&#123; </span><br><span class="line">       System.out.println(<span class="string">"空调被制造了"</span>); </span><br><span class="line">   &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>接下来，就是工厂方法的核心部分，也就是具体创建产品对象的具体工厂类<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建洗衣机的工厂 </span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CreateWasher</span> <span class="keyword">implements</span> <span class="title">Factory</span></span>&#123; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Product <span class="title">create</span><span class="params">()</span></span>&#123; </span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">new</span> Washer(); </span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line"><span class="comment">//创建冰箱的工厂 </span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CreateIcebox</span> <span class="keyword">implements</span> <span class="title">Factory</span></span>&#123; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Product <span class="title">create</span><span class="params">()</span></span>&#123; </span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">new</span> Icebox(); </span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line"><span class="comment">//创建空调的工厂 </span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CreateAirCondition</span> <span class="keyword">implements</span> <span class="title">Factory</span></span>&#123; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Product <span class="title">create</span><span class="params">()</span></span>&#123; </span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">new</span> AirCondition(); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>从上面创建产品对象的代码可以看出，工厂方法和简单工厂的主要区别是，简单工厂是把创建产品的职能都放在一个类里面，而工厂方法则把不同的产品放在实现了工厂接口的不同工厂类里面，这样就算其中一个工厂类出了问题，其他工厂类也能正常工作，互相不受影响，以后增加新产品，也只需要新增一个实现工厂接口工厂类，就能达到，不用修改已有的代码。但工厂方法也有他局限的地方，那就是当面对的产品有复杂的等级结构的时候，例如，工厂除了生产家电外产品，还生产手机产品，这样一来家电是手机就是两大产品家族了，这两大家族下面包含了数量众多的产品，每个产品又有多个型号，这样就形成了一个复杂的产品树了。如果用工厂方法来设计这个产品家族系统，就必须为每个型号的产品创建一个对应的工厂类，当有数百种甚至上千种产品的时候，也必须要有对应的上百成千个工厂类，这就出现了传说的类爆炸，对于以后的维护来说，简直就是一场灾难…..</p>
<h3 id="抽象工厂（Factory-Method）"><a href="#抽象工厂（Factory-Method）" class="headerlink" title="抽象工厂（Factory Method）"></a>抽象工厂（Factory Method）</h3><p>抽象工厂：目的意图在于创建一系列互相关联或互相依赖的对象。</p>
<p>我自己觉得抽象工厂是在工厂方法的基础上引进了分类管理的概念….</p>
<p>工厂方法用来创建一个产品，它没有分类的概念，而抽象工厂则用于创建一系列产品，所以产品分类成了抽象工厂的重点。</p>
<p>我们继续用上面的例子来说明：<br>工厂生产的所有产品都用都用大写字母来标明它们的型号，比如冰箱，就有“冰箱-A”,“冰箱-B”,同样，其他的产品也都是遵守这个编号规则，于是就有了一下产品家族树。</p>
<p>冰箱：</p>
<ol>
<li>冰箱-A</li>
<li>冰箱-B</li>
</ol>
<p>洗衣机：</p>
<ol>
<li>洗衣机-A</li>
<li>洗衣机-B</li>
</ol>
<p>我们可以为冰箱和洗衣机分别定义两个产品接口，以对他们进行分类。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//洗衣机接口 </span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Washer</span></span>&#123; </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line"><span class="comment">//冰箱接口 </span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Icebox</span></span>&#123; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>接着，我们分别创建这两个接口的具体产品<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//洗衣机-A </span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WasherA</span> <span class="keyword">implements</span> <span class="title">Washer</span></span>&#123; </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">WasherA</span><span class="params">()</span></span>&#123; </span><br><span class="line">       System.out.println(<span class="string">"洗衣机-A被制造了"</span>); </span><br><span class="line">   &#125; </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line"><span class="comment">//洗衣机-B </span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WasherB</span> <span class="keyword">implements</span> <span class="title">Washer</span></span>&#123; </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">WasherB</span><span class="params">()</span></span>&#123; </span><br><span class="line">       System.out.println(<span class="string">"洗衣机-B被制造了"</span>); </span><br><span class="line">   &#125; </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line"><span class="comment">//冰箱-A </span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IceboxA</span> <span class="keyword">implements</span> <span class="title">Icebox</span></span>&#123; </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">IceboxA</span><span class="params">()</span></span>&#123; </span><br><span class="line">       System.out.println(<span class="string">"冰箱-A被制造了"</span>); </span><br><span class="line">   &#125; </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line"><span class="comment">//冰箱-B </span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IceboxB</span> <span class="keyword">implements</span> <span class="title">Icebox</span></span>&#123; </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">IceboxB</span><span class="params">()</span></span>&#123; </span><br><span class="line">       System.out.println(<span class="string">"冰箱-B被制造了"</span>); </span><br><span class="line">   &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>到此，产品部分我们准备好了，接下来我们来处理工厂部分，我们先来定义工厂行为接口<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Factory</span></span>&#123; </span><br><span class="line">       <span class="function"><span class="keyword">public</span> Washer <span class="title">createWasher</span><span class="params">()</span></span>; </span><br><span class="line">       <span class="function"><span class="keyword">public</span> Icebox <span class="title">createIcebox</span><span class="params">()</span></span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>接下来我创造具体的工厂类，我们根据上面产品的接口，把型号A的产品分为一类，由一个工厂来管理，把型号为B的产品有另一个工厂管理，根据这个分类，我们可以实现如下的两个具体工厂类<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建型号为A的产品工厂 </span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FactoryA</span> <span class="keyword">implements</span> <span class="title">Factory</span></span>&#123; </span><br><span class="line">       <span class="comment">//创建洗衣机-A </span></span><br><span class="line">       <span class="function"><span class="keyword">public</span> Washer <span class="title">createWasher</span><span class="params">()</span></span>&#123; </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> WasherA(); </span><br><span class="line">       &#125; </span><br><span class="line"> </span><br><span class="line">       <span class="comment">//创建冰箱-A </span></span><br><span class="line">       <span class="function"><span class="keyword">public</span> Icebox <span class="title">createIcebox</span><span class="params">()</span></span>&#123; </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> IceboxA(); </span><br><span class="line">       &#125; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">//创建型号为B的产品工厂 </span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FactoryB</span> <span class="keyword">implements</span> <span class="title">Factory</span></span>&#123; </span><br><span class="line">       <span class="comment">//创建洗衣机-B </span></span><br><span class="line">       <span class="function"><span class="keyword">public</span> Washer <span class="title">createWasher</span><span class="params">()</span></span>&#123; </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> WasherB(); </span><br><span class="line">       &#125; </span><br><span class="line"> </span><br><span class="line">       <span class="comment">//创建冰箱-B </span></span><br><span class="line">       <span class="function"><span class="keyword">public</span> Icebox <span class="title">createIcebox</span><span class="params">()</span></span>&#123; </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> IceboxB(); </span><br><span class="line">       &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这样，我们的抽象工厂就完成了。有上面可以看出，在运用上我觉得工厂方法和抽象工厂，都有自己的应用场景，并没有什么优劣之分，但在应用抽象工厂之前，要先对创建的对象进行系统的分类，这点很重要，好的产品分类规则能为具体工厂类的选择调用和以后的扩展提供清晰的思路。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol>
<li>静态工厂：一个共同的产品接口，所有产品实现这个接口。一个工厂类，内有一个静态方法，负责生产以上的商品。</li>
<li>工厂方法：一个共同的产品接口，所有产品实现这个接口。一个工厂接口，生产不同产品的工厂实现这个接口。</li>
<li>抽象工厂：定义不同产品的接口，分别创建不同产品接口下的多个具体产品类。一个工厂接口，定义工厂行为方法，根据具体产品类的分类创建对应的实现工厂接口的工厂实现类。</li>
</ol>
]]></content>
      
        <categories>
            
            <category> Design Pattern </category>
            
        </categories>
        
        
        <tags>
            
            <tag> technology </tag>
            
            <tag> design pattern </tag>
            
            <tag> Simple Factory </tag>
            
            <tag> Factory Method </tag>
            
            <tag> Abstract Factory </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[单例设计模式]]></title>
      <url>/2018/01/07/%E5%8D%95%E4%BE%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
      <content type="html"><![CDATA[<h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>java中单例模式是一种常见的设计模式，单例模式的写法有好几种，这里主要介绍三种：懒汉式单例、饿汉式单例、登记式单例。</p>
<p>单例模式有以下特点：</p>
<ol>
<li>单例类只能有一个实例。</li>
<li>单例类必须自己创建自己的唯一实例。</li>
<li>单例类必须给所有其他对象提供这一实例。</li>
</ol>
<p>单例模式确保某个类只有一个实例，而且自行实例化并向整个系统提供这个实例。在计算机系统中，线程池、缓存、日志对象、对话框、打印机、显卡的驱动程序对象常被设计成单例。这些应用都或多或少具有资源管理器的功能。每台计算机可以有若干个打印机，但只能有一个Printer Spooler，以避免两个打印作业同时输出到打印机中。每台计算机可以有若干通信端口，系统应当集中管理这些通信端口，以避免一个通信端口同时被两个请求同时调用。总之，选择单例模式就是为了避免不一致状态，避免政出多头。</p>
<h3 id="单例模式的实现方式-列出6种可行的实现"><a href="#单例模式的实现方式-列出6种可行的实现" class="headerlink" title="单例模式的实现方式(列出6种可行的实现)"></a>单例模式的实现方式(列出6种可行的实现)</h3><p>饿汉式和懒汉式是以往最经典和常用的方式。</p>
<a id="more"></a>
<ul>
<li><strong>饿汉式(静态常量)</strong></li>
</ul>
<p><img src="https://github.com/dicheng52119/dicheng52119.github.io/blob/master/images/design-mode/%E9%A5%BF%E6%B1%89%E9%9D%99%E6%80%81%E5%B8%B8%E9%87%8F%E6%96%B9%E5%BC%8F.png?raw=true" alt=""></p>
<p>该方式不能实现懒加载、参数化、配置化，简单地说就是不够灵活。但却是一种简单可行的方式，在Java jdk中就有用到该方式实现单例，例如Runtime类。虽然jdk中没有使用final，但达到的效果是相同的，该方式还能用静态代码块实现。</p>
<ul>
<li><strong>饿汉式(静态代码块)</strong></li>
</ul>
<p><img src="https://github.com/dicheng52119/dicheng52119.github.io/blob/master/images/design-mode/%E9%A5%BF%E6%B1%89%E9%9D%99%E6%80%81%E4%BB%A3%E7%A0%81%E5%9D%97%E6%96%B9%E5%BC%8F.png?raw=true" alt=""></p>
<p>该方式效果和优缺点同上。</p>
<ul>
<li><strong>懒汉式(线程同步)</strong></li>
</ul>
<p><img src="https://github.com/dicheng52119/dicheng52119.github.io/blob/master/images/design-mode/%E6%87%92%E6%B1%89%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E6%96%B9%E5%BC%8F.png?raw=true" alt=""></p>
<p>该方式达到了实现懒加载、可参数化、可配置化的要求，但是明显的缺点就是效率太低。</p>
<ul>
<li><strong>懒汉式（双重检查）</strong></li>
</ul>
<p><img src="https://github.com/dicheng52119/dicheng52119.github.io/blob/master/images/design-mode/%E6%87%92%E6%B1%89%E5%8F%8C%E9%87%8D%E6%A3%80%E6%9F%A5%E6%96%B9%E5%BC%8F.png?raw=true" alt=""></p>
<p>该方式值得推荐使用，使用该方式需要对线程知识有一定的了解。使用volatile关键字使得单例对象具有可见性，通知多线程中的其他线程去主存中获取单例对象。但不能保证原子性，所以需要使用synchronized关键字保证原子性操作。</p>
<p>除了饿汉式和懒汉式，下面笔者再提供两种值得推荐的方式。</p>
<ul>
<li><strong>静态内部类</strong></li>
</ul>
<p><img src="https://github.com/dicheng52119/dicheng52119.github.io/blob/master/images/design-mode/%E9%9D%99%E6%80%81%E5%86%85%E9%83%A8%E7%B1%BB%E6%96%B9%E5%BC%8F.png?raw=true" alt=""></p>
<p>该方式类似于饿汉式和懒汉式的结合版，既避免了线程同步问题，又支持延迟加载，还提高了效率。类加载时没有进行单例对象的初始化，而是在获取实例对象时通过调用其静态内部类获取单例的静态常量对象来进行实现。</p>
<ul>
<li><strong>枚举式</strong></li>
</ul>
<p><img src="https://github.com/dicheng52119/dicheng52119.github.io/blob/master/images/design-mode/%E6%9E%9A%E4%B8%BE%E6%96%B9%E5%BC%8F.png?raw=true" alt=""></p>
<p>该方式简单直接。不过目前使用的频率不高，可能是因为枚举是在JDK1.5之后的新特性的原因，大家还未习惯使用枚举吧。</p>
<p>以上六种方式均为可行的实现单例模式的方式，可根据具体需求进行选择。</p>
<h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><ol>
<li>应用程序的日志应用，一般都应用单例模式实现，这一般是由于共享的日志文件一直处于打开状态，因为只能有一个实例去操作，否则内容不好追加。</li>
<li>Web应用的配置对象的读取，一般也应用单例模式，这个是由于配置文件是共享的资源。</li>
<li>数据库连接池的设计一般也是采用单例模式，因为数据库连接是一种数据库资源。数据库软件系统中使用数据库连接池，主要是节省打开或者关闭数据库连接所引起的效率损耗，这种效率上的损耗还是非常昂贵的，用单例模式来维护，就可以大大降低这种损耗。</li>
<li>多线程的线程池的设计一般也是采用单例模式，这是由于线程池要方便对池中的线程进行控制。</li>
<li>操作系统的文件系统，也是大的单例模式实现的具体例子，一个操作系统只能有一个文件系统。</li>
<li>HttpApplication也是单例的典型应用。熟悉ASP.Net(IIS)的整个请求生命周期的人应该知道HttpApplication也是单例模式，所有的HttpModule都共享一个HttpApplication实例。</li>
</ol>
<p>简单的说说单例的目的：资源共享，避免多次创建对象，以提高性能。资源控制，方便资源之间的互相通信。</p>
<p>单例模式与垃圾回收：单例模式创建的对象会不会被垃圾回收机制回收？这是一个饱受争议的问题，网上各种水平的人，包括所谓的“技术大牛”都持有不同观点。但是笔者可以在这里明确的告诉大家，一个单例对象即使长时间未被引用也不会被垃圾回收机制给卸载掉。关于垃圾回收（GC）的底层原理，不属于本文范围，在此不做过多讲解。</p>
<h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestSingleton</span> </span>&#123;  </span><br><span class="line">    String name = <span class="keyword">null</span>;  </span><br><span class="line">  </span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="title">TestSingleton</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> TestSingleton instance = <span class="keyword">null</span>;  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> TestSingleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">           <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;    </span><br><span class="line">             <span class="keyword">synchronized</span> (TestSingleton.class) &#123;    </span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;    </span><br><span class="line">                   instance = <span class="keyword">new</span> TestSingleton();   </span><br><span class="line">                &#125;    </span><br><span class="line">             &#125;    </span><br><span class="line">           &#125;   </span><br><span class="line">           <span class="keyword">return</span> instance;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> name;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">this</span>.name = name;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printInfo</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        System.out.println(<span class="string">"the name is "</span> + name);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TMain</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;  </span><br><span class="line">        TestStream ts1 = TestSingleton.getInstance();  </span><br><span class="line">        ts1.setName(<span class="string">"jason"</span>);  </span><br><span class="line">        TestStream ts2 = TestSingleton.getInstance();  </span><br><span class="line">        ts2.setName(<span class="string">"0539"</span>);  </span><br><span class="line">          </span><br><span class="line">        ts1.printInfo();  </span><br><span class="line">        ts2.printInfo();  </span><br><span class="line">          </span><br><span class="line">        <span class="keyword">if</span>(ts1 == ts2)&#123;  </span><br><span class="line">            System.out.println(<span class="string">"创建的是同一个实例"</span>);  </span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;  </span><br><span class="line">            System.out.println(<span class="string">"创建的不是同一个实例"</span>);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">the name is 0539</span><br><span class="line">the name is 0539</span><br><span class="line">创建的是同一个实例</span><br></pre></td></tr></table></figure></p>
<p>结论：由结果可以得知单例模式为一个面向对象的应用程序提供了对象惟一的访问点，不管它实现何种功能，整个应用程序都会同享一个实例对象。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li><strong>饿汉式和懒汉式区别</strong></li>
</ul>
<ol>
<li>单例对象初始化时间：<br>饿汉就是类一旦加载，就把单例初始化完成，保证getInstance的时候，单例是已经存在的了，而懒汉比较懒，只有当调用getInstance的时候，才回去初始化这个单例。</li>
<li>线程安全：<br>饿汉式天生就是线程安全的，可以直接用于多线程而不会出现问题，<br>懒汉式本身是非线程安全的，为了实现线程安全有几种写法，在资源加载和性能方面有些区别。</li>
<li>资源加载和性能：<br>饿汉式在类创建的同时就实例化一个静态对象出来，不管之后会不会使用这个单例，都会占据一定的内存，但是相应的，在第一次调用时速度也会更快，因为其资源已经初始化完成，<br>而懒汉式顾名思义，会延迟加载，在第一次使用该单例的时候才会实例化对象出来，第一次调用时要做初始化，如果要做的工作比较多，性能上会有些延迟，之后就和饿汉式一样了。</li>
</ol>
<p>至于3、4、5这三种实现又有些区别：</p>
<p>第3种，在方法调用上加了同步，虽然线程安全了，但是每次都要同步，会影响性能，毕竟99%的情况下是不需要同步的。</p>
<p>第4种，在getInstance中做了两次null检查，确保了只有第一次调用单例的时候才会做同步，这样也是线程安全的，同时避免了每次都同步的性能损耗。</p>
<p>第5种，利用了classloader的机制来保证初始化instance时只有一个线程，所以也是线程安全的，同时没有性能损耗，所以一般我倾向于使用这一种。</p>
]]></content>
      
        <categories>
            
            <category> Design Pattern </category>
            
        </categories>
        
        
        <tags>
            
            <tag> technology </tag>
            
            <tag> design pattern </tag>
            
            <tag> 单例 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[ConcurrentHashMap并发集合学习笔记]]></title>
      <url>/2018/01/07/ConcurrentHashMap%E5%B9%B6%E5%8F%91%E9%9B%86%E5%90%88%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>HashMap是我们平时开发过程中用的比较多的集合，但它是非线程安全的，在涉及到多线程并发的情况，进行put操作有可能会引起死循环，导致CPU利用率接近100%。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> HashMap&lt;String, String&gt; map = <span class="keyword">new</span> HashMap&lt;String, String&gt;(<span class="number">2</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            map.put(UUID.randomUUID().toString(), <span class="string">""</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>解决方案有Hashtable和Collections.synchronizedMap(hashMap)，不过这两个方案基本上是对读写进行加锁操作，一个线程在读写元素，其余线程必须等待，性能可想而知。</p>
<p>所以，Doug Lea给我们带来了并发安全的ConcurrentHashMap，它的实现是依赖于 Java 内存模型。</p>
<a id="more"></a>
<h3 id="JDK1-6分析"><a href="#JDK1-6分析" class="headerlink" title="JDK1.6分析"></a>JDK1.6分析</h3><p>ConcurrentHashMap采用 分段锁的机制，实现并发的更新操作，底层采用数组+链表+红黑树的存储结构。</p>
<p>其包含两个核心静态内部类 Segment和HashEntry。</p>
<ol>
<li>Segment继承ReentrantLock用来充当锁的角色，每个 Segment 对象守护每个散列映射表的若干个桶。</li>
<li>HashEntry 用来封装映射表的键 / 值对；</li>
<li>每个桶是由若干个 HashEntry 对象链接起来的链表。</li>
</ol>
<p>一个 ConcurrentHashMap 实例中包含由若干个 Segment 对象组成的数组，下面我们通过一个图来演示一下 ConcurrentHashMap 的结构：<br><img src="https://raw.githubusercontent.com/dicheng52119/dicheng52119.github.io/master/images/thread/1.6%20ConcurrentHashMap%20%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84.png" alt=""></p>
<h3 id="JDK1-8分析"><a href="#JDK1-8分析" class="headerlink" title="JDK1.8分析"></a>JDK1.8分析</h3><p>1.8的实现已经抛弃了Segment分段锁机制，利用CAS+Synchronized来保证并发更新的安全，底层依然采用数组+链表+红黑树的存储结构:<br><img src="https://raw.githubusercontent.com/dicheng52119/dicheng52119.github.io/master/images/thread/1.8%20ConcurrentHashMap%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84.png" alt=""></p>
<h3 id="重要概念"><a href="#重要概念" class="headerlink" title="重要概念"></a>重要概念</h3><p>在开始之前，有些重要的概念需要介绍一下：</p>
<ol>
<li><strong>table：</strong> 默认为null，初始化发生在第一次插入操作，默认大小为16的数组，用来存储Node节点数据，扩容时大小总是2的幂次方。</li>
<li><strong>nextTable：</strong> 默认为null，扩容时新生成的数组，其大小为原数组的两倍。</li>
<li><strong>sizeCtl ：</strong> 默认为0，用来控制table的初始化和扩容操作，具体应用在后续会体现出来。</li>
<li><strong>-1：</strong> 代表table正在初始化。</li>
<li><strong>-N：</strong> 表示有N-1个线程正在进行扩容操作</li>
<li><strong>Node：</strong> 保存key，value及key的hash值的数据结构。<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line">    <span class="keyword">final</span> K key;</span><br><span class="line">    <span class="keyword">volatile</span> V val;</span><br><span class="line">    <span class="keyword">volatile</span> Node&lt;K,V&gt; next;</span><br><span class="line">    ... 省略部分代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>其中value和next都用volatile修饰，保证并发的可见性。</p>
<ol>
<li><strong>ForwardingNode：</strong> 一个特殊的Node节点，hash值为-1，其中存储nextTable的引用。<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ForwardingNode</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;K,V&gt;[] nextTable;</span><br><span class="line">    ForwardingNode(Node&lt;K,V&gt;[] tab) &#123;</span><br><span class="line">        <span class="keyword">super</span>(MOVED, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">this</span>.nextTable = tab;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>只有table发生扩容的时候，ForwardingNode才会发挥作用，作为一个占位符放在table中表示当前节点为null或则已经被移动。</p>
<h3 id="实例初始化"><a href="#实例初始化" class="headerlink" title="实例初始化"></a>实例初始化</h3><p>实例化ConcurrentHashMap时带参数时，会根据参数调整table的大小，假设参数为100，最终会调整成256，确保table的大小总是2的幂次方，算法如下：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ConcurrentHashMap&lt;String, String&gt; hashMap = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;(<span class="number">100</span>);</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">tableSizeFor</span><span class="params">(<span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = c - <span class="number">1</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">2</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">4</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">8</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">16</span>;</span><br><span class="line">    <span class="keyword">return</span> (n &lt; <span class="number">0</span>) ? <span class="number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>注意</strong>，ConcurrentHashMap在构造函数中只会初始化sizeCtl值，并不会直接初始化table，而是延缓到第一次put操作。</p>
<h3 id="table初始化"><a href="#table初始化" class="headerlink" title="table初始化"></a>table初始化</h3><p>前面已经提到过，table初始化操作会延缓到第一次put行为。但是put是可以并发执行的，Doug Lea是如何实现table只初始化一次的？让我们来看看源码的实现。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Node&lt;K,V&gt;[] initTable() &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; <span class="keyword">int</span> sc;</span><br><span class="line">    <span class="keyword">while</span> ((tab = table) == <span class="keyword">null</span> || tab.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//如果一个线程发现sizeCtl&lt;0，意味着另外的线程执行CAS操作成功，当前线程只需要让出cpu时间片</span></span><br><span class="line">        <span class="keyword">if</span> ((sc = sizeCtl) &lt; <span class="number">0</span>) </span><br><span class="line">            Thread.yield(); <span class="comment">// lost initialization race; just spin</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc, -<span class="number">1</span>)) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || tab.length == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">int</span> n = (sc &gt; <span class="number">0</span>) ? sc : DEFAULT_CAPACITY;</span><br><span class="line">                    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">                    Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node&lt;?,?&gt;[n];</span><br><span class="line">                    table = tab = nt;</span><br><span class="line">                    sc = n - (n &gt;&gt;&gt; <span class="number">2</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                sizeCtl = sc;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>sizeCtl默认为0，如果ConcurrentHashMap实例化时有传参数，sizeCtl会是一个2的幂次方的值。所以执行第一次put操作的线程会执行Unsafe.compareAndSwapInt方法修改sizeCtl为-1，有且只有一个线程能够修改成功，其它线程通过Thread.yield()让出CPU时间片等待table初始化完成。</p>
<h3 id="put操作"><a href="#put操作" class="headerlink" title="put操作"></a>put操作</h3><p>假设table已经初始化完成，put操作采用CAS+synchronized实现并发插入或更新操作。</p>
<h3 id="get操作"><a href="#get操作" class="headerlink" title="get操作"></a>get操作</h3><ol>
<li>判断table是否为空，如果为空，直接返回null。</li>
<li>计算key的hash值，并获取指定table中指定位置的Node节点，通过遍历链表或则树结构找到对应的节点，返回value值。</li>
</ol>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>ConcurrentHashMap 是一个并发散列映射表的实现，它允许完全并发的读取，并且支持给定数量的并发更新。相比于 HashTable 和同步包装器包装的 HashMap，使用一个全局的锁来同步不同线程间的并发访问，同一时间点，只能有一个线程持有锁，也就是说在同一时间点，只能有一个线程能访问容器，这虽然保证多线程间的安全并发访问，但同时也导致对容器的访问变成串行化的了。</p>
<p>1.6中采用ReentrantLock分段锁的方式，使多个线程在不同的segment上进行写操作不会发现阻塞行为;1.8中直接采用了内置锁synchronized。</p>
]]></content>
      
        <categories>
            
            <category> Thread </category>
            
        </categories>
        
        
        <tags>
            
            <tag> ConcurrentHashMap </tag>
            
            <tag> technology </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Executor并发框架学习笔记]]></title>
      <url>/2018/01/07/Executor%E5%B9%B6%E5%8F%91%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      <content type="html"><![CDATA[<h3 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h3><p>Eexecutor作为灵活且强大的异步执行框架，其支持多种不同类型的任务执行策略，提供了一种标准的方法将任务的提交过程和执行过程解耦开发，基于生产者-消费者模式，其提交任务的线程相当于生产者，执行任务的线程相当于消费者，并用Runnable来表示任务，Executor的实现还提供了对生命周期的支持，以及统计信息收集，应用程序管理机制和性能监视等机制。</p>
<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><ul>
<li>Executor的UML图：（常用的几个接口和子类）<br><img src="https://raw.githubusercontent.com/dicheng52119/dicheng52119.github.io/master/images/thread/Executor%E5%AE%B6%E8%B0%B1%E5%9B%BE.png" alt=""></li>
</ul>
<ol>
<li>Executor：一个接口，其定义了一个接收Runnable对象的方法executor，其方法签名为executor(Runnable command)</li>
<li>ExecutorService：是一个比Executor使用更广泛的子类接口，其提供了生命周期管理的方法，以及可跟踪一个或多个异步任务执行状况返回Future的方法</li>
<li>AbstractExecutorService：ExecutorService执行方法的默认实现</li>
<li>ScheduledExecutorService：一个可定时调度任务的接口</li>
<li>ScheduledThreadPoolExecutor：ScheduledExecutorService的实现，一个可定时调度任务的线程池</li>
<li>ThreadPoolExecutor：线程池，可以通过调用Executors以下静态工厂方法来创建线程池并返回一个ExecutorService对象</li>
</ol>
<a id="more"></a>
<h3 id="ThreadPoolExecutor构造函数的各个参数说明"><a href="#ThreadPoolExecutor构造函数的各个参数说明" class="headerlink" title="ThreadPoolExecutor构造函数的各个参数说明"></a>ThreadPoolExecutor构造函数的各个参数说明</h3><p>ThreadPoolExecutor方法签名：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                          TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                          BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">                          ThreadFactory threadFactory,</span></span></span><br><span class="line"><span class="function"><span class="params">                          RejectedExecutionHandler handler)</span> <span class="comment">//后两个参数为可选参数</span></span></span><br></pre></td></tr></table></figure></p>
<p>参数说明：</p>
<ol>
<li>corePoolSize：核心线程数，如果运行的线程少于corePoolSize，则创建新线程来执行新任务，即使线程池中的其他线程是空闲的</li>
<li>maximumPoolSize:最大线程数，可允许创建的线程数，corePoolSize和maximumPoolSize设置的边界自动调整池大小：<br>corePoolSize &lt;运行的线程数&lt; maximumPoolSize:仅当队列满时才创建新线程<br>corePoolSize=运行的线程数= maximumPoolSize：创建固定大小的线程池</li>
<li>keepAliveTime:如果线程数多于corePoolSize,则这些多余的线程的空闲时间超过keepAliveTime时将被终止</li>
<li>unit:keepAliveTime参数的时间单位</li>
<li>workQueue:保存任务的阻塞队列，与线程池的大小有关：<br>当运行的线程数少于corePoolSize时，在有新任务时直接创建新线程来执行任务而无需再进队列<br>当运行的线程数等于或多于corePoolSize，在有新任务添加时则选加入队列，不直接创建线程<br>当队列满时，在有新任务时就创建新线程</li>
<li>threadFactory:使用ThreadFactory创建新线程，默认使用defaultThreadFactory创建线程</li>
<li>handle:定义处理被拒绝任务的策略，默认使用ThreadPoolExecutor.AbortPolicy,任务被拒绝时将抛出RejectExecutorException</li>
</ol>
<h3 id="Executors"><a href="#Executors" class="headerlink" title="Executors"></a>Executors</h3><p>提供了一系列静态工厂方法用于创建各种线程池</p>
<ol>
<li><p>newFixedThreadPool:创建可重用且固定线程数的线程池，如果线程池中的所有线程都处于活动状态，此时再提交任务就在队列中等待，直到有可用线程；如果线程池中的某个线程由于异常而结束时，线程池就会再补充一条新线程。<br>方法签名：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(nThreads, nThreads,</span><br><span class="line">                                  <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                  <span class="comment">//使用一个基于FIFO排序的阻塞队列，在所有corePoolSize线程都忙时新任务将在队列中等待</span></span><br><span class="line">                                  <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>newSingleThreadExecutor:创建一个单线程的Executor，如果该线程因为异常而结束就新建一条线程来继续执行后续的任务。<br>方法签名：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newSingleThreadExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">new</span> FinalizableDelegatedExecutorService</span><br><span class="line">                     <span class="comment">//corePoolSize和maximumPoolSize都等于，表示固定线程池大小为1</span></span><br><span class="line">                        (<span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                                                <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                                <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>newScheduledThreadPool:创建一个可延迟执行或定期执行的线程池。</p>
</li>
<li>newCachedThreadPool:创建可缓存的线程池，如果线程池中的线程在60秒未被使用就将被移除，在执行新的任务时，当线程池中有之前创建的可用线程就重用可用线程，否则就新建一条线程。<br>方法签名：<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">                                  <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                                  <span class="comment">//使用同步队列，将任务直接提交给线程</span></span><br><span class="line">                                  <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>通过使用Executor可以很轻易的实现各种调优  管理  监视  记录日志和错误报告等待。</p>
<h3 id="Executor的生命周期"><a href="#Executor的生命周期" class="headerlink" title="Executor的生命周期"></a>Executor的生命周期</h3><p>ExecutorService提供了管理Executor生命周期的方法，ExecutorService的生命周期包括了：运行、关闭和终止三种状态。</p>
<p>ExecutorService在初始化创建时处于运行状态。<br>shutdown方法等待提交的任务执行完成并不再接受新任务，在完成全部提交的任务后关闭。</p>
<h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><ul>
<li><p>使用newScheduledThreadPool来模拟心跳机制</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HeartBeat</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ScheduledExecutorService executor = Executors.newScheduledThreadPool(<span class="number">5</span>);</span><br><span class="line">        Runnable task = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"HeartBeat........................."</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        executor.scheduleAtFixedRate(task,<span class="number">5</span>,<span class="number">3</span>, TimeUnit.SECONDS);   <span class="comment">//5秒后第一次执行，之后每隔3秒执行一次</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  输出结果：</p>
  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">HeartBeat....................... //5秒后第一次输出</span><br><span class="line">HeartBeat....................... //每隔3秒输出一个</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用newCachedThreadPool模拟线程重用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPoolTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">     ExecutorService threadPool = Executors.newCachedThreadPool();<span class="comment">//线程池里面的线程数会动态变化，并可在线程被移除前重用</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">3</span>; i ++) &#123;</span><br><span class="line">            <span class="keyword">final</span>  <span class="keyword">int</span> task = i;   <span class="comment">//10个任务</span></span><br><span class="line">            <span class="comment">//TimeUnit.SECONDS.sleep(1);</span></span><br><span class="line">            threadPool.execute(<span class="keyword">new</span> Runnable() &#123;    <span class="comment">//接受一个Runnable实例</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                        System.out.println(<span class="string">"线程名字： "</span> + Thread.currentThread().getName() +  <span class="string">"  任务名为： "</span>+task);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  输出结果：（为每个任务新建一条线程，共创建了3条线程）</p>
  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">线程名字： pool-1-thread-1 任务名为： 1</span><br><span class="line">线程名字： pool-1-thread-2 任务名为： 2</span><br><span class="line">线程名字： pool-1-thread-3 任务名为： 3</span><br></pre></td></tr></table></figure>
<p>  去掉第6行的注释其输出如下：（始终重复利用一条线程，因为newCachedThreadPool能重用可用线程）</p>
  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">线程名字： pool-1-thread-1 任务名为： 1</span><br><span class="line">线程名字： pool-1-thread-1 任务名为： 2</span><br><span class="line">线程名字： pool-1-thread-1 任务名为： 3</span><br></pre></td></tr></table></figure>
</li>
<li><p>任务执行完成后并返回执行结果</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CallableAndFuture</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">        ExecutorService executor = Executors.newSingleThreadExecutor();</span><br><span class="line">        Future&lt;String&gt; future = executor.submit(<span class="keyword">new</span> Callable&lt;String&gt;() &#123;   <span class="comment">//接受一上callable实例</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="string">"MOBIN"</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(<span class="string">"任务的执行结果："</span>+future.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  输出结果：</p>
  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">任务的执行结果：MOBIN</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>通过Executor来设计应用程序可以简化开发过程，提高开发效率，并有助于实现并发，在开发中如果需要创建线程可优先考虑使用Executor。</p>
]]></content>
      
        <categories>
            
            <category> Thread </category>
            
        </categories>
        
        
        <tags>
            
            <tag> technology </tag>
            
            <tag> Executor </tag>
            
            <tag> Executors </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Semaphore信号量学习笔记]]></title>
      <url>/2018/01/07/Semaphore%E4%BF%A1%E5%8F%B7%E9%87%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>在多线程程序设计中有三个同步工具需要我们掌握，分别是Semaphore(信号量)，countDownLatch（倒计数门闸锁），CyclicBarrier(可重用栅栏)</p>
<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>Semaphore是一种基于计数的信号量。它可以设定一个阈值，基于此，多个线程竞争获取许可信号，做完自己的申请后归还，超过阈值后，线程申请许可信号将会被阻塞。Semaphore可以用来构建一些对象池，资源池之类的，比如数据库连接池，我们也可以创建计数为1的Semaphore，将其作为一种类似互斥锁的机制，这也叫二元信号量，表示两种互斥状态。它的用法如下：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建一个计数阈值为5的信号量对象  </span></span><br><span class="line"><span class="comment">// 只能5个线程同时访问  </span></span><br><span class="line">Semaphore semp = <span class="keyword">new</span> Semaphore(<span class="number">5</span>);  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">try</span> &#123;  </span><br><span class="line">    <span class="comment">// 申请许可  </span></span><br><span class="line">    semp.acquire();  </span><br><span class="line">    <span class="keyword">try</span> &#123;  </span><br><span class="line">        <span class="comment">// 业务逻辑  </span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;  </span><br><span class="line">  </span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;  </span><br><span class="line">        <span class="comment">// 释放许可  </span></span><br><span class="line">        semp.release();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;  </span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<a id="more"></a>
<p>在信号量上我们定义两种操作： acquire（获取） 和 release（释放）。当一个线程调用acquire操作时，它要么通过成功获取信号量（信号量减1），要么一直等下去，直到有线程释放信号量，或超时。release（释放）实际上会将信号量的值加1，然后唤醒等待的线程。</p>
<h3 id="Semaphore的作用"><a href="#Semaphore的作用" class="headerlink" title="Semaphore的作用"></a>Semaphore的作用</h3><p>在java中，使用了synchronized关键字和Lock锁实现了资源的并发访问控制，在同一时间只允许唯一了线程进入临界区访问资源(读锁除外)，这样子控制的主要目的是为了解决多个线程并发同一资源造成的数据不一致的问题。在另外一种场景下，一个资源有多个副本可供同时使用，比如打印机房有多个打印机、厕所有多个坑可供同时使用，这种情况下，Java提供了另外的并发访问控制–资源的多副本的并发访问控制，今天学习的信号量Semaphore即是其中的一种。</p>
<p>信号量主要用于两个目的，一个是用于多个共享资源的互斥使用，另一个用于并发线程数的控制。</p>
<h3 id="Semaphore的实现原理"><a href="#Semaphore的实现原理" class="headerlink" title="Semaphore的实现原理"></a>Semaphore的实现原理</h3><p>Semaphore是用来保护一个或者多个共享资源的访问，Semaphore内部维护了一个计数器，其值为可以访问的共享资源的个数。一个线程要访问共享资源，先获得信号量，如果信号量的计数器值大于1，意味着有共享资源可以访问，则使其计数器值减去1，再访问共享资源。</p>
<p>如果计数器值为0,线程进入休眠。当某个线程使用完共享资源后，释放信号量，并将信号量内部的计数器加1，之前进入休眠的线程将被唤醒并再次试图获得信号量。</p>
<p>就好比一个厕所管理员，站在门口，只有厕所有空位，就开门允许与空侧数量等量的人进入厕所。多个人进入厕所后，相当于N个人来分配使用N个空位。为避免多个人来同时竞争同一个侧卫，在内部仍然使用锁来控制资源的同步访问。</p>
<h3 id="信号量Semaphore的源码分析"><a href="#信号量Semaphore的源码分析" class="headerlink" title="信号量Semaphore的源码分析"></a>信号量Semaphore的源码分析</h3><p>在Java的并发包中，Semaphore类表示信号量。Semaphore内部主要通过AQS（AbstractQueuedSynchronizer）实现线程的管理。Semaphore有两个构造函数，参数permits表示许可数，它最后传递给了AQS的state值。线程在运行时首先获取许可，如果成功，许可数就减1，线程运行，当线程运行结束就释放许可，许可数就加1。如果许可数为0，则获取失败，线程位于AQS的等待队列中，它会被其它释放许可的线程唤醒。在创建Semaphore对象的时候还可以指定它的公平性。一般常用非公平的信号量，非公平信号量是指在获取许可时先尝试获取许可，而不必关心是否已有需要获取许可的线程位于等待队列中，如果获取失败，才会入列。而公平的信号量在获取许可时首先要查看等待队列中是否已有线程，如果有则入列。</p>
<ul>
<li><p><strong>构造函数源代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//非公平的构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Semaphore</span><span class="params">(<span class="keyword">int</span> permits)</span> </span>&#123;</span><br><span class="line">    sync = <span class="keyword">new</span> NonfairSync(permits);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过fair参数决定公平性</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Semaphore</span><span class="params">(<span class="keyword">int</span> permits, <span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">    sync = fair ? <span class="keyword">new</span> FairSync(permits) : <span class="keyword">new</span> NonfairSync(permits);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>acquire源代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    sync.acquireSharedInterruptibly(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireSharedInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">    <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>)</span><br><span class="line">        doAcquireSharedInterruptibly(arg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">nonfairTryAcquireShared</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> available = getState();</span><br><span class="line">        <span class="keyword">int</span> remaining = available - acquires;</span><br><span class="line">        <span class="keyword">if</span> (remaining &lt; <span class="number">0</span> ||</span><br><span class="line">            compareAndSetState(available, remaining))</span><br><span class="line">            <span class="keyword">return</span> remaining;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  可以看出，如果remaining &lt;0 即获取许可后，许可数小于0，则获取失败，在doAcquireSharedInterruptibly方法中线程会将自身阻塞，然后入列。</p>
</li>
<li><p><strong>release源代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">release</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync.releaseShared(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">releaseShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tryReleaseShared(arg)) &#123;</span><br><span class="line">        doReleaseShared();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryReleaseShared</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> current = getState();</span><br><span class="line">        <span class="keyword">int</span> next = current + releases;</span><br><span class="line">        <span class="keyword">if</span> (next &lt; current) <span class="comment">// overflow</span></span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum permit count exceeded"</span>);</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(current, next))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  可以看出释放许可就是将AQS中state的值加1。然后通过doReleaseShared唤醒等待队列的第一个节点。可以看出Semaphore使用的是AQS的共享模式，等待队列中的第一个节点，如果第一个节点成功获取许可，又会唤醒下一个节点，以此类推。</p>
</li>
</ul>
<h3 id="Semaphore的使用"><a href="#Semaphore的使用" class="headerlink" title="Semaphore的使用"></a>Semaphore的使用</h3><p>Semaphore使用时需要先构建一个参数来指定共享资源的数量，Semaphore构造完成后即是获取Semaphore、共享资源使用完毕后释放Semaphore。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Semaphore semaphore = <span class="keyword">new</span> Semaphore(<span class="number">10</span>,<span class="keyword">true</span>);  </span><br><span class="line">semaphore.acquire();  </span><br><span class="line"><span class="comment">//do something here  </span></span><br><span class="line">semaphore.release();</span><br></pre></td></tr></table></figure>
<p>下面的代码就是模拟控制商场厕所的并发使用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ResourceManage</span> </span>&#123;    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Semaphore semaphore ;    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> resourceArray[];    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock lock;    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ResourceManage</span><span class="params">()</span> </span>&#123;    </span><br><span class="line">        <span class="keyword">this</span>.resourceArray = <span class="keyword">new</span> <span class="keyword">boolean</span>[<span class="number">10</span>];<span class="comment">//存放厕所状态    </span></span><br><span class="line">        <span class="keyword">this</span>.semaphore = <span class="keyword">new</span> Semaphore(<span class="number">10</span>,<span class="keyword">true</span>);<span class="comment">//控制10个共享资源的使用，使用先进先出的公平模式进行共享;公平模式的信号量，先来的先获得信号量    </span></span><br><span class="line">        <span class="keyword">this</span>.lock = <span class="keyword">new</span> ReentrantLock(<span class="keyword">true</span>);<span class="comment">//公平模式的锁，先来的先选    </span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span> ;i&lt;<span class="number">10</span>; i++)&#123;    </span><br><span class="line">            resourceArray[i] = <span class="keyword">true</span>;<span class="comment">//初始化为资源可用的情况    </span></span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">useResource</span><span class="params">(<span class="keyword">int</span> userId)</span></span>&#123;   </span><br><span class="line">        semaphore.acquire();   </span><br><span class="line">        <span class="keyword">try</span>&#123;    </span><br><span class="line">            <span class="comment">//semaphore.acquire();    </span></span><br><span class="line">            <span class="keyword">int</span> id = getResourceId();<span class="comment">//占到一个坑    </span></span><br><span class="line">            System.out.print(<span class="string">"userId:"</span>+userId+<span class="string">"正在使用资源，资源id:"</span>+id+<span class="string">"\n"</span>);    </span><br><span class="line">            Thread.sleep(<span class="number">100</span>);<span class="comment">//do something，相当于于使用资源    </span></span><br><span class="line">            resourceArray[id] = <span class="keyword">true</span>;<span class="comment">//退出这个坑    </span></span><br><span class="line">        &#125;<span class="keyword">catch</span> (InterruptedException e)&#123;    </span><br><span class="line">            e.printStackTrace();    </span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;    </span><br><span class="line">            semaphore.release();<span class="comment">//释放信号量，计数器加1    </span></span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getResourceId</span><span class="params">()</span></span>&#123;    </span><br><span class="line">        <span class="keyword">int</span> id = -<span class="number">1</span>;   </span><br><span class="line">        lock.lock();  </span><br><span class="line">        <span class="keyword">try</span> &#123;    </span><br><span class="line">            <span class="comment">//lock.lock();//虽然使用了锁控制同步，但由于只是简单的一个数组遍历，效率还是很高的，所以基本不影响性能。    </span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++)&#123;    </span><br><span class="line">                <span class="keyword">if</span>(resourceArray[i])&#123;    </span><br><span class="line">                    resourceArray[i] = <span class="keyword">false</span>;    </span><br><span class="line">                    id = i;    </span><br><span class="line">                    <span class="keyword">break</span>;    </span><br><span class="line">                &#125;    </span><br><span class="line">            &#125;    </span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;    </span><br><span class="line">            e.printStackTrace();    </span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;    </span><br><span class="line">            lock.unlock();    </span><br><span class="line">        &#125;    </span><br><span class="line">        <span class="keyword">return</span> id;    </span><br><span class="line">    &#125;    </span><br><span class="line">&#125;    </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ResourceUser</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;    </span><br><span class="line">    <span class="keyword">private</span> ResourceManage resourceManage;    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> userId;    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ResourceUser</span><span class="params">(ResourceManage resourceManage, <span class="keyword">int</span> userId)</span> </span>&#123;    </span><br><span class="line">        <span class="keyword">this</span>.resourceManage = resourceManage;    </span><br><span class="line">        <span class="keyword">this</span>.userId = userId;    </span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;    </span><br><span class="line">        System.out.print(<span class="string">"userId:"</span>+userId+<span class="string">"准备使用资源...\n"</span>);    </span><br><span class="line">        resourceManage.useResource(userId);    </span><br><span class="line">        System.out.print(<span class="string">"userId:"</span>+userId+<span class="string">"使用资源完毕...\n"</span>);    </span><br><span class="line">    &#125;    </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;    </span><br><span class="line">        ResourceManage resourceManage = <span class="keyword">new</span> ResourceManage();    </span><br><span class="line">        Thread[] threads = <span class="keyword">new</span> Thread[<span class="number">100</span>];    </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;    </span><br><span class="line">            Thread thread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> ResourceUser(resourceManage,i));<span class="comment">//创建多个资源使用者    </span></span><br><span class="line">            threads[i] = thread;    </span><br><span class="line">        &#125;    </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++)&#123;    </span><br><span class="line">            Thread thread = threads[i];    </span><br><span class="line">            <span class="keyword">try</span> &#123;    </span><br><span class="line">                thread.start();<span class="comment">//启动线程    </span></span><br><span class="line">            &#125;<span class="keyword">catch</span> (Exception e)&#123;    </span><br><span class="line">                e.printStackTrace();    </span><br><span class="line">            &#125;    </span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后，Semaphore除了控制资源的多个副本的并发访问控制，也可以使用二进制信号量来实现类似synchronized关键字和Lock锁的并发访问控制功能。</p>
]]></content>
      
        <categories>
            
            <category> Thread </category>
            
        </categories>
        
        
        <tags>
            
            <tag> technology </tag>
            
            <tag> Semaphore </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[CyclicBarrier学习笔记]]></title>
      <url>/2018/01/07/CyclicBarrier%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      <content type="html"><![CDATA[<h3 id="类说明"><a href="#类说明" class="headerlink" title="类说明"></a>类说明</h3><p>一个同步辅助类，它允许一组线程互相等待，直到到达某个公共屏障点 (common barrier point)。在涉及一组固定大小的线程的程序中，这些线程必须不时地互相等待，此时 CyclicBarrier 很有用。因为该 barrier 在释放等待线程后可以重用，所以称它为循环的 barrier。比如有一组线程，都要往数据库里面写入操作，只有当所有的线程都往数据库里面写入数据之后，这些线程才能继续往下执行，这时候就可以使用CyclicBarrier了。当所有的等待线程释放之后,CyclicBarrier是可重用的。</p>
<p>CyclicBarrier有两个构造函数：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CyclicBarrier</span><span class="params">(<span class="keyword">int</span> parties, Runnable barrierAction)</span></span></span><br></pre></td></tr></table></figure></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CyclicBarrier</span><span class="params">(<span class="keyword">int</span> parties)</span></span></span><br></pre></td></tr></table></figure>
<p>参数parties指让多少个线程或者任务等待至barrier状态；参数barrierAction为当这些线程都达到barrier状态时会执行的内容。</p>
<h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><p>需要所有的子任务都完成时，才执行主任务，这个时候就可以选择使用CyclicBarrier。</p>
<h3 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h3><p>对于CyclicBarrier来说，最重要的是await()方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, BrokenBarrierException</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">await</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br></pre></td></tr></table></figure>
<p>第一个版本比较常用，用来挂起当前线程，直至所有线程都到达barrier状态再同时执行后续任务；</p>
<a id="more"></a>
<p>第二个版本是让这些线程等待至一定的时间，如果还有线程没有到达barrier状态就直接让到达barrier的线程执行后续任务。</p>
<p>返回：到达的当前线程的索引，其中，索引 getParties() - 1 指示将到达的第一个线程，零指示最后一个到达的线程</p>
<p>抛出：</p>
<p>InterruptedException - 如果当前线程在等待时被中断</p>
<p>BrokenBarrierException - 如果另一个 线程在当前线程等待时被中断或超时，或者重置了 barrier，或者在调用 await 时 barrier 被损坏，抑或由于异常而导致屏障操作（如果存在）失败。</p>
<h3 id="相关实例"><a href="#相关实例" class="headerlink" title="相关实例"></a>相关实例</h3><ul>
<li><p>应用场景一：赛跑时，等待所有人都准备好时，才起跑</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CyclicBarrierTest</span> </span>&#123;  </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, InterruptedException </span>&#123;  </span><br><span class="line">        <span class="comment">//如果将参数改为4，但是下面只加入了3个选手，这永远等待下去  </span></span><br><span class="line">        <span class="comment">//Waits until all parties have invoked await on this barrier.   </span></span><br><span class="line">        CyclicBarrier barrier = <span class="keyword">new</span> CyclicBarrier(<span class="number">3</span>);  </span><br><span class="line"></span><br><span class="line">        ExecutorService executor = Executors.newFixedThreadPool(<span class="number">3</span>);  </span><br><span class="line">        executor.submit(<span class="keyword">new</span> Thread(<span class="keyword">new</span> Runner(barrier, <span class="string">"1号选手"</span>)));  </span><br><span class="line">        executor.submit(<span class="keyword">new</span> Thread(<span class="keyword">new</span> Runner(barrier, <span class="string">"2号选手"</span>)));  </span><br><span class="line">        executor.submit(<span class="keyword">new</span> Thread(<span class="keyword">new</span> Runner(barrier, <span class="string">"3号选手"</span>)));  </span><br><span class="line"></span><br><span class="line">        executor.shutdown();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Runner</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;  </span><br><span class="line">    <span class="comment">// 一个同步辅助类，它允许一组线程互相等待，直到到达某个公共屏障点 (common barrier point)  </span></span><br><span class="line">    <span class="keyword">private</span> CyclicBarrier barrier;  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;  </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Runner</span><span class="params">(CyclicBarrier barrier, String name)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">super</span>();  </span><br><span class="line">        <span class="keyword">this</span>.barrier = barrier;  </span><br><span class="line">        <span class="keyword">this</span>.name = name;  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">try</span> &#123;  </span><br><span class="line">            Thread.sleep(<span class="number">1000</span> * (<span class="keyword">new</span> Random()).nextInt(<span class="number">8</span>));  </span><br><span class="line">            System.out.println(name + <span class="string">" 准备好了..."</span>);  </span><br><span class="line">            <span class="comment">// barrier的await方法，在所有参与者都已经在此 barrier 上调用 await 方法之前，将一直等待。  </span></span><br><span class="line">            barrier.await();  </span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;  </span><br><span class="line">            e.printStackTrace();  </span><br><span class="line">        &#125; <span class="keyword">catch</span> (BrokenBarrierException e) &#123;  </span><br><span class="line">            e.printStackTrace();  </span><br><span class="line">        &#125;  </span><br><span class="line">        System.out.println(name + <span class="string">" 起跑！"</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  输出结果：</p>
  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">3号选手 准备好了...</span><br><span class="line">2号选手 准备好了...</span><br><span class="line">1号选手 准备好了...</span><br><span class="line">1号选手 起跑！</span><br><span class="line">2号选手 起跑！</span><br><span class="line">3号选手 起跑！</span><br></pre></td></tr></table></figure>
</li>
<li><p>应用场景二：有几个同学约好一起去食堂吃饭，各自都从各自的宿舍出发，然后到宿舍楼下集合。当所有的人都到了宿舍楼下之后，再一起从宿舍楼下出发前往食堂吃饭。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.easyliu.java.demo.cyclicbarrier;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.BrokenBarrierException;  </span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CyclicBarrier;  </span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;  </span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CyclicBarrierTest</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> THREAD_NUMBER = <span class="number">3</span>;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> CyclicBarrier sCyclicBarrier = <span class="keyword">new</span> CyclicBarrier(  </span><br><span class="line">            THREAD_NUMBER, <span class="keyword">new</span> Runnable() &#123;  </span><br><span class="line">  </span><br><span class="line">                <span class="meta">@Override</span>  </span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">                    System.out.println(<span class="string">"大家都到达了宿舍楼下，一起出发吧。。。"</span>);  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;);  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </span><br><span class="line">        ExecutorService executorService = Executors  </span><br><span class="line">                .newFixedThreadPool(THREAD_NUMBER);  </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; THREAD_NUMBER; i++) &#123;  </span><br><span class="line">            executorService.execute(<span class="keyword">new</span> WalkFromDomitoryToCanteenRunnable(  </span><br><span class="line">                    sCyclicBarrier, <span class="string">"同学"</span> + i));  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">try</span> &#123;  </span><br><span class="line">            Thread.sleep(<span class="number">10000</span>);<span class="comment">//主线程睡眠  </span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;  </span><br><span class="line">            e.printStackTrace();  </span><br><span class="line">        &#125;  </span><br><span class="line">        System.out.println(<span class="string">"CyclicBarrier重用"</span>);  </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = THREAD_NUMBER; i &lt; THREAD_NUMBER * <span class="number">2</span>; i++) &#123;  </span><br><span class="line">            executorService.execute(<span class="keyword">new</span> WalkFromDomitoryToCanteenRunnable(  </span><br><span class="line">                    sCyclicBarrier, <span class="string">"同学"</span> + i));  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * 从宿舍到食堂线程 </span></span><br><span class="line"><span class="comment">     *  </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@author</span> LiuYi </span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     */</span>  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">WalkFromDomitoryToCanteenRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">private</span> CyclicBarrier mCyclicBarrier;  </span><br><span class="line">        <span class="keyword">private</span> String mName;  </span><br><span class="line">  </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">WalkFromDomitoryToCanteenRunnable</span><span class="params">(CyclicBarrier cyclicBarrier,  </span></span></span><br><span class="line"><span class="function"><span class="params">                String name)</span> </span>&#123;  </span><br><span class="line">            <span class="keyword">this</span>.mCyclicBarrier = cyclicBarrier;  </span><br><span class="line">            <span class="keyword">this</span>.mName = name;  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">        <span class="meta">@Override</span>  </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">            System.out.println(mName + <span class="string">"开始从宿舍出发。。。"</span>);  </span><br><span class="line">            <span class="keyword">try</span> &#123;  </span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);  </span><br><span class="line">                mCyclicBarrier.await();<span class="comment">// 等待别同学  </span></span><br><span class="line">                <span class="comment">// 前往食堂  </span></span><br><span class="line">                System.out.println(mName + <span class="string">"开始从宿舍楼下出发。。。"</span>);  </span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);  </span><br><span class="line">                System.out.println(mName + <span class="string">"达到食堂。。。"</span>);  </span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;  </span><br><span class="line">                e.printStackTrace();  </span><br><span class="line">            &#125; <span class="keyword">catch</span> (BrokenBarrierException e) &#123;  </span><br><span class="line">                e.printStackTrace();  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  输出结果如下：</p>
  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">同学1开始从宿舍出发。。。  </span><br><span class="line">同学0开始从宿舍出发。。。  </span><br><span class="line">同学2开始从宿舍出发。。。  </span><br><span class="line">大家都到达了宿舍楼下，一起出发吧。。。  </span><br><span class="line">同学1开始从宿舍楼下出发。。。  </span><br><span class="line">同学2开始从宿舍楼下出发。。。  </span><br><span class="line">同学0开始从宿舍楼下出发。。。  </span><br><span class="line">同学0达到食堂。。。  </span><br><span class="line">同学1达到食堂。。。  </span><br><span class="line">同学2达到食堂。。。  </span><br><span class="line">CyclicBarrier重用  </span><br><span class="line">同学3开始从宿舍出发。。。  </span><br><span class="line">同学5开始从宿舍出发。。。  </span><br><span class="line">同学4开始从宿舍出发。。。  </span><br><span class="line">大家都到达了宿舍楼下，一起出发吧。。。  </span><br><span class="line">同学5开始从宿舍楼下出发。。。  </span><br><span class="line">同学4开始从宿舍楼下出发。。。  </span><br><span class="line">同学3开始从宿舍楼下出发。。。  </span><br><span class="line">同学4达到食堂。。。  </span><br><span class="line">同学3达到食堂。。。  </span><br><span class="line">同学5达到食堂。。。</span><br></pre></td></tr></table></figure>
<p>  从输出结果可以看出实现了我们想要的效果，并且实现了CyclicBarrier的重用，因为初始化CyclicBarrier的时候只设置了让三个线程等待至barrier状态，也就是当有三个同学到达了宿舍楼下之后，就一起走。剩下的三个同学一起走。</p>
</li>
</ul>
<h3 id="总结-CountDownLatch、CyclicBarrier和Semaphore比较"><a href="#总结-CountDownLatch、CyclicBarrier和Semaphore比较" class="headerlink" title="总结(CountDownLatch、CyclicBarrier和Semaphore比较)"></a>总结(CountDownLatch、CyclicBarrier和Semaphore比较)</h3><ul>
<li><strong>相同点：</strong></li>
</ul>
<ol>
<li>CountDownLatch和CyclicBarrier都能够实现线程之间的等待。</li>
</ol>
<ul>
<li><strong>不同点：</strong></li>
</ul>
<ol>
<li><p>它们侧重点不同：CountDownLatch一般用于某个线程A等待若干个其他线程执行完任务之后，它才执行；<br>而CyclicBarrier一般用于一组线程互相等待至某个状态，然后这一组线程再同时执行；</p>
</li>
<li><p>重用性：CountDownLatch是不能够重用的，而CyclicBarrier是可以重用的。</p>
</li>
<li><p>Semaphore其实和锁有点类似，它一般用于控制对某组资源的访问权限。</p>
</li>
</ol>
]]></content>
      
        <categories>
            
            <category> Thread </category>
            
        </categories>
        
        
        <tags>
            
            <tag> technology </tag>
            
            <tag> CyclicBarrier </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[CountDownLatch学习笔记]]></title>
      <url>/2018/01/07/CountDownLatch%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      <content type="html"><![CDATA[<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>CountDownLatch是一个同步的辅助类，它可以允许一个或多个线程等待，直到一组在其它线程中的操作执行完成。</p>
<p>一个CountDownLatch会通过一个给定的count数来被初始化。其中await()方法会一直阻塞，直到当前的count被减到0，而这个过程是通过调用countDown()方法来实现的。在await()方法不再阻塞以后，所有等待的线程都会被释放，并且任何await()的子调用都会立刻返回。这是一次性的－－count不能被重置。如果你需要一种能重置count的版本，请考虑使用CyclicBarrier。</p>
<p>CountDownlatch是一个多功能的同步工具，可以被用于各种目的。一个CountDownLatch通过一个值为1的count被初始化，来作为一个开/关的门或门闩：所有调用了await()的线程都会在门前等待，直到门被一个线程通过调用countDown()打开。一个被初始化为N的CountDownLatch可以被用来“在N个线程都完成了某种操作（或者一些操作已经被完成了N次）之后创建一个线程”。</p>
<p>CountDownLatch一个有用的属性就是它不需要线程们在继续执行之前，调用countDown来等待count被减到0。它简单地阻止了任何调用了await()的线程继续，直到所有的线程都能够通过。</p>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>下面请看一个应用场景：<br>有1个driver和5个worker，需要满足以下两点要求：</p>
<p>当driver完成了全部的工作之后才允许worker们开始工作；<br>当所有的worker都完成了自己的工作之后，driver主线程才能结束。</p>
<a id="more"></a>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Driver</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        CountDownLatch startSignal = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</span><br><span class="line">        CountDownLatch doneSignal = <span class="keyword">new</span> CountDownLatch(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 依次创建并启动5个worker线程</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(<span class="keyword">new</span> Worker(startSignal, doneSignal)).start();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">"Driver is doing something..."</span>);</span><br><span class="line">        System.out.println(<span class="string">"Driver is Finished, start all workers ..."</span>);</span><br><span class="line">        startSignal.countDown(); <span class="comment">// Driver执行完毕，发出开始信号，使所有的worker线程开始执行</span></span><br><span class="line">        doneSignal.await(); <span class="comment">// 等待所有的worker线程执行结束</span></span><br><span class="line">        System.out.println(<span class="string">"Finished."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Worker</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> CountDownLatch startSignal;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> CountDownLatch doneSignal;</span><br><span class="line">    Worker(CountDownLatch startSignal, CountDownLatch doneSignal) &#123;</span><br><span class="line">        <span class="keyword">this</span>.startSignal = startSignal;</span><br><span class="line">        <span class="keyword">this</span>.doneSignal = doneSignal;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            startSignal.await(); <span class="comment">// 等待Driver线程执行完毕，获得开始信号</span></span><br><span class="line">            System.out.println(<span class="string">"Working now ..."</span>);</span><br><span class="line">            doneSignal.countDown(); <span class="comment">// 当前worker执行完毕，释放一个完成信号</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Driver is doing something...</span><br><span class="line">Driver is Finished, start all workers ...</span><br><span class="line">Working now ...</span><br><span class="line">Working now ...</span><br><span class="line">Working now ...</span><br><span class="line">Working now ...</span><br><span class="line">Working now ...</span><br><span class="line">Finished.</span><br></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> Thread </category>
            
        </categories>
        
        
        <tags>
            
            <tag> technology </tag>
            
            <tag> CountDownLatch </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[volatile关键字学习笔记]]></title>
      <url>/2018/01/07/volatile%E5%85%B3%E9%94%AE%E5%AD%97%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      <content type="html"><![CDATA[<h3 id="并发编程中的三个概念"><a href="#并发编程中的三个概念" class="headerlink" title="并发编程中的三个概念"></a>并发编程中的三个概念</h3><ul>
<li><p><strong>原子性</strong> </p>
<p>  原子性：即一个操作或者多个操作 要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行。</p>
</li>
<li><p><strong>可见性</strong></p>
<p>  可见性是指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。</p>
</li>
<li><p><strong>有序性</strong></p>
<p>  有序性：即程序执行的顺序按照代码的先后顺序执行。</p>
</li>
</ul>
<h3 id="深入剖析volatile关键字"><a href="#深入剖析volatile关键字" class="headerlink" title="深入剖析volatile关键字"></a>深入剖析volatile关键字</h3><ul>
<li><p><strong>volatile关键字的两层语义</strong></p>
<p>  一旦一个共享变量（类的成员变量、类的静态成员变量）被volatile修饰之后，那么就具备了两层语义：</p>
<p>  1）保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的。</p>
<p>  2）禁止进行指令重排序。</p>
<p>  先看一段代码，假如线程1先执行，线程2后执行：</p>
  <a id="more"></a>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//线程1</span></span><br><span class="line"><span class="keyword">boolean</span> stop = <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">while</span>(!stop)&#123;</span><br><span class="line">    doSomething();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//线程2</span></span><br><span class="line">stop = <span class="keyword">true</span>;</span><br></pre></td></tr></table></figure>
<p>  这段代码是很典型的一段代码，很多人在中断线程时可能都会采用这种标记办法。但是事实上，这段代码会完全运行正确么？即一定会将线程中断么？不一定，也许在大多数时候，这个代码能够把线程中断，但是也有可能会导致无法中断线程（虽然这个可能性很小，但是只要一旦发生这种情况就会造成死循环了）。</p>
<p>  下面解释一下这段代码为何有可能导致无法中断线程。在前面已经解释过，每个线程在运行过程中都有自己的工作内存，那么线程1在运行的时候，会将stop变量的值拷贝一份放在自己的工作内存当中。</p>
<p>  那么当线程2更改了stop变量的值之后，但是还没来得及写入主存当中，线程2转去做其他事情了，那么线程1由于不知道线程2对stop变量的更改，因此还会一直循环下去。</p>
<p>  但是用volatile修饰之后就变得不一样了：</p>
<p>  第一：使用volatile关键字会强制将修改的值立即写入主存；</p>
<p>  第二：使用volatile关键字的话，当线程2进行修改时，会导致线程1的工作内存中缓存变量stop的缓存行无效（反映到硬件层的话，就是CPU的L1或者L2缓存中对应的缓存行无效）；</p>
<p>  第三：由于线程1的工作内存中缓存变量stop的缓存行无效，所以线程1再次读取变量stop的值时会去主存读取。</p>
<p>  那么在线程2修改stop值时（当然这里包括2个操作，修改线程2工作内存中的值，然后将修改后的值写入内存），会使得线程1的工作内存中缓存变量stop的缓存行无效，然后线程1读取时，发现自己的缓存行无效，它会等待缓存行对应的主存地址被更新之后，然后去对应的主存读取最新的值。</p>
<p>  那么线程1读取到的就是最新的正确的值。</p>
</li>
<li><p><strong>volatile保证原子性吗？</strong></p>
<p>  从上面知道volatile关键字保证了操作的可见性，但是volatile能保证对变量的操作是原子性吗？</p>
<p>  下面看一个例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">volatile</span> <span class="keyword">int</span> inc = <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">increase</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        inc++;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Test test = <span class="keyword">new</span> Test();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">new</span> Thread()&#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">1000</span>;j++)</span><br><span class="line">                        test.increase();</span><br><span class="line">                &#125;;</span><br><span class="line">            &#125;.start();</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">while</span>(Thread.activeCount()&gt;<span class="number">1</span>)  <span class="comment">//保证前面的线程都执行完</span></span><br><span class="line">            Thread.yield();</span><br><span class="line">        System.out.println(test.inc);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  大家想一下这段程序的输出结果是多少？也许有些朋友认为是10000。但是事实上运行它会发现每次运行结果都不一致，都是一个小于10000的数字。</p>
<p>  可能有的朋友就会有疑问，不对啊，上面是对变量inc进行自增操作，由于volatile保证了可见性，那么在每个线程中对inc自增完之后，在其他线程中都能看到修改后的值啊，所以有10个线程分别进行了1000次操作，那么最终inc的值应该是1000*10=10000。</p>
<p>  这里面就有一个误区了，volatile关键字能保证可见性没有错，但是上面的程序错在没能保证原子性。可见性只能保证每次读取的是最新的值，但是volatile没办法保证对变量的操作的原子性。</p>
<p>  在前面已经提到过，自增操作是不具备原子性的，它包括读取变量的原始值、进行加1操作、写入工作内存。那么就是说自增操作的三个子操作可能会分割开执行，就有可能导致下面这种情况出现：</p>
<p>  假如某个时刻变量inc的值为10，</p>
<p>  线程1对变量进行自增操作，线程1先读取了变量inc的原始值，然后线程1被阻塞了；</p>
<p>  然后线程2对变量进行自增操作，线程2也去读取变量inc的原始值，由于线程1只是对变量inc进行读取操作，而没有对变量进行修改操作，所以不会导致线程2的工作内存中缓存变量inc的缓存行无效，所以线程2会直接去主存读取inc的值，发现inc的值时10，然后进行加1操作，并把11写入工作内存，最后写入主存。</p>
<p>  然后线程1接着进行加1操作，由于已经读取了inc的值，注意此时在线程1的工作内存中inc的值仍然为10，所以线程1对inc进行加1操作后inc的值为11，然后将11写入工作内存，最后写入主存。</p>
<p>  那么两个线程分别进行了一次自增操作后，inc只增加了1。</p>
<p>  解释到这里，可能有朋友会有疑问，不对啊，前面不是保证一个变量在修改volatile变量时，会让缓存行无效吗？然后其他线程去读就会读到新的值，对，这个没错。这个就是上面的happens-before规则中的volatile变量规则，但是要注意，线程1对变量进行读取操作之后，被阻塞了的话，并没有对inc值进行修改。然后虽然volatile能保证线程2对变量inc的值读取是从内存中读取的，但是线程1没有进行修改，所以线程2根本就不会看到修改的值。</p>
<p>  根源就在这里，自增操作不是原子性操作，而且volatile也无法保证对变量的任何操作都是原子性的。</p>
<p>  把上面的代码改成以下任何一种都可以达到效果：</p>
<p>  采用synchronized：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span>  <span class="keyword">int</span> inc = <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">increase</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        inc++;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Test test = <span class="keyword">new</span> Test();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">new</span> Thread()&#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">1000</span>;j++)</span><br><span class="line">                        test.increase();</span><br><span class="line">                &#125;;</span><br><span class="line">            &#125;.start();</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">while</span>(Thread.activeCount()&gt;<span class="number">1</span>)  <span class="comment">//保证前面的线程都执行完</span></span><br><span class="line">            Thread.yield();</span><br><span class="line">        System.out.println(test.inc);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  采用Lock：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span>  <span class="keyword">int</span> inc = <span class="number">0</span>;</span><br><span class="line">    Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">increase</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            inc++;</span><br><span class="line">        &#125; <span class="keyword">finally</span>&#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Test test = <span class="keyword">new</span> Test();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">new</span> Thread()&#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">1000</span>;j++)</span><br><span class="line">                        test.increase();</span><br><span class="line">                &#125;;</span><br><span class="line">            &#125;.start();</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">while</span>(Thread.activeCount()&gt;<span class="number">1</span>)  <span class="comment">//保证前面的线程都执行完</span></span><br><span class="line">            Thread.yield();</span><br><span class="line">        System.out.println(test.inc);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  采用AtomicInteger：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span>  AtomicInteger inc = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">increase</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        inc.getAndIncrement();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Test test = <span class="keyword">new</span> Test();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">new</span> Thread()&#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">1000</span>;j++)</span><br><span class="line">                        test.increase();</span><br><span class="line">                &#125;;</span><br><span class="line">            &#125;.start();</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">while</span>(Thread.activeCount()&gt;<span class="number">1</span>)  <span class="comment">//保证前面的线程都执行完</span></span><br><span class="line">            Thread.yield();</span><br><span class="line">        System.out.println(test.inc);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  在java 1.5的java.util.concurrent.atomic包下提供了一些原子操作类，即对基本数据类型的 自增（加1操作），自减（减1操作）、以及加法操作（加一个数），减法操作（减一个数）进行了封装，保证这些操作是原子性操作。atomic是利用CAS来实现原子性操作的（Compare And Swap），CAS实际上是利用处理器提供的CMPXCHG指令实现的，而处理器执行CMPXCHG指令是一个原子性操作。</p>
</li>
<li><p><strong>volatile能保证有序性吗？</strong></p>
<p>  在前面提到volatile关键字能禁止指令重排序，所以volatile能在一定程度上保证有序性。</p>
<p>  volatile关键字禁止指令重排序有两层意思：</p>
<p>  1）当程序执行到volatile变量的读操作或者写操作时，在其前面的操作的更改肯定全部已经进行，且结果已经对后面的操作可见；在其后面的操作肯定还没有进行；</p>
<p>  2）在进行指令优化时，不能将在对volatile变量访问的语句放在其后面执行，也不能把volatile变量后面的语句放到其前面执行。</p>
<p>  可能上面说的比较绕，举个简单的例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//x、y为非volatile变量</span></span><br><span class="line"><span class="comment">//flag为volatile变量</span></span><br><span class="line"> </span><br><span class="line">x = <span class="number">2</span>;        <span class="comment">//语句1</span></span><br><span class="line">y = <span class="number">0</span>;        <span class="comment">//语句2</span></span><br><span class="line">flag = <span class="keyword">true</span>;  <span class="comment">//语句3</span></span><br><span class="line">x = <span class="number">4</span>;         <span class="comment">//语句4</span></span><br><span class="line">y = -<span class="number">1</span>;       <span class="comment">//语句5</span></span><br></pre></td></tr></table></figure>
<p>  由于flag变量为volatile变量，那么在进行指令重排序的过程的时候，不会将语句3放到语句1、语句2前面，也不会讲语句3放到语句4、语句5后面。但是要注意语句1和语句2的顺序、语句4和语句5的顺序是不作任何保证的。</p>
<p>  并且volatile关键字能保证，执行到语句3时，语句1和语句2必定是执行完毕了的，且语句1和语句2的执行结果对语句3、语句4、语句5是可见的。</p>
<p>  那么我们回到前面举的一个例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//线程1:</span></span><br><span class="line">context = loadContext();   <span class="comment">//语句1</span></span><br><span class="line">inited = <span class="keyword">true</span>;             <span class="comment">//语句2</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//线程2:</span></span><br><span class="line"><span class="keyword">while</span>(!inited )&#123;</span><br><span class="line">  sleep()</span><br><span class="line">&#125;</span><br><span class="line">doSomethingwithconfig(context);</span><br></pre></td></tr></table></figure>
<p>  前面举这个例子的时候，提到有可能语句2会在语句1之前执行，那么久可能导致context还没被初始化，而线程2中就使用未初始化的context去进行操作，导致程序出错。</p>
<p>  这里如果用volatile关键字对inited变量进行修饰，就不会出现这种问题了，因为当执行到语句2时，必定能保证context已经初始化完毕。</p>
</li>
<li><p><strong>volatile的原理和实现机制</strong></p>
<p>  前面讲述了源于volatile关键字的一些使用，下面我们来探讨一下volatile到底如何保证可见性和禁止指令重排序的。</p>
<p>  下面这段话摘自《深入理解Java虚拟机》：</p>
<p>  “观察加入volatile关键字和没有加入volatile关键字时所生成的汇编代码发现，加入volatile关键字时，会多出一个lock前缀指令”</p>
<p>  lock前缀指令实际上相当于一个内存屏障（也成内存栅栏），内存屏障会提供3个功能：</p>
<p>  1）它确保指令重排序时不会把其后面的指令排到内存屏障之前的位置，也不会把前面的指令排到内存屏障的后面；即在执行到内存屏障这句指令时，在它前面的操作已经全部完成；</p>
<p>  2）它会强制将对缓存的修改操作立即写入主存；</p>
<p>  3）如果是写操作，它会导致其他CPU中对应的缓存行无效。</p>
</li>
</ul>
<h3 id="使用volatile关键字的场景"><a href="#使用volatile关键字的场景" class="headerlink" title="使用volatile关键字的场景"></a>使用volatile关键字的场景</h3><ul>
<li><p><strong>条件说明</strong></p>
<p>  synchronized关键字是防止多个线程同时执行一段代码，那么就会很影响程序执行效率，而volatile关键字在某些情况下性能要优于synchronized，但是要注意volatile关键字是无法替代synchronized关键字的，因为volatile关键字无法保证操作的原子性。通常来说，使用volatile必须具备以下2个条件：</p>
<p>  1）对变量的写操作不依赖于当前值</p>
<p>  2）该变量没有包含在具有其他变量的不变式中</p>
<p>  实际上，这些条件表明，可以被写入 volatile 变量的这些有效值独立于任何程序的状态，包括变量的当前状态。</p>
<p>  事实上，我的理解就是上面的2个条件需要保证操作是原子性操作，才能保证使用volatile关键字的程序在并发时能够正确执行。</p>
<p>  下面列举几个Java中使用volatile的几个场景。</p>
</li>
<li><p><strong>状态标记量</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">while</span>(!flag)&#123;</span><br><span class="line">    doSomething();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFlag</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    flag = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="keyword">boolean</span> inited = <span class="keyword">false</span>;</span><br><span class="line"><span class="comment">//线程1:</span></span><br><span class="line">context = loadContext();  </span><br><span class="line">inited = <span class="keyword">true</span>;            </span><br><span class="line"></span><br><span class="line"><span class="comment">//线程2:</span></span><br><span class="line"><span class="keyword">while</span>(!inited )&#123;</span><br><span class="line">sleep()</span><br><span class="line">&#125;</span><br><span class="line">doSomethingwithconfig(context);</span><br></pre></td></tr></table></figure>
</li>
<li><p>double check</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">null</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance==<span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span>(instance==<span class="keyword">null</span>)</span><br><span class="line">                    instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="Java-关键字volatile-与-synchronized-作用与区别"><a href="#Java-关键字volatile-与-synchronized-作用与区别" class="headerlink" title="Java 关键字volatile 与 synchronized 作用与区别"></a>Java 关键字volatile 与 synchronized 作用与区别</h3><ul>
<li><p><strong>volatile</strong></p>
<p>  它所修饰的变量不保留拷贝，直接访问主内存中的。</p>
<p>  在Java内存模型中，有main memory，每个线程也有自己的memory (例如寄存器)。为了性能，一个线程会在自己的memory中保持要访问的变量的副本。这样就会出现同一个变 量在某个瞬间，在一个线程的memory中的值可能与另外一个线程memory中的值，或者main memory中的值不一致的情况。 一个变量声明为volatile，就意味着这个变量是随时会被其他线程修改的，因此不能将它cache在线程memory中。</p>
</li>
<li><p><strong>synchronized</strong></p>
<p>  当它用来修饰一个方法或者一个代码块的时候，能够保证在同一时刻最多只有一个线程执行该段代码。</p>
<ol>
<li><p>当两个并发线程访问同一个对象object中的这个synchronized(this)同步代码块时，一个时间内只能有一个线程得到执行。另一个线程必须等待当前线程执行完这个代码块以后才能执行该代码块。</p>
</li>
<li><p>然而，当一个线程访问object的一个synchronized(this)同步代码块时，另一个线程仍然可以访问该object中的非synchronized(this)同步代码块。</p>
</li>
<li><p>尤其关键的是，当一个线程访问object的一个synchronized(this)同步代码块时，其他线程对object中所有其它synchronized(this)同步代码块的访问将被阻塞。</p>
</li>
<li><p>当一个线程访问object的一个synchronized(this)同步代码块时，它就获得了这个object的对象锁。结果，其它线程对该object对象所有同步代码部分的访问都被暂时阻塞。</p>
</li>
<li><p>以上规则对其它对象锁同样适用.</p>
</li>
</ol>
</li>
<li><p><strong>区别：</strong></p>
<ol>
<li>volatile是变量修饰符，而synchronized则作用于一段代码或方法。</li>
<li>volatile只是在线程内存和“主”内存间同步某个变量的值；而synchronized通过锁定和解锁某个监视器同步所有变量的值。显然synchronized要比volatile消耗更多资源。</li>
</ol>
</li>
</ul>
]]></content>
      
        <categories>
            
            <category> Thread </category>
            
        </categories>
        
        
        <tags>
            
            <tag> technology </tag>
            
            <tag> volatile </tag>
            
            <tag> synchronized </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[多条件condition学习笔记(生产者消费者模式实例)]]></title>
      <url>/2018/01/07/%E5%A4%9A%E6%9D%A1%E4%BB%B6condition%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>Java 并发包下的提供Lock，Lock相对于Synchronized可以更好的解决线程同步问题，更加的灵活和高效，并且ReadWriteLock锁还能实现读、写的分离。但线程间仅仅互斥是不够的，还需要通信，本篇的内容是基于上篇之上，使用Lock如何处理线程通信。阻塞队列(BlockingQueue)就是使用condition的和lock实现的。</p>
<h3 id="Condition介绍"><a href="#Condition介绍" class="headerlink" title="Condition介绍"></a>Condition介绍</h3><p>那么引入本篇的主角，Condition，Condition 将 Object的通信方法（wait、notify 和 notifyAll）分解成截然不同的对象，以便通过将这些对象与任意 Lock 实现组合使用，为每个对象提供多个等待 set （wait-set）。其中，Lock 替代了 synchronized 方法和语句的使用，Condition 替代了 Object 通信方法的使用。</p>
<p>在Condition中，用await()替换wait()，用signal()替换notify()，用signalAll()替换notifyAll()，传统线程的通信方式，Condition都可以实现，这里注意，Condition是被绑定到Lock上的，要创建一个Lock的Condition必须用newCondition()方法。</p>
<p>Condition的强大之处在于它可以为多个线程间建立不同的Condition， 使用synchronized/wait()只有一个阻塞队列，notifyAll会唤起所有阻塞队列下的线程，而使用lock/condition，可以实现多个阻塞队列，signalAll只会唤起某个阻塞队列下的阻塞线程。</p>
<a id="more"></a>
<h3 id="两种方式实现生产者消费者模式"><a href="#两种方式实现生产者消费者模式" class="headerlink" title="两种方式实现生产者消费者模式"></a>两种方式实现生产者消费者模式</h3><ul>
<li><p>使用synchronized/wait()实现生产者消费者模式如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//模拟生产和消费的对象</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Buffer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> maxSize;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Date&gt; storage;</span><br><span class="line">    Buffer(<span class="keyword">int</span> size)&#123;</span><br><span class="line">        maxSize=size;</span><br><span class="line">        storage=<span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//生产方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">()</span>  </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (storage.size() ==maxSize )&#123;<span class="comment">//如果队列满了</span></span><br><span class="line">                System.out.print(Thread.currentThread().getName()+<span class="string">": wait \n"</span>);;</span><br><span class="line">                wait();<span class="comment">//阻塞线程</span></span><br><span class="line">            &#125;</span><br><span class="line">            storage.add(<span class="keyword">new</span> Date());</span><br><span class="line">            System.out.print(Thread.currentThread().getName()+<span class="string">": put:"</span>+storage.size()+ <span class="string">"\n"</span>);</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            notifyAll();<span class="comment">//唤起线程</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;       </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//消费方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">take</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123; </span><br><span class="line">            <span class="keyword">while</span> (storage.size() ==<span class="number">0</span> )&#123;<span class="comment">//如果队列满了</span></span><br><span class="line">                System.out.print(Thread.currentThread().getName()+<span class="string">": wait \n"</span>);;</span><br><span class="line">                wait();<span class="comment">//阻塞线程</span></span><br><span class="line">            &#125;</span><br><span class="line">            Date d=((LinkedList&lt;Date&gt;)storage).poll();</span><br><span class="line">            System.out.print(Thread.currentThread().getName()+<span class="string">": take:"</span>+storage.size()+ <span class="string">"\n"</span>);</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            notifyAll();<span class="comment">//唤起线程</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;       </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//生产者</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Producer</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Buffer buffer;</span><br><span class="line">    Producer(Buffer b)&#123;</span><br><span class="line">        buffer=b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            buffer.put();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//消费者</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Buffer buffer;</span><br><span class="line">    Consumer(Buffer b)&#123;</span><br><span class="line">        buffer=b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            buffer.take();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//测试主函数</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] arg)</span></span>&#123;</span><br><span class="line">        Buffer buffer=<span class="keyword">new</span> Buffer(<span class="number">10</span>);</span><br><span class="line">        Producer producer=<span class="keyword">new</span> Producer(buffer);</span><br><span class="line">        Consumer consumer=<span class="keyword">new</span> Consumer(buffer);</span><br><span class="line">        <span class="comment">//创建线程执行生产和消费</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(producer,<span class="string">"producer-"</span>+i).start();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(consumer,<span class="string">"consumer-"</span>+i).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用lock/condition实现生产者消费者模式如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Condition;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Buffer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span>  <span class="keyword">final</span> Lock lock;</span><br><span class="line">    <span class="keyword">private</span>  <span class="keyword">final</span> Condition notFull;</span><br><span class="line">    <span class="keyword">private</span>  <span class="keyword">final</span> Condition notEmpty;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> maxSize;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Date&gt; storage;</span><br><span class="line">    Buffer(<span class="keyword">int</span> size)&#123;</span><br><span class="line">        <span class="comment">//使用锁lock，并且创建两个condition，相当于两个阻塞队列</span></span><br><span class="line">        lock=<span class="keyword">new</span> ReentrantLock();</span><br><span class="line">        notFull=lock.newCondition();</span><br><span class="line">        notEmpty=lock.newCondition();</span><br><span class="line">        maxSize=size;</span><br><span class="line">        storage=<span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">()</span>  </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;   </span><br><span class="line">            <span class="keyword">while</span> (storage.size() ==maxSize )&#123;<span class="comment">//如果队列满了</span></span><br><span class="line">                System.out.print(Thread.currentThread().getName()+<span class="string">": wait \n"</span>);;</span><br><span class="line">                notFull.await();<span class="comment">//阻塞生产线程</span></span><br><span class="line">            &#125;</span><br><span class="line">            storage.add(<span class="keyword">new</span> Date());</span><br><span class="line">            System.out.print(Thread.currentThread().getName()+<span class="string">": put:"</span>+storage.size()+ <span class="string">"\n"</span>);</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);         </span><br><span class="line">            notEmpty.signalAll();<span class="comment">//唤醒消费线程</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span>&#123;   </span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">take</span><span class="params">()</span> </span>&#123;       </span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;  </span><br><span class="line">            <span class="keyword">while</span> (storage.size() ==<span class="number">0</span> )&#123;<span class="comment">//如果队列满了</span></span><br><span class="line">                System.out.print(Thread.currentThread().getName()+<span class="string">": wait \n"</span>);;</span><br><span class="line">                notEmpty.await();<span class="comment">//阻塞消费线程</span></span><br><span class="line">            &#125;</span><br><span class="line">            Date d=((LinkedList&lt;Date&gt;)storage).poll();</span><br><span class="line">            System.out.print(Thread.currentThread().getName()+<span class="string">": take:"</span>+storage.size()+ <span class="string">"\n"</span>);</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);         </span><br><span class="line">            notFull.signalAll();<span class="comment">//唤醒生产线程</span></span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Producer</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Buffer buffer;</span><br><span class="line">    Producer(Buffer b)&#123;</span><br><span class="line">        buffer=b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            buffer.put();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Buffer buffer;</span><br><span class="line">    Consumer(Buffer b)&#123;</span><br><span class="line">        buffer=b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            buffer.take();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] arg)</span></span>&#123;</span><br><span class="line">        Buffer buffer=<span class="keyword">new</span> Buffer(<span class="number">10</span>);</span><br><span class="line">        Producer producer=<span class="keyword">new</span> Producer(buffer);</span><br><span class="line">        Consumer consumer=<span class="keyword">new</span> Consumer(buffer);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(producer,<span class="string">"producer-"</span>+i).start();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(consumer,<span class="string">"consumer-"</span>+i).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li>当生产者执行put方法时，调用notEmpty.signalAll()只会唤醒notEmpty.await()下的消费者线程。 </li>
<li>当消费者执行塔克方法时，调用notFull.signalAll()只会唤醒notFull.await()下的消费者线程。</li>
</ul>
]]></content>
      
        <categories>
            
            <category> Thread </category>
            
        </categories>
        
        
        <tags>
            
            <tag> technology </tag>
            
            <tag> Condition </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[阻塞队列BlockingQueue学习笔记]]></title>
      <url>/2018/01/07/%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97BlockingQueue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      <content type="html"><![CDATA[<h3 id="阻塞队列-BlockingQueue-介绍"><a href="#阻塞队列-BlockingQueue-介绍" class="headerlink" title="阻塞队列 (BlockingQueue)介绍"></a>阻塞队列 (BlockingQueue)介绍</h3><p>阻塞队列 (BlockingQueue)是Java util.concurrent包下重要的数据结构，BlockingQueue提供了线程安全的队列访问方式：当阻塞队列进行插入数据时，如果队列已满，线程将会阻塞等待直到队列非满；从阻塞队列取数据时，如果队列已空，线程将会阻塞等待直到队列非空。并发包下很多高级同步类的实现都是基于BlockingQueue实现的。</p>
<h3 id="BlockingQueue-的操作方法"><a href="#BlockingQueue-的操作方法" class="headerlink" title="BlockingQueue 的操作方法"></a>BlockingQueue 的操作方法</h3><p>BlockingQueue 具有 4 组不同的方法用于插入、移除以及对队列中的元素进行检查。如果请求的操作不能得到立即执行的话，每个方法的表现也不同。这些方法如下： </p>
<table>
<thead>
<tr>
<th>操作</th>
<th>抛异常</th>
<th>特定值</th>
<th>阻塞</th>
<th>超时</th>
</tr>
</thead>
<tbody>
<tr>
<td>插入</td>
<td>add(o)</td>
<td>offer(o)</td>
<td>put(o)</td>
<td>offer(o,timeout,timeunit)</td>
</tr>
<tr>
<td>移除</td>
<td>remove(o)</td>
<td>poll(o)</td>
<td>take(o)</td>
<td>poll(timeout,timeunit)</td>
</tr>
<tr>
<td>检查</td>
<td>element(o)</td>
<td>peek(o)</td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>四组不同的行为方式解释：</p>
<ul>
<li>抛异常：如果试图的操作无法立即执行，抛一个异常。</li>
<li>特定值：如果试图的操作无法立即执行，返回一个特定的值(常常是 true / false)。</li>
<li>阻塞：如果试图的操作无法立即执行，该方法调用将会发生阻塞，直到能够执行。</li>
<li>超时：如果试图的操作无法立即执行，该方法调用将会发生阻塞，直到能够执行，但等待时间不会超过给定值。返回一个特定值以告知该操作是否成功(典型的是true / false)。</li>
</ul>
<p>无法向一个 BlockingQueue 中插入 null。如果你试图插入 null，BlockingQueue 将会抛出一个 NullPointerException。</p>
<a id="more"></a>
<p>可以访问到 BlockingQueue 中的所有元素，而不仅仅是开始和结束的元素。比如说，你将一个对象放入队列之中以等待处理，但你的应用想要将其取消掉。那么你可以调用诸如 remove(o) 方法来将队列之中的特定对象进行移除。但是这么干效率并不高(译者注：基于队列的数据结构，获取除开始或结束位置的其他对象的效率不会太高)，因此你尽量不要用这一类的方法，除非你确实不得不那么做。</p>
<h3 id="BlockingQueue-的实现类"><a href="#BlockingQueue-的实现类" class="headerlink" title="BlockingQueue 的实现类"></a>BlockingQueue 的实现类</h3><p>BlockingQueue 是个接口，你需要使用它的实现之一来使用BlockingQueue，java.util.concurrent包下具有以下 BlockingQueue 接口的实现类：</p>
<ul>
<li><strong>ArrayBlockingQueue：</strong> ArrayBlockingQueue 是一个有界的阻塞队列，其内部实现是将对象放到一个数组里。有界也就意味着，它不能够存储无限多数量的元素。它有一个同一时间能够存储元素数量的上限。你可以在对其初始化的时候设定这个上限，但之后就无法对这个上限进行修改了(译者注：因为它是基于数组实现的，也就具有数组的特性：一旦初始化，大小就无法修改)。</li>
<li><strong>DelayQueue：</strong> DelayQueue 对元素进行持有直到一个特定的延迟到期。注入其中的元素必须实现 java.util.concurrent.Delayed 接口。</li>
<li><strong>LinkedBlockingQueue：</strong> LinkedBlockingQueue 内部以一个链式结构(链接节点)对其元素进行存储。如果需要的话，这一链式结构可以选择一个上限。如果没有定义上限，将使用 Integer.MAX_VALUE 作为上限。</li>
<li><strong>PriorityBlockingQueue：</strong> PriorityBlockingQueue 是一个无界的并发队列。它使用了和类java.util.PriorityQueue 一样的排序规则。你无法向这个队列中插入 null 值。所有插入到 PriorityBlockingQueue 的元素必须实现 java.lang.Comparable接口。因此该队列中元素的排序就取决于你自己的 Comparable 实现。</li>
<li><strong>SynchronousQueue：</strong> SynchronousQueue 是一个特殊的队列，它的内部同时只能够容纳单个元素。如果该队列已有一元素的话，试图向队列中插入一个新元素的线程将会阻塞，直到另一个线程将该元素从队列中抽走。同样，如果该队列为空，试图向队列中抽取一个元素的线程将会阻塞，直到另一个线程向队列中插入了一条新的元素。据此，把这个类称作一个队列显然是夸大其词了。它更多像是一个汇合点。</li>
</ul>
<h3 id="使用例子"><a href="#使用例子" class="headerlink" title="使用例子"></a>使用例子</h3><p>阻塞队列的最长使用的例子就是生产者消费者模式,也是各种实现生产者消费者模式方式中首选的方式。使用者不用关心什么阻塞生产，什么时候阻塞消费，使用非常方便，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> MyThread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.BlockingQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.LinkedBlockingQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BlockingQueueTest</span> </span>&#123;</span><br><span class="line">    <span class="comment">//生产者</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Producer</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> BlockingQueue&lt;Integer&gt; blockingQueue;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> flag;</span><br><span class="line">        <span class="keyword">private</span> Random random;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Producer</span><span class="params">(BlockingQueue&lt;Integer&gt; blockingQueue)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.blockingQueue = blockingQueue;</span><br><span class="line">            flag=<span class="keyword">false</span>;</span><br><span class="line">            random=<span class="keyword">new</span> Random();</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span>(!flag)&#123;</span><br><span class="line">                <span class="keyword">int</span> info=random.nextInt(<span class="number">100</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    blockingQueue.put(info);</span><br><span class="line">                    System.out.println(Thread.currentThread().getName()+<span class="string">" produce "</span>+info);</span><br><span class="line">                    Thread.sleep(<span class="number">50</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;               </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shutDown</span><span class="params">()</span></span>&#123;</span><br><span class="line">            flag=<span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//消费者</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> BlockingQueue&lt;Integer&gt; blockingQueue;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> flag;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Consumer</span><span class="params">(BlockingQueue&lt;Integer&gt; blockingQueue)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.blockingQueue = blockingQueue;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span>(!flag)&#123;</span><br><span class="line">                <span class="keyword">int</span> info;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    info = blockingQueue.take();</span><br><span class="line">                    System.out.println(Thread.currentThread().getName()+<span class="string">" consumer "</span>+info);</span><br><span class="line">                    Thread.sleep(<span class="number">50</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;               </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shutDown</span><span class="params">()</span></span>&#123;</span><br><span class="line">            flag=<span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        BlockingQueue&lt;Integer&gt; blockingQueue = <span class="keyword">new</span> LinkedBlockingQueue&lt;Integer&gt;(<span class="number">10</span>);</span><br><span class="line">        Producer producer=<span class="keyword">new</span> Producer(blockingQueue);</span><br><span class="line">        Consumer consumer=<span class="keyword">new</span> Consumer(blockingQueue);</span><br><span class="line">        <span class="comment">//创建5个生产者，5个消费者</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i&lt;<span class="number">5</span>)&#123;</span><br><span class="line">                <span class="keyword">new</span> Thread(producer,<span class="string">"producer"</span>+i).start();</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">new</span> Thread(consumer,<span class="string">"consumer"</span>+(i-<span class="number">5</span>)).start();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        producer.shutDown();</span><br><span class="line">        consumer.shutDown();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="阻塞队列原理"><a href="#阻塞队列原理" class="headerlink" title="阻塞队列原理"></a>阻塞队列原理</h3><p>其实阻塞队列实现阻塞同步的方式很简单，使用的就是是lock锁的多条件（condition）阻塞控制。使用BlockingQueue封装了根据条件阻塞线程的过程，而我们就不用关心繁琐的await/signal操作了。</p>
<p>下面是Jdk 1.7中ArrayBlockingQueue部分代码：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayBlockingQueue</span><span class="params">(<span class="keyword">int</span> capacity, <span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (capacity &lt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">        <span class="comment">//创建数组    </span></span><br><span class="line">        <span class="keyword">this</span>.items = <span class="keyword">new</span> Object[capacity];</span><br><span class="line">        <span class="comment">//创建锁和阻塞条件</span></span><br><span class="line">        lock = <span class="keyword">new</span> ReentrantLock(fair);   </span><br><span class="line">        notEmpty = lock.newCondition();</span><br><span class="line">        notFull =  lock.newCondition();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//添加元素的方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(E e)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        checkNotNull(e);</span><br><span class="line">        <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">        lock.lockInterruptibly();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (count == items.length)</span><br><span class="line">                notFull.await();</span><br><span class="line">            <span class="comment">//如果队列不满就入队</span></span><br><span class="line">            enqueue(e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//入队的方法</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(E x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Object[] items = <span class="keyword">this</span>.items;</span><br><span class="line">        items[putIndex] = x;</span><br><span class="line">        <span class="keyword">if</span> (++putIndex == items.length)</span><br><span class="line">            putIndex = <span class="number">0</span>;</span><br><span class="line">        count++;</span><br><span class="line">        notEmpty.signal();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//移除元素的方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">        lock.lockInterruptibly();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (count == <span class="number">0</span>)</span><br><span class="line">                notEmpty.await();</span><br><span class="line">            <span class="keyword">return</span> dequeue();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//出队的方法</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> E <span class="title">dequeue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Object[] items = <span class="keyword">this</span>.items;</span><br><span class="line">        <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">        E x = (E) items[takeIndex];</span><br><span class="line">        items[takeIndex] = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (++takeIndex == items.length)</span><br><span class="line">            takeIndex = <span class="number">0</span>;</span><br><span class="line">        count--;</span><br><span class="line">        <span class="keyword">if</span> (itrs != <span class="keyword">null</span>)</span><br><span class="line">            itrs.elementDequeued();</span><br><span class="line">        notFull.signal();</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="双端阻塞队列（BlockingDeque）"><a href="#双端阻塞队列（BlockingDeque）" class="headerlink" title="双端阻塞队列（BlockingDeque）"></a>双端阻塞队列（BlockingDeque）</h3><p>concurrent包下还提供双端阻塞队列（BlockingDeque），和BlockingQueue是类似的，只不过BlockingDeque提供从任意一端插入或者抽取元素的队列。</p>
]]></content>
      
        <categories>
            
            <category> Thread </category>
            
        </categories>
        
        
        <tags>
            
            <tag> technology </tag>
            
            <tag> BlockingQueue </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Lock学习笔记]]></title>
      <url>/2018/01/07/Lock%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      <content type="html"><![CDATA[<h2 id="API说明"><a href="#API说明" class="headerlink" title="API说明"></a>API说明</h2><ul>
<li><h3 id="Lock"><a href="#Lock" class="headerlink" title="Lock"></a>Lock</h3><p>  Lock是一个接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Lock</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">lockInterruptibly</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">(<span class="keyword">long</span> time, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">Condition <span class="title">newCondition</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><h3 id="Lock接口中方法的说明与使用"><a href="#Lock接口中方法的说明与使用" class="headerlink" title="Lock接口中方法的说明与使用"></a>Lock接口中方法的说明与使用</h3><p>  lock()方法是平常使用得最多的一个方法，就是用来获取锁。如果锁已被其他线程获取，则进行等待。</p>
<p>  如果采用Lock，必须主动去释放锁，并且在发生异常时，不会自动释放锁。因此一般来说，使用Lock必须在try{}catch{}块中进行，并且将释放锁的操作放在finally块中进行，以保证锁一定被被释放，防止死锁的发生。通常使用Lock来进行同步的话，是以下面这种形式去使用的：</p>
  <a id="more"></a>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Lock lock = ...;</span><br><span class="line">lock.lock();</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="comment">//处理任务</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(Exception ex)&#123;</span><br><span class="line">     </span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">    lock.unlock();   <span class="comment">//释放锁</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  tryLock()方法是有返回值的，它表示用来尝试获取锁，如果获取成功，则返回true，如果获取失败（即锁已被其他线程获取），则返回false，也就说这个方法无论如何都会立即返回。在拿不到锁时不会一直在那等待。</p>
<p>  tryLock(long time, TimeUnit unit)方法和tryLock()方法是类似的，只不过区别在于这个方法在拿不到锁时会等待一定的时间，在时间期限之内如果还拿不到锁，就返回false。如果如果一开始拿到锁或者在等待期间内拿到了锁，则返回true。</p>
<p>  所以，一般情况下通过tryLock来获取锁时是这样使用的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Lock lock = ...;</span><br><span class="line"><span class="keyword">if</span>(lock.tryLock()) &#123;</span><br><span class="line">     <span class="keyword">try</span>&#123;</span><br><span class="line">         <span class="comment">//处理任务</span></span><br><span class="line">     &#125;<span class="keyword">catch</span>(Exception ex)&#123;</span><br><span class="line">         </span><br><span class="line">     &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">         lock.unlock();   <span class="comment">//释放锁</span></span><br><span class="line">     &#125; </span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//如果不能获取锁，则直接做其他事情</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  lockInterruptibly()方法比较特殊，当通过这个方法去获取锁时，如果线程正在等待获取锁，则这个线程能够响应中断，即中断线程的等待状态。也就使说，当两个线程同时通过lock.lockInterruptibly()想获取某个锁时，假若此时线程A获取到了锁，而线程B只有在等待，那么对线程B调用threadB.interrupt()方法能够中断线程B的等待过程。由于lockInterruptibly()的声明中抛出了异常，所以lock.lockInterruptibly()必须放在try块中或者在调用lockInterruptibly()的方法外声明抛出InterruptedException。</p>
<p>  因此lockInterruptibly()一般的使用形式如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    lock.lockInterruptibly();</span><br><span class="line">    <span class="keyword">try</span> &#123;  </span><br><span class="line">     <span class="comment">//.....</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  注意，当一个线程获取了锁之后，是不会被interrupt()方法中断的。因为本身在前面的文章中讲过单独调用interrupt()方法不能中断正在运行过程中的线程，只能中断阻塞过程中的线程。</p>
<p>  因此当通过lockInterruptibly()方法获取某个锁时，如果不能获取到，只有进行等待的情况下，是可以响应中断的。</p>
<p>  而用synchronized修饰的话，当一个线程处于等待某个锁的状态，是无法被中断的，只有一直等待下去。</p>
</li>
<li><h3 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h3><p>  ReentrantLock，意思是“可重入锁”，ReentrantLock是唯一实现了Lock接口的类，并且ReentrantLock提供了更多的方法。下面通过一些实例看具体看一下如何使用ReentrantLock。</p>
<p>  例子1，lock()的正确使用方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;Integer&gt; arrayList = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span>  </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Test test = <span class="keyword">new</span> Test();</span><br><span class="line">         </span><br><span class="line">        <span class="keyword">new</span> Thread()&#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                test.insert(Thread.currentThread());</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;.start();</span><br><span class="line">         </span><br><span class="line">        <span class="keyword">new</span> Thread()&#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                test.insert(Thread.currentThread());</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;.start();</span><br><span class="line">    &#125;  </span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(Thread thread)</span> </span>&#123;</span><br><span class="line">        Lock lock = <span class="keyword">new</span> ReentrantLock();    <span class="comment">//注意这个地方</span></span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(thread.getName()+<span class="string">"得到了锁"</span>);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++) &#123;</span><br><span class="line">                arrayList.add(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="comment">// <span class="doctag">TODO:</span> handle exception</span></span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(thread.getName()+<span class="string">"释放了锁"</span>);</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Thread-0得到了锁</span><br><span class="line">Thread-1得到了锁</span><br><span class="line">Thread-0释放了锁</span><br><span class="line">Thread-1释放了锁</span><br></pre></td></tr></table></figure>
<p>  第二个线程怎么会在第一个线程释放锁之前得到了锁？原因在于，在insert方法中的lock变量是局部变量，每个线程执行该方法时都会保存一个副本，那么理所当然每个线程执行到lock.lock()处获取的是不同的锁，所以就不会发生冲突。</p>
<p>  知道了原因改起来就比较容易了，只需要将lock声明为类的属性即可。</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;Integer&gt; arrayList = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">    <span class="keyword">private</span> Lock lock = <span class="keyword">new</span> ReentrantLock();    <span class="comment">//注意这个地方</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span>  </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Test test = <span class="keyword">new</span> Test();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">new</span> Thread()&#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                test.insert(Thread.currentThread());</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;.start();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">new</span> Thread()&#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                test.insert(Thread.currentThread());</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;.start();</span><br><span class="line">    &#125;  </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(Thread thread)</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(thread.getName()+<span class="string">"得到了锁"</span>);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++) &#123;</span><br><span class="line">                arrayList.add(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="comment">// <span class="doctag">TODO:</span> handle exception</span></span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(thread.getName()+<span class="string">"释放了锁"</span>);</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  例子2，tryLock()的使用方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;Integer&gt; arrayList = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">    <span class="keyword">private</span> Lock lock = <span class="keyword">new</span> ReentrantLock();    <span class="comment">//注意这个地方</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span>  </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Test test = <span class="keyword">new</span> Test();</span><br><span class="line">         </span><br><span class="line">        <span class="keyword">new</span> Thread()&#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                test.insert(Thread.currentThread());</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;.start();</span><br><span class="line">         </span><br><span class="line">        <span class="keyword">new</span> Thread()&#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                test.insert(Thread.currentThread());</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;.start();</span><br><span class="line">    &#125;  </span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(Thread thread)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(lock.tryLock()) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(thread.getName()+<span class="string">"得到了锁"</span>);</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++) &#123;</span><br><span class="line">                    arrayList.add(i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                <span class="comment">// <span class="doctag">TODO:</span> handle exception</span></span><br><span class="line">            &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                System.out.println(thread.getName()+<span class="string">"释放了锁"</span>);</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(thread.getName()+<span class="string">"获取锁失败"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Thread-0得到了锁</span><br><span class="line">Thread-1获取锁失败</span><br><span class="line">Thread-0释放了锁</span><br></pre></td></tr></table></figure>
<p>  例子3，lockInterruptibly()响应中断的使用方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Lock lock = <span class="keyword">new</span> ReentrantLock();   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span>  </span>&#123;</span><br><span class="line">        Test test = <span class="keyword">new</span> Test();</span><br><span class="line">        MyThread thread1 = <span class="keyword">new</span> MyThread(test);</span><br><span class="line">        MyThread thread2 = <span class="keyword">new</span> MyThread(test);</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">         </span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        thread2.interrupt();</span><br><span class="line">    &#125;  </span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(Thread thread)</span> <span class="keyword">throws</span> InterruptedException</span>&#123;</span><br><span class="line">        lock.lockInterruptibly();   <span class="comment">//注意，如果需要正确中断等待锁的线程，必须将获取锁放在外面，然后将InterruptedException抛出</span></span><br><span class="line">        <span class="keyword">try</span> &#123;  </span><br><span class="line">            System.out.println(thread.getName()+<span class="string">"得到了锁"</span>);</span><br><span class="line">            <span class="keyword">long</span> startTime = System.currentTimeMillis();</span><br><span class="line">            <span class="keyword">for</span>(    ;     ;) &#123;</span><br><span class="line">                <span class="keyword">if</span>(System.currentTimeMillis() - startTime &gt;= Integer.MAX_VALUE)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="comment">//插入数据</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">"执行finally"</span>);</span><br><span class="line">            lock.unlock();</span><br><span class="line">            System.out.println(thread.getName()+<span class="string">"释放了锁"</span>);</span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Test test = <span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyThread</span><span class="params">(Test test)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.test = test;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         </span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            test.insert(Thread.currentThread());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">"被中断"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  运行之后，发现thread2能够被正确中断。</p>
</li>
<li><h3 id="ReadWriteLock"><a href="#ReadWriteLock" class="headerlink" title="ReadWriteLock"></a>ReadWriteLock</h3><p>  ReadWriteLock也是一个接口，在它里面只定义了两个方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ReadWriteLock</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns the lock used for reading.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the lock used for reading.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">Lock <span class="title">readLock</span><span class="params">()</span></span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns the lock used for writing.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the lock used for writing.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">Lock <span class="title">writeLock</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  一个用来获取读锁，一个用来获取写锁。也就是说将文件的读写操作分开，分成2个锁来分配给线程，从而使得多个线程可以同时进行读操作。下面的ReentrantReadWriteLock实现了ReadWriteLock接口。</p>
</li>
<li><h3 id="ReentrantReadWriteLock"><a href="#ReentrantReadWriteLock" class="headerlink" title="ReentrantReadWriteLock"></a>ReentrantReadWriteLock</h3><p>  ReentrantReadWriteLock里面提供了很多丰富的方法，不过最主要的有两个方法：readLock()和writeLock()用来获取读锁和写锁。<br>　<br>  下面通过几个例子来看一下ReentrantReadWriteLock具体用法。</p>
<p>  假如有多个线程要同时进行读操作的话，先看一下synchronized达到的效果：
　</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ReentrantReadWriteLock rwl = <span class="keyword">new</span> ReentrantReadWriteLock();</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span>  </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Test test = <span class="keyword">new</span> Test();</span><br><span class="line">         </span><br><span class="line">        <span class="keyword">new</span> Thread()&#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                test.get(Thread.currentThread());</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;.start();</span><br><span class="line">         </span><br><span class="line">        <span class="keyword">new</span> Thread()&#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                test.get(Thread.currentThread());</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;.start();</span><br><span class="line">         </span><br><span class="line">    &#125;  </span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">get</span><span class="params">(Thread thread)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">while</span>(System.currentTimeMillis() - start &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">            System.out.println(thread.getName()+<span class="string">"正在进行读操作"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(thread.getName()+<span class="string">"读操作完毕"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  这段程序的输出结果会是，直到thread1执行完读操作之后，才会打印thread2执行读操作的信息。</p>
  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Thread-0正在进行读操作</span><br><span class="line">Thread-0正在进行读操作</span><br><span class="line">Thread-0正在进行读操作</span><br><span class="line">Thread-0正在进行读操作</span><br><span class="line">Thread-0正在进行读操作</span><br><span class="line">Thread-0正在进行读操作</span><br><span class="line">Thread-0正在进行读操作</span><br><span class="line">Thread-0正在进行读操作</span><br><span class="line">Thread-0正在进行读操作</span><br><span class="line">Thread-0正在进行读操作</span><br><span class="line">Thread-0正在进行读操作</span><br><span class="line">Thread-0正在进行读操作</span><br><span class="line">Thread-0正在进行读操作</span><br><span class="line">Thread-0正在进行读操作</span><br><span class="line">Thread-0正在进行读操作</span><br><span class="line">Thread-0正在进行读操作</span><br><span class="line">Thread-0正在进行读操作</span><br><span class="line">Thread-0正在进行读操作</span><br><span class="line">Thread-0正在进行读操作</span><br><span class="line">Thread-0正在进行读操作</span><br><span class="line">Thread-0正在进行读操作</span><br><span class="line">Thread-0正在进行读操作</span><br><span class="line">Thread-0正在进行读操作</span><br><span class="line">Thread-0正在进行读操作</span><br><span class="line">Thread-0正在进行读操作</span><br><span class="line">Thread-0正在进行读操作</span><br><span class="line">Thread-0正在进行读操作</span><br><span class="line">Thread-0正在进行读操作</span><br><span class="line">Thread-0读操作完毕</span><br><span class="line">Thread-1正在进行读操作</span><br><span class="line">Thread-1正在进行读操作</span><br><span class="line">Thread-1正在进行读操作</span><br><span class="line">Thread-1正在进行读操作</span><br><span class="line">Thread-1正在进行读操作</span><br><span class="line">Thread-1正在进行读操作</span><br><span class="line">Thread-1正在进行读操作</span><br><span class="line">Thread-1正在进行读操作</span><br><span class="line">Thread-1正在进行读操作</span><br><span class="line">Thread-1正在进行读操作</span><br><span class="line">Thread-1正在进行读操作</span><br><span class="line">Thread-1正在进行读操作</span><br><span class="line">Thread-1正在进行读操作</span><br><span class="line">Thread-1正在进行读操作</span><br><span class="line">Thread-1正在进行读操作</span><br><span class="line">Thread-1正在进行读操作</span><br><span class="line">Thread-1正在进行读操作</span><br><span class="line">Thread-1正在进行读操作</span><br><span class="line">Thread-1正在进行读操作</span><br><span class="line">Thread-1正在进行读操作</span><br><span class="line">Thread-1正在进行读操作</span><br><span class="line">Thread-1正在进行读操作</span><br><span class="line">Thread-1正在进行读操作</span><br><span class="line">Thread-1正在进行读操作</span><br><span class="line">Thread-1正在进行读操作</span><br><span class="line">Thread-1正在进行读操作</span><br><span class="line">Thread-1正在进行读操作</span><br><span class="line">Thread-1正在进行读操作</span><br><span class="line">Thread-1正在进行读操作</span><br><span class="line">Thread-1正在进行读操作</span><br><span class="line">Thread-1正在进行读操作</span><br><span class="line">Thread-1正在进行读操作</span><br><span class="line">Thread-1正在进行读操作</span><br><span class="line">Thread-1正在进行读操作</span><br><span class="line">Thread-1正在进行读操作</span><br><span class="line">Thread-1正在进行读操作</span><br><span class="line">Thread-1正在进行读操作</span><br><span class="line">Thread-1正在进行读操作</span><br><span class="line">Thread-1正在进行读操作</span><br><span class="line">Thread-1正在进行读操作</span><br><span class="line">Thread-1正在进行读操作</span><br><span class="line">Thread-1正在进行读操作</span><br><span class="line">Thread-1正在进行读操作</span><br><span class="line">Thread-1读操作完毕</span><br></pre></td></tr></table></figure>
<p>  而改成用读写锁的话：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ReentrantReadWriteLock rwl = <span class="keyword">new</span> ReentrantReadWriteLock();</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span>  </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Test test = <span class="keyword">new</span> Test();</span><br><span class="line">         </span><br><span class="line">        <span class="keyword">new</span> Thread()&#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                test.get(Thread.currentThread());</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;.start();</span><br><span class="line">         </span><br><span class="line">        <span class="keyword">new</span> Thread()&#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                test.get(Thread.currentThread());</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;.start();</span><br><span class="line">         </span><br><span class="line">    &#125;  </span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">get</span><span class="params">(Thread thread)</span> </span>&#123;</span><br><span class="line">        rwl.readLock().lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">             </span><br><span class="line">            <span class="keyword">while</span>(System.currentTimeMillis() - start &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">                System.out.println(thread.getName()+<span class="string">"正在进行读操作"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(thread.getName()+<span class="string">"读操作完毕"</span>);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            rwl.readLock().unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Thread-0正在进行读操作</span><br><span class="line">Thread-0正在进行读操作</span><br><span class="line">Thread-1正在进行读操作</span><br><span class="line">Thread-0正在进行读操作</span><br><span class="line">Thread-1正在进行读操作</span><br><span class="line">Thread-0正在进行读操作</span><br><span class="line">Thread-1正在进行读操作</span><br><span class="line">Thread-1正在进行读操作</span><br><span class="line">Thread-1正在进行读操作</span><br><span class="line">Thread-1正在进行读操作</span><br><span class="line">Thread-1正在进行读操作</span><br><span class="line">Thread-1正在进行读操作</span><br><span class="line">Thread-0正在进行读操作</span><br><span class="line">Thread-0正在进行读操作</span><br><span class="line">Thread-0正在进行读操作</span><br><span class="line">Thread-0正在进行读操作</span><br><span class="line">Thread-1正在进行读操作</span><br><span class="line">Thread-1正在进行读操作</span><br><span class="line">Thread-1正在进行读操作</span><br><span class="line">Thread-1正在进行读操作</span><br><span class="line">Thread-0正在进行读操作</span><br><span class="line">Thread-1正在进行读操作</span><br><span class="line">Thread-1正在进行读操作</span><br><span class="line">Thread-0正在进行读操作</span><br><span class="line">Thread-1正在进行读操作</span><br><span class="line">Thread-1正在进行读操作</span><br><span class="line">Thread-0正在进行读操作</span><br><span class="line">Thread-1正在进行读操作</span><br><span class="line">Thread-1正在进行读操作</span><br><span class="line">Thread-1正在进行读操作</span><br><span class="line">Thread-0正在进行读操作</span><br><span class="line">Thread-1正在进行读操作</span><br><span class="line">Thread-1正在进行读操作</span><br><span class="line">Thread-0正在进行读操作</span><br><span class="line">Thread-1正在进行读操作</span><br><span class="line">Thread-0正在进行读操作</span><br><span class="line">Thread-1正在进行读操作</span><br><span class="line">Thread-0正在进行读操作</span><br><span class="line">Thread-1正在进行读操作</span><br><span class="line">Thread-0正在进行读操作</span><br><span class="line">Thread-1正在进行读操作</span><br><span class="line">Thread-0正在进行读操作</span><br><span class="line">Thread-1正在进行读操作</span><br><span class="line">Thread-0正在进行读操作</span><br><span class="line">Thread-1正在进行读操作</span><br><span class="line">Thread-0正在进行读操作</span><br><span class="line">Thread-1正在进行读操作</span><br><span class="line">Thread-0读操作完毕</span><br><span class="line">Thread-1读操作完毕</span><br></pre></td></tr></table></figure>
<p>  说明thread1和thread2在同时进行读操作。</p>
<p>  这样就大大提升了读操作的效率。</p>
<p>  不过要注意的是，如果有一个线程已经占用了读锁，则此时其他线程如果要申请写锁，则申请写锁的线程会一直等待释放读锁。</p>
<p>  如果有一个线程已经占用了写锁，则此时其他线程如果申请写锁或者读锁，则申请的线程会一直等待释放写锁。</p>
</li>
<li><h3 id="Lock和synchronized的选择"><a href="#Lock和synchronized的选择" class="headerlink" title="Lock和synchronized的选择"></a>Lock和synchronized的选择</h3><p>  总结来说，Lock和synchronized有以下几点不同：</p>
<p>  1）Lock是一个接口，而synchronized是Java中的关键字，synchronized是内置的语言实现；</p>
<p>  2）synchronized在发生异常时，会自动释放线程占有的锁，因此不会导致死锁现象发生；而Lock在发生异常时，如果没有主动通过unLock()去释放锁，则很可能造成死锁现象，因此使用Lock时需要在finally块中释放锁；</p>
<p>  3）Lock可以让等待锁的线程响应中断，而synchronized却不行，使用synchronized时，等待的线程会一直等待下去，不能够响应中断；</p>
<p>  4）通过Lock可以知道有没有成功获取锁，而synchronized却无法办到。</p>
<p>  5）Lock可以提高多个线程进行读操作的效率。</p>
<p>  在性能上来说，如果竞争资源不激烈，两者的性能是差不多的，而当竞争资源非常激烈时（即有大量线程同时竞争），此时Lock的性能要远远优于synchronized。所以说，在具体使用时要根据适当情况选择。</p>
<p>  <br></p>
</li>
</ul>
<h2 id="锁的相关概念介绍"><a href="#锁的相关概念介绍" class="headerlink" title="锁的相关概念介绍"></a>锁的相关概念介绍</h2><p>在前面介绍了Lock的基本使用，这一节来介绍一下与锁相关的几个概念。</p>
<ul>
<li><h3 id="可重入锁"><a href="#可重入锁" class="headerlink" title="可重入锁"></a>可重入锁</h3><p>  如果锁具备可重入性，则称作为可重入锁。像synchronized和ReentrantLock都是可重入锁，可重入性在我看来实际上表明了锁的分配机制：基于线程的分配，而不是基于方法调用的分配。举个简单的例子，当一个线程执行到某个synchronized方法时，比如说method1，而在method1中会调用另外一个synchronized方法method2，此时线程不必重新去申请锁，而是可以直接执行方法method2。</p>
<p>  看下面这段代码就明白了：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        method2();</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  上述代码中的两个方法method1和method2都用synchronized修饰了，假如某一时刻，线程A执行到了method1，此时线程A获取了这个对象的锁，而由于method2也是synchronized方法，假如synchronized不具备可重入性，此时线程A需要重新申请锁。但是这就会造成一个问题，因为线程A已经持有了该对象的锁，而又在申请获取该对象的锁，这样就会线程A一直等待永远不会获取到的锁。</p>
<p>  而由于synchronized和Lock都具备可重入性，所以不会发生上述现象。</p>
</li>
<li><h3 id="可中断锁"><a href="#可中断锁" class="headerlink" title="可中断锁"></a>可中断锁</h3><p>  可中断锁：顾名思义，就是可以相应中断的锁。</p>
<p>  在Java中，synchronized就不是可中断锁，而Lock是可中断锁。</p>
<p>  如果某一线程A正在执行锁中的代码，另一线程B正在等待获取该锁，可能由于等待时间过长，线程B不想等待了，想先处理其他事情，我们可以让它中断自己或者在别的线程中中断它，这种就是可中断锁。</p>
<p>  在前面演示lockInterruptibly()的用法时已经体现了Lock的可中断性。
　　</p>
</li>
<li><h3 id="公平锁"><a href="#公平锁" class="headerlink" title="公平锁"></a>公平锁</h3><p>  公平锁即尽量以请求锁的顺序来获取锁。比如同是有多个线程在等待一个锁，当这个锁被释放时，等待时间最久的线程（最先请求的线程）会获得该所，这种就是公平锁。</p>
<p>  非公平锁即无法保证锁的获取是按照请求锁的顺序进行的。这样就可能导致某个或者一些线程永远获取不到锁。</p>
<p>  在Java中，synchronized就是非公平锁，它无法保证等待的线程获取锁的顺序。</p>
<p>  而对于ReentrantLock和ReentrantReadWriteLock，它默认情况下是非公平锁，但是可以设置为公平锁。<br>　　<br>  我们可以在创建ReentrantLock对象时，通过以下方式来设置锁的公平性：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ReentrantLock lock = <span class="keyword">new</span> ReentrantLock(<span class="keyword">true</span>);</span><br></pre></td></tr></table></figure>
<p>  如果参数为true表示为公平锁，为fasle为非公平锁。默认情况下，如果使用无参构造器，则是非公平锁。</p>
<p>  另外在ReentrantLock类中定义了很多方法，比如：</p>
<p>  isFair()        //判断锁是否是公平锁</p>
<p>  isLocked()    //判断锁是否被任何线程获取了</p>
<p>  isHeldByCurrentThread()   //判断锁是否被当前线程获取了</p>
<p>  hasQueuedThreads()   //判断是否有线程在等待该锁</p>
<p>  在ReentrantReadWriteLock中也有类似的方法，同样也可以设置为公平锁和非公平锁。不过要记住，ReentrantReadWriteLock并未实现Lock接口，它实现的是ReadWriteLock接口。</p>
</li>
<li><h3 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h3><p>  读写锁将对一个资源（比如文件）的访问分成了2个锁，一个读锁和一个写锁。</p>
<p>  正因为有了读写锁，才使得多个线程之间的读操作不会发生冲突。</p>
<p>  ReadWriteLock就是读写锁，它是一个接口，ReentrantReadWriteLock实现了这个接口。</p>
<p>  可以通过readLock()获取读锁，通过writeLock()获取写锁。</p>
<p>  上面已经演示过了读写锁的使用方法，在此不再赘述。</p>
</li>
</ul>
]]></content>
      
        <categories>
            
            <category> Thread </category>
            
        </categories>
        
        
        <tags>
            
            <tag> technology </tag>
            
            <tag> Lock </tag>
            
            <tag> ReentrantLock </tag>
            
            <tag> ReadWriteLock </tag>
            
            <tag> ReentrantReadWriteLock </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[一花一世界]]></title>
      <url>/2017/12/24/%E4%B8%80%E8%8A%B1%E4%B8%80%E4%B8%96%E7%95%8C/</url>
      <content type="html"><![CDATA[<p>闲来无事，总想写点东西，不知这种感觉你是否也从拥有。</p>
<p>其实，这种感觉并非空穴来风，而是源自你内心深处最真实的想法。这可能就是所谓的感由心生。</p>
<p>最近，爱上了一种安静，甚至可以说是宁静，时常地思考或者回忆，浮现出一幅幅画面，不知这种喜欢你是否也感同深受。</p>
<p>其实，这种喜欢并非妙不可言，而是情感的变化凸显了这种微妙。这可能就是所谓的境由情生。</p>
<p>很多时候，梦境中的情形似曾相识，在某年某月某日的某个时刻，你就是梦境中的主人公。</p>
<p>其实，这种情景是对美好生活的极度渴望和向往。如果，梦不再那么模糊，梦中的细节得以延续，那将会是另一个世界。这可能就是所谓的一花一世界。</p>
<a id="more"></a>
<p><br></p>
<h3 id="nbsp-nbsp-nbsp-版权声明：本文为博主原创文章，转载请标明作者和原链接"><a href="#nbsp-nbsp-nbsp-版权声明：本文为博主原创文章，转载请标明作者和原链接" class="headerlink" title="| &nbsp;&nbsp;&nbsp;版权声明：本文为博主原创文章，转载请标明作者和原链接"></a><font color="red"><b>| &nbsp;&nbsp;&nbsp;版权声明：本文为博主原创文章，转载请标明作者和原链接<br></b></font></h3>]]></content>
      
        <categories>
            
            <category> 情感 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 感觉 </tag>
            
            <tag> 梦境 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[岁月如光，时光静好]]></title>
      <url>/2017/12/24/%E5%B2%81%E6%9C%88%E5%A6%82%E5%85%89%EF%BC%8C%E6%97%B6%E5%85%89%E9%9D%99%E5%A5%BD/</url>
      <content type="html"><![CDATA[<p>不知道，失眠是否是对一个人意志上的考验，然而，此刻，在这个静谧深邃、月光如水的夜晚，我却辗转反侧。</p>
<p>有时候，一支优美的音乐，或是因为它的旋律动人，或是因为它的伤感离愁，总是勾勒起对过去的往往。这种微妙的情感，唯泪流满面不止。因为，它触动的是你内心最柔弱的那一点。</p>
<p>创作的源泉，或者说是素材，来源于不平凡的点点滴滴。心跳般的跌宕人生，必是一段刻骨铭心的经历。</p>
<p>忆千年久远，古有勇赴鸿门宴，逼至西楚霸王乌江自刎，开创大汉王朝的汉高祖刘邦。亦有耻受胯下之辱，一雪前耻的西汉开国名将韩信。亦有令汉朝皇室皇叔刘备三顾茅庐、令号称拥有百万雄狮的丞相曹操心不甘，情不愿草船借箭、令东吴最为倚重的大都督周瑜感叹既生瑜，何生亮、北征前作催人泪下，留芳百世，肺腑之言绝笔出师表、于城上敌楼前，凭栏而坐，焚香抚琴，不费一兵一卒击退魏国军师司马懿十万大军，坐唱空城计的三国诸葛孔明。亦有放荡不羁，把酒吟月，钟鼓馔玉不足贵，但愿长醉不复醒，留下千古绝唱的李白。数风流人物，还看今朝。指挥红军万里长征，八年抗战，三年内战的辉煌胜利，开国伟大的领袖毛泽东同志亦是最可爱的人。</p>
<p>如果说在这个静谧深邃、月光如水的夜晚，配上一支优美的音乐，浮现不平凡的点点滴滴，你的内心是否还依然如此平静，你是否被这个寂静的深夜所深深吸引而无法入睡。</p>
<p>明天，是美好的一天。</p>
<a id="more"></a>
<p><br></p>
<h3 id="nbsp-nbsp-nbsp-版权声明：本文为博主原创文章，转载请标明作者和原链接"><a href="#nbsp-nbsp-nbsp-版权声明：本文为博主原创文章，转载请标明作者和原链接" class="headerlink" title="| &nbsp;&nbsp;&nbsp;版权声明：本文为博主原创文章，转载请标明作者和原链接"></a><font color="red"><b>| &nbsp;&nbsp;&nbsp;版权声明：本文为博主原创文章，转载请标明作者和原链接<br></b></font></h3>]]></content>
      
        <categories>
            
            <category> 情感 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 失眠 </tag>
            
            <tag> 夜晚 </tag>
            
            <tag> 音乐 </tag>
            
            <tag> 历史 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Spring Cloud之Hystrix学习笔记]]></title>
      <url>/2017/12/24/Spring%20Cloud%E4%B9%8BHystrix%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      <content type="html"><![CDATA[<h3 id="Hystrix介绍"><a href="#Hystrix介绍" class="headerlink" title="Hystrix介绍"></a>Hystrix介绍</h3><p>Spring Cloud Hystrix实现了断路器、线程隔离等一系列服务保护功能。它是基于Netflix的开源框架Hystrix实现的，该框架的目标在于通过控制那些访问远程系统、服务和第三方库的节点，从而对延迟和故障提供更强大的容错能力。Hystrix具备服务降级、服务熔断、线程和信号隔离、请求缓存、请求合并以及服务监控等强大功能。</p>
<h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><ul>
<li>需要启动的工程：<ol>
<li>eureka-server工程：服务注册中心。</li>
<li>hello-service工程：HELLO-SERVICE的服务单元，启动两个不同端口的服务实例。</li>
<li>ribbon-consume工程：使用Ribbon实现的服务消费者。</li>
</ol>
</li>
</ul>
<h3 id="引入Spring-Cloud-Hystrix"><a href="#引入Spring-Cloud-Hystrix" class="headerlink" title="引入Spring Cloud Hystrix"></a>引入Spring Cloud Hystrix</h3><ul>
<li><p>在ribbon-consumer工程的pom.xml的dependency节点中引入spring-cloud-starter-hystrix依赖</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">	&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">	&lt;artifactId&gt;spring-cloud-starter-hystrix&lt;/artifactId&gt;</span><br><span class="line">dependency&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在ribbon-consumer工程的主类中使用@EnableCircuitBreaker注解开启断路器功能</p>
</li>
</ul>
<a id="more"></a>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1.EnableCircuitBreaker 熔断器配置注解</span></span><br><span class="line"><span class="comment">//2.EnableDiscoveryClient 服务注册与发现注解</span></span><br><span class="line"><span class="comment">//3.SpringBootApplication springboot启动类注解</span></span><br><span class="line"><span class="comment">//4.SpringCloudApplication 包含上面3个注解</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@EnableCircuitBreaker</span></span><br><span class="line"><span class="meta">@EnableDiscoveryClient</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RibbonConsumerApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">  <span class="meta">@LoadBalanced</span></span><br><span class="line">  <span class="function">RestTemplate <span class="title">restTemplate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	  <span class="keyword">return</span> <span class="keyword">new</span> RestTemplate();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">	  SpringApplication.run(RibbonConsumerApplication.class, args);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>添加HelloService类，注入RestTemplate实例，在需要断路处理的方法上添加@HystrixCommand注解来指定回调方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@HystrixCommand</span>(fallbackMethod = <span class="string">"helloFallback"</span>, commandKey = <span class="string">"helloKey"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">helloConsumer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//添加HystrixCommand注解来制定回调方法</span></span><br><span class="line">    String result = restTemplate.getForEntity(<span class="string">"http://HELLO-SERVICE/hello"</span>, String.class).getBody();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">    logger.info(<span class="string">"Spend time:"</span>+(end - start));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">helloFallback</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"error"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>停止其中一个端口的Hello-Service，确保其他工程均已启动，访问<a href="http://localhost:9001/ribbon-consumer" target="_blank" rel="noopener">http://localhost:9001/ribbon-consumer</a> ，当轮询访问到停止的端口的服务时，输出内容为error，而不再是错误内容。</p>
</li>
</ul>
<h3 id="Hystrix-仪表盘介绍"><a href="#Hystrix-仪表盘介绍" class="headerlink" title="Hystrix 仪表盘介绍"></a>Hystrix 仪表盘介绍</h3><p>主要用来实时监控Hystrix 的各项指标信息。通过Hystrix Dasboard反馈的实时信息，可以帮助我们快速发现系统中存在的问题，从而及时的采取应对措施。</p>
<h3 id="Hystrix-Dashboard的架构介绍"><a href="#Hystrix-Dashboard的架构介绍" class="headerlink" title="Hystrix Dashboard的架构介绍"></a>Hystrix Dashboard的架构介绍</h3><p>本节中我们将在Hystrix入门例子的基础上，构建一个Hystrix Dashboard来对RIBBON-CONSUMER实时监控，完成后的架构如下图所示：<br><img src="https://github.com/dicheng52119/dicheng52119.github.io/blob/master/images/spring-cloud/Hystrix%20Dashboard%E6%9E%B6%E6%9E%84%E5%9B%BE.png?raw=true" alt=""></p>
<h3 id="Hystrix-Dashboard的快速构建"><a href="#Hystrix-Dashboard的快速构建" class="headerlink" title="Hystrix Dashboard的快速构建"></a>Hystrix Dashboard的快速构建</h3><ul>
<li>创建一个标准的Spring Boot工程，命名为hystrix-dashboard。</li>
<li><p>编辑pom.xml，具体依赖内容如下所以：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line">	&lt;dependency&gt;</span><br><span class="line">		&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">		&lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt;</span><br><span class="line">	&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">	&lt;dependency&gt;</span><br><span class="line">		&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">		&lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;</span><br><span class="line">		&lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">	&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">	&lt;dependency&gt;</span><br><span class="line">		&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">		&lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;</span><br><span class="line">	&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">	&lt;dependency&gt;</span><br><span class="line">		&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">		&lt;artifactId&gt;spring-cloud-starter-hystrix&lt;/artifactId&gt;</span><br><span class="line">	&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">	&lt;dependency&gt;</span><br><span class="line">		&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">		&lt;artifactId&gt;spring-cloud-starter-hystrix-dashboard&lt;/artifactId&gt;</span><br><span class="line">	&lt;/dependency&gt;</span><br><span class="line">&lt;/dependencies&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependencyManagement&gt;</span><br><span class="line">	&lt;!--</span><br><span class="line">		旧版本的</span><br><span class="line">		&lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;</span><br><span class="line">		&lt;version&gt;1.3.5.RELEASE&lt;/version&gt;</span><br><span class="line">		对应旧版本的</span><br><span class="line">		&lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt;</span><br><span class="line">		&lt;version&gt;Brixton.RELEASE&lt;/version&gt;</span><br><span class="line"></span><br><span class="line">		新版本的</span><br><span class="line">		&lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;</span><br><span class="line">		&lt;version&gt;1.5.3.RELEASE&lt;/version&gt;</span><br><span class="line">		对应新版本的</span><br><span class="line">		&lt;spring-cloud.version&gt;Dalston.SR1&lt;/spring-cloud.version&gt;</span><br><span class="line"></span><br><span class="line">		otherwise ， 报错。。。</span><br><span class="line">	--&gt;</span><br><span class="line">	&lt;dependencies&gt;</span><br><span class="line">		&lt;dependency&gt;</span><br><span class="line">			&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">			&lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt;</span><br><span class="line">			&lt;version&gt;Dalston.SR1&lt;/version&gt;</span><br><span class="line">			&lt;type&gt;pom&lt;/type&gt;</span><br><span class="line">			&lt;scope&gt;import&lt;/scope&gt;</span><br><span class="line">		&lt;/dependency&gt;</span><br><span class="line">	&lt;/dependencies&gt;</span><br><span class="line">&lt;/dependencyManagement&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>为应用主类加上@EnableHystrixDashboard，启用Hystrix Dashboard功能。</p>
</li>
<li><p>根据实际情况修改application.properties配置文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">spring.application.name=hystrix-dashboard</span><br><span class="line">server.port=2001</span><br></pre></td></tr></table></figure>
</li>
<li><p>启动该应用，访问<a href="http://localhost:2001/hystrix" target="_blank" rel="noopener">http://localhost:2001/hystrix</a> 。</p>
</li>
</ul>
<h3 id="Hystrix-Dashboard页面介绍"><a href="#Hystrix-Dashboard页面介绍" class="headerlink" title="Hystrix Dashboard页面介绍"></a>Hystrix Dashboard页面介绍</h3><ul>
<li><p>监控首页</p>
<p><img src="https://github.com/dicheng52119/dicheng52119.github.io/blob/master/images/spring-cloud/hystrix%E7%9B%91%E6%8E%A7%E9%A6%96%E9%A1%B5.png?raw=true" alt=""></p>
<ul>
<li>Hystrix Dashboard 共支持三种不同的监控方式：</li>
</ul>
<ol>
<li><p>默认的集群监控：通过URL <a href="http://turbine-host:port/turbine.stream" target="_blank" rel="noopener">http://turbine-host:port/turbine.stream</a> 开启，实现对默认集群的监控。</p>
</li>
<li><p>指定的集群监控：通过URL <a href="http://turbine-host:port/turbine.stream.stream?cluster=[clusterName]开启，实现对clusterName集群的监控。" target="_blank" rel="noopener">http://turbine-host:port/turbine.stream.stream?cluster=[clusterName]开启，实现对clusterName集群的监控。</a></p>
</li>
<li><p>单体应用的监控：通过URL <a href="http://hystrix-app:port/hystrix.stream" target="_blank" rel="noopener">http://hystrix-app:port/hystrix.stream</a> 开启，实现对具体某个服务实例的监控。  </p>
</li>
</ol>
<ul>
<li><p>Delay：该参数用来控制服务器上轮询监控信息的延迟时间，默认为2000ms，可以通过配置该属性来降低客户端的网络和CPU消耗。</p>
</li>
<li><p>Title：该参数对应了监控图头部标题Hystrix Stream之后的内容，默认会使用具体监控实例的URL，可以通过配置该信息来展示更合适的标题。</p>
</li>
</ul>
</li>
<li><p>监控页面</p>
<ul>
<li>可以在监控信息的左上部找到两个重要的图形信息：一个实心圆和一条曲线。</li>
</ul>
<ol>
<li><p>实心圆：通过颜色的变化代表了实例的健康程度，它的健康度从绿色、黄色、橙色、红色递减。它的大小会根据实例的请求流量发生变化，流量越大该实心圆就越大。通过该实心圆，可以在大量的实例中快速发现故障实例和高压力实例。</p>
</li>
<li><p>曲线：用来记录2分钟内流量的相对变化，可以通过它来观察流量的上升和下降趋势。</p>
</li>
</ol>
<ul>
<li><p>其他一些数量指标如下图所示：</p>
<p><img src="https://github.com/dicheng52119/dicheng52119.github.io/blob/master/images/spring-cloud/hystrix%E5%BA%A6%E9%87%8F%E6%8C%87%E6%A0%87%E8%AF%B4%E6%98%8E.png?raw=true" alt=""></p>
</li>
</ul>
</li>
</ul>
<h3 id="Turbine集群监控介绍"><a href="#Turbine集群监控介绍" class="headerlink" title="Turbine集群监控介绍"></a>Turbine集群监控介绍</h3><p>Hystrix Dashboard通过监控端点/turbine.stream对集群进行监控。通过引入Turbine，来汇集集群服务的监控信息，并将聚合后的信息供给Hystrix Dashboard来集中展示和监控。</p>
<h3 id="监控聚合服务架构图"><a href="#监控聚合服务架构图" class="headerlink" title="监控聚合服务架构图"></a>监控聚合服务架构图</h3><p><img src="https://github.com/dicheng52119/dicheng52119.github.io/blob/master/images/spring-cloud/turbine%E8%81%9A%E5%90%88%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E5%9B%BE.png?raw=true" alt=""></p>
<h3 id="turbine工程的快速构建"><a href="#turbine工程的快速构建" class="headerlink" title="turbine工程的快速构建"></a>turbine工程的快速构建</h3><ul>
<li>创建一个标准的Spring Boot工程，命名为turbine。</li>
<li><p>编辑pom.xml</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line">	&lt;dependency&gt;</span><br><span class="line">		&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">		&lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt;</span><br><span class="line">	&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">	&lt;dependency&gt;</span><br><span class="line">		&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">		&lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;</span><br><span class="line">		&lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">	&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">	&lt;dependency&gt;</span><br><span class="line">		&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">		&lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;</span><br><span class="line">	&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">	&lt;dependency&gt;</span><br><span class="line">		&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">		&lt;artifactId&gt;spring-cloud-starter-turbine&lt;/artifactId&gt;</span><br><span class="line">	&lt;/dependency&gt;</span><br><span class="line">&lt;/dependencies&gt;</span><br></pre></td></tr></table></figure>
<p>  <dependencymanagement></dependencymanagement></p>
<pre><code>&lt;!--
    旧版本的
    &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;
    &lt;version&gt;1.3.5.RELEASE&lt;/version&gt;
    对应旧版本的
    &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt;
    &lt;version&gt;Brixton.RELEASE&lt;/version&gt;

    新版本的
    &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;
    &lt;version&gt;1.5.3.RELEASE&lt;/version&gt;
    对应新版本的
    &lt;spring-cloud.version&gt;Dalston.SR1&lt;/spring-cloud.version&gt;

    otherwise ， 报错。。。
--&gt;
&lt;dependencies&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
        &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt;
        &lt;version&gt;Dalston.SR1&lt;/version&gt;
        &lt;type&gt;pom&lt;/type&gt;
        &lt;scope&gt;import&lt;/scope&gt;
    &lt;/dependency&gt;
&lt;/dependencies&gt;
</code></pre><p>  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">	</span><br><span class="line">* 应用主类使用@EnableTurbine注解开启Turbine</span><br><span class="line">  ``` java</span><br><span class="line">  @EnableTurbine</span><br><span class="line">  @EnableDiscoveryClient</span><br><span class="line">  @SpringBootApplication</span><br><span class="line">  public class TurbineApplication &#123;</span><br><span class="line"></span><br><span class="line">		public static void main(String[] args) &#123;</span><br><span class="line">			SpringApplication.run(TurbineApplication.class, args);</span><br><span class="line">		&#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在application.properties中加入Eureka和Turbine的相关配置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">spring.application.name=turbine</span><br><span class="line"></span><br><span class="line">server.port=8989</span><br><span class="line">management.port=8990</span><br><span class="line"></span><br><span class="line">eureka.client.serviceUrl.defaultZone=http://peer1:1111/eureka/</span><br><span class="line"></span><br><span class="line"># 指定了需要收集监控信息的服务名</span><br><span class="line">turbine.app-config=RIBBON-CONSUMER</span><br><span class="line"></span><br><span class="line"># 指定了集群名称，当服务非常多的时候，启动多个Turbine服务来构建不同的聚合集群，而该参数可以用来区分这些不同的聚合集群，</span><br><span class="line"># 只需在Hystrix Stream的url中通过cluster参数来指定 </span><br><span class="line">turbine.cluster-name-expression=&quot;default&quot;</span><br><span class="line"></span><br><span class="line"># 可以让同一主机上的服务通过主机名和端口号的组合来进行区分</span><br><span class="line">turbine.combine-host-port=true</span><br></pre></td></tr></table></figure>
</li>
<li><p>体验一下Turbine对集群的监控能力。分别启动eureka-server、HELLO-SERVICE、RIBBON-CONSUMER、Turbine以及Hystrix Dashboard。访问Hystrix Dashboard，并开启对<a href="http://localhost:8989/turbine.stream" target="_blank" rel="noopener">http://localhost:8989/turbine.stream</a> 的监控。</p>
</li>
</ul>
<h3 id="与消息代理结合简介"><a href="#与消息代理结合简介" class="headerlink" title="与消息代理结合简介"></a>与消息代理结合简介</h3><p>Spring Cloud在封装Turbine的时候，还封装了基于消息代理的收集实现。所以，我们可以将所有需要收集的监控信息都输出到消息代理中，然后Turbine服务再从消息代理中异步获取这些监控信息，最后将这些监控信息聚合并输出到Hystrix Dashboard中。</p>
<h3 id="Turbine与消息代理整合架构图"><a href="#Turbine与消息代理整合架构图" class="headerlink" title="Turbine与消息代理整合架构图"></a>Turbine与消息代理整合架构图</h3><p><img src="https://github.com/dicheng52119/dicheng52119.github.io/blob/master/images/spring-cloud/Turbine%E4%B8%8E%E6%B6%88%E6%81%AF%E4%BB%A3%E7%90%86%E7%BB%93%E5%90%88%E6%9E%B6%E6%9E%84%E5%9B%BE.png?raw=true" alt=""></p>
<h3 id="创建基于消息代理的Turbine聚合服务"><a href="#创建基于消息代理的Turbine聚合服务" class="headerlink" title="创建基于消息代理的Turbine聚合服务"></a>创建基于消息代理的Turbine聚合服务</h3><ul>
<li>创建一个标准的Spring Boot工程，命名为turbine-amqp。</li>
<li><p>编辑pom.xml</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line">	&lt;dependency&gt;</span><br><span class="line">		&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">		&lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt;</span><br><span class="line">	&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">	&lt;dependency&gt;</span><br><span class="line">		&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">		&lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;</span><br><span class="line">		&lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">	&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">	&lt;dependency&gt;</span><br><span class="line">		&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">		&lt;artifactId&gt;spring-cloud-starter-turbine-amqp&lt;/artifactId&gt;</span><br><span class="line">	&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">	&lt;dependency&gt;</span><br><span class="line">		&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">		&lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;</span><br><span class="line">	&lt;/dependency&gt;</span><br><span class="line">&lt;/dependencies&gt;</span><br></pre></td></tr></table></figure>
<p>  <dependencymanagement></dependencymanagement></p>
<pre><code>&lt;!--
    旧版本的
    &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;
    &lt;version&gt;1.3.5.RELEASE&lt;/version&gt;
    对应旧版本的
    &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt;
    &lt;version&gt;Brixton.RELEASE&lt;/version&gt;

    新版本的
    &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;
    &lt;version&gt;1.5.3.RELEASE&lt;/version&gt;
    对应新版本的
    &lt;spring-cloud.version&gt;Dalston.SR1&lt;/spring-cloud.version&gt;

    otherwise ， 报错。。。
--&gt;
&lt;dependencies&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
        &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt;
        &lt;version&gt;Dalston.SR1&lt;/version&gt;
        &lt;type&gt;pom&lt;/type&gt;
        &lt;scope&gt;import&lt;/scope&gt;
    &lt;/dependency&gt;
&lt;/dependencies&gt;
</code></pre><p>  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">* 在应用主类中使用@EnableTurbineStream注解来启用Turbine Stream的配置。</span><br><span class="line">  ``` java</span><br><span class="line">  @EnableTurbineStream</span><br><span class="line">  @EnableDiscoveryClient</span><br><span class="line">  @SpringBootApplication</span><br><span class="line">  public class TurbineAmqpApplication &#123;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		SpringApplication.run(TurbineAmqpApplication.class, args);</span><br><span class="line">	&#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>配置application.properties文件。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">spring.application.name=turbine</span><br><span class="line"></span><br><span class="line">server.port=8989</span><br><span class="line">management.port=8990</span><br><span class="line"></span><br><span class="line">eureka.client.serviceUrl.defaultZone=http://peer1:1111/eureka/</span><br></pre></td></tr></table></figure>
</li>
<li><p>对服务消费者RIBBON-CONSUMER做一些修改，使其监控信息能够输出到RabbitMQ上。修改其pom文件，添加依赖。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">	&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">	&lt;artifactId&gt;spring-cloud-netflix-hystrix-amqp&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>完成配置之后，继续启动eureka-server、HELLO-SERVICE、RIBBON-CONSUMER、Turbine以及Hystrix Dashboard，同时确保RabbitMQ已在正常运行，访问Hystrix Dashboard，并开启对<a href="http://localhost:8989/turbine.stream" target="_blank" rel="noopener">http://localhost:8989/turbine.stream</a> 的监控，效果和之前一样，只是这里的监控信息收集是通过消息代理异步实现的。</p>
</li>
</ul>
<p><br></p>
<h3 id="nbsp-nbsp-nbsp-版权声明：本文为博主原创文章，转载请标明作者和原链接"><a href="#nbsp-nbsp-nbsp-版权声明：本文为博主原创文章，转载请标明作者和原链接" class="headerlink" title="| &nbsp;&nbsp;&nbsp;版权声明：本文为博主原创文章，转载请标明作者和原链接"></a><font color="red"><b>| &nbsp;&nbsp;&nbsp;版权声明：本文为博主原创文章，转载请标明作者和原链接<br></b></font></h3>]]></content>
      
        <categories>
            
            <category> Spring Cloud </category>
            
        </categories>
        
        
        <tags>
            
            <tag> technology </tag>
            
            <tag> springboot </tag>
            
            <tag> spring cloud </tag>
            
            <tag> hystrix </tag>
            
            <tag> turbine </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Markdown的常用语法(个人总结)]]></title>
      <url>/2017/12/19/Markdown%E7%9A%84%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95/</url>
      <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Markdown 是一种轻量级标记语言，它用简洁的语法代替排版，使我们专心于码字。它的目标是实现易读易写，成为一种适用于网络的书写语言。同时，Markdown支持嵌入html标签。</p>
<p>注意：</p>
<ul>
<li>Markdown使用#、+、*等符号来标记， 符号后面必须跟上 至少1个 空格才有效！</li>
<li>markdown中如果遇到有字符与markdown语法冲突,可以使用 反引号包裹  <code>需要转移的内容</code> </li>
<li>markdown中如何让# * &gt;等符号原样显示，不被解析成对应的markdown语法，前加\转义</li>
</ul>
<p><br></p>
<h2 id="Markdown的常用语法"><a href="#Markdown的常用语法" class="headerlink" title="Markdown的常用语法"></a>Markdown的常用语法</h2><h3 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h3><p>Markdown 标题支持两种形式：</p>
<h4 id="1-用-标记"><a href="#1-用-标记" class="headerlink" title="1. 用#标记"></a>1. 用#标记</h4><p>在 <strong>标题开头</strong> 加上1~6个#，依次代表一级标题、二级标题….六级标题</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 一级标题 </span><br><span class="line">## 二级标题</span><br><span class="line">### 三级标题</span><br><span class="line">##### 四级标题</span><br><span class="line">###### 五级标题</span><br><span class="line">###### 六级标题</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h4 id="2-用-和-标记"><a href="#2-用-和-标记" class="headerlink" title="2. 用=和-标记"></a>2. 用=和-标记</h4><p>在 <strong>标题底下</strong> 加上任意个=代表一级标题，-代表二级标题</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">一级标题</span><br><span class="line">======</span><br><span class="line"></span><br><span class="line">二级标题</span><br><span class="line">----------</span><br></pre></td></tr></table></figure>
<p>效果如下：</p>
<h1 id="一级标题"><a href="#一级标题" class="headerlink" title="一级标题"></a>一级标题</h1><h2 id="二级标题"><a href="#二级标题" class="headerlink" title="二级标题"></a>二级标题</h2><h3 id="三级标题"><a href="#三级标题" class="headerlink" title="三级标题"></a>三级标题</h3><h5 id="四级标题"><a href="#四级标题" class="headerlink" title="四级标题"></a>四级标题</h5><h6 id="五级标题"><a href="#五级标题" class="headerlink" title="五级标题"></a>五级标题</h6><h6 id="六级标题"><a href="#六级标题" class="headerlink" title="六级标题"></a>六级标题</h6><hr>
<h3 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h3><p>Markdown 支持有序列表和无序列表。</p>
<p><strong>无序列表使用-、+和<code>*</code>作为列表标记：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- Red</span><br><span class="line">- Green</span><br><span class="line">- Blue</span><br><span class="line"></span><br><span class="line">* Red</span><br><span class="line">* Green</span><br><span class="line">* Blue</span><br><span class="line"></span><br><span class="line">+ Red</span><br><span class="line">+ Green</span><br><span class="line">+ Blue</span><br></pre></td></tr></table></figure>
<p>效果如下：</p>
<ul>
<li>Red</li>
<li>Green</li>
<li>Blue</li>
</ul>
<ul>
<li>Red</li>
<li>Green</li>
<li>Blue</li>
</ul>
<ul>
<li>Red</li>
<li>Green</li>
<li>Blue</li>
</ul>
<p><strong>有序列表则使用数字加英文句点.来表示(注意空格)：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. Red</span><br><span class="line">2. Green</span><br><span class="line">3. Blue</span><br></pre></td></tr></table></figure>
<p>效果如下：</p>
<ol>
<li>Red</li>
<li>Green</li>
<li>Blue</li>
</ol>
<hr>
<h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><p>引用以&gt;来表示，引用中支持多级引用、标题、列表、代码块、分割线等常规语法。</p>
<p>常见的引用写法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; 这是一段引用    //在`&gt;`后面有 1 个空格</span><br><span class="line">&gt; </span><br><span class="line">&gt;     这是引用的代码块形式    //在`&gt;`后面有5个空格</span><br><span class="line">&gt;     </span><br><span class="line">&gt; 代码例子：</span><br><span class="line">&gt;   </span><br><span class="line">    protected void onCreate(Bundle savedInstanceState) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&gt; 一级引用</span><br><span class="line">&gt; &gt; 二级引用</span><br><span class="line">&gt; &gt; &gt; 三级引用</span><br><span class="line"></span><br><span class="line">&gt; #### 这是一个四级标题</span><br><span class="line">&gt; </span><br><span class="line">&gt; 1. 这是第一行列表项</span><br><span class="line">&gt; 2. 这是第二行列表项</span><br></pre></td></tr></table></figure>
<p>效果如下：</p>
<blockquote>
<p>这是一段引用</p>
<pre><code>这是引用的代码块形式
</code></pre><p>代码例子：</p>
<pre><code>protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    setContentView(R.layout.activity_main);
}
</code></pre><p>一级引用</p>
<blockquote>
<p>二级引用</p>
<blockquote>
<p>三级引用</p>
</blockquote>
</blockquote>
<h4 id="这是一个四级标题"><a href="#这是一个四级标题" class="headerlink" title="这是一个四级标题"></a>这是一个四级标题</h4><ol>
<li>这是第一行列表项</li>
<li>这是第二行列表项</li>
</ol>
</blockquote>
<hr>
<h3 id="强调"><a href="#强调" class="headerlink" title="强调"></a>强调</h3><p>两个<code>*</code>或<code>_</code>代表加粗，一个<code>*</code>或<code>_</code>代表斜体，<code>~~</code>代表删除。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">**加粗文本** 或者 __加粗文本__</span><br><span class="line"></span><br><span class="line">*斜体文本*  或者_斜体文本_</span><br><span class="line"></span><br><span class="line">~~删除文本~~</span><br></pre></td></tr></table></figure>
<p>效果如下：</p>
<p><strong>加粗文本</strong> 或者 <strong>加粗文本</strong></p>
<p><em>斜体文本</em> 或者 <em>斜体文本</em></p>
<p><del>删除文本</del></p>
<hr>
<h3 id="图片与链接"><a href="#图片与链接" class="headerlink" title="图片与链接"></a>图片与链接</h3><p>图片与链接的语法很像，区别在一个 ! 号。二者格式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">图片：![]()    ![图片文本(可忽略)](图片地址)</span><br><span class="line"></span><br><span class="line">链接：[]()     [链接文本](链接地址)</span><br></pre></td></tr></table></figure>
<p>链接又分为行内式、参考式和自动链接：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">这是行内式链接：[CrazyIT&apos;s Blog](http://dicheng52119.github.io)。</span><br><span class="line"></span><br><span class="line">这是参考式链接：[CrazyIT&apos;s Blog][url]，其中url为链接标记，可置于文中任意位置。</span><br><span class="line"></span><br><span class="line">[url]: http://dicheng52119.github.io/ &quot;CrazyIT&apos;s Blog&quot;</span><br><span class="line"></span><br><span class="line">链接标记格式为：[链接标记文本]:  链接地址  链接title(可忽略)</span><br><span class="line"></span><br><span class="line">这是自动链接：直接使用`&lt;&gt;`括起来&lt;http://dicheng52119.github.io&gt;</span><br><span class="line"></span><br><span class="line">这是图片：![][avatar]</span><br><span class="line"></span><br><span class="line">[avatar]: https://github.com/dicheng52119/dicheng52119.github.io/blob/master/assets/tree_small.png?raw=true</span><br></pre></td></tr></table></figure>
<p>效果如下：</p>
<p>这是行内式链接：<a href="https://dicheng52119.github.io" target="_blank" rel="noopener">CrazyIT’s Blog</a>。</p>
<p>这是参考式链接：<a href="https://dicheng52119.github.io/" title="CrazyIT&#39;s Blog" target="_blank" rel="noopener">CrazyIT’s Blog</a>，其中url为链接标记，可置于文中任意位置。</p>
<p>链接标记格式为：[链接标记文本]:  链接地址  链接title(可忽略)</p>
<p>这是自动链接：直接使用<code>&lt;&gt;</code>括起来<a href="https://dicheng52119.github.io" target="_blank" rel="noopener">https://dicheng52119.github.io</a></p>
<p>这是图片：<img src="https://github.com/dicheng52119/dicheng52119.github.io/blob/master/assets/tree_small.png?raw=true" alt=""></p>
<hr>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>代码分为行内代码和代码块。</p>
<ul>
<li><p>行内代码使用 `` 标识，可嵌入文字中</p>
</li>
<li><p>代码块使用4个空格或<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">\</span><br></pre></td></tr></table></figure></p>
<p>这里是代码</p>
<p>\<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">* 代码语法高亮在 ```后面加上空格和语言名称即可</span><br><span class="line"></span><br><span class="line">  \``` 语言</span><br><span class="line"></span><br><span class="line">  ``//注意语言前面有空格``</span><br><span class="line">  </span><br><span class="line">  这里是代码</span><br><span class="line"></span><br><span class="line">  \</span><br></pre></td></tr></table></figure></p>
</li>
</ul>
<p>例如：</p>
<blockquote>
<p>这是行内代码<code>onCreate(Bundle savedInstanceState)</code>的例子。</p>
<p>这是代码块和语法高亮：</p>
<p>\<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&gt;</span><br><span class="line">&gt;<span class="comment">// 注意java前面有空格</span></span><br><span class="line">&gt;</span><br><span class="line">&gt;  </span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">    &#125;</span><br><span class="line">&gt;</span><br><span class="line">&gt;\</span><br></pre></td></tr></table></figure></p>
</blockquote>
<p>效果如下：</p>
<p>这是行内代码onCreate(Bundle savedInstanceState)的例子。</p>
<p>这是代码块和语法高亮：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 注意java前面有空格</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">    setContentView(R.layout.activity_main);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h3><p>表格对齐格式</p>
<ul>
<li>居左： <code>:----</code></li>
<li>居中：<code>:----: 或 -----</code></li>
<li>居右：<code>----:</code></li>
</ul>
<p>例子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">|标题|标题|标题|</span><br><span class="line">|:---|:---:|---:|</span><br><span class="line">|居左测试文本|居中测试文本|居右测试文本|</span><br><span class="line">|居左测试文本1|居中测试文本2|居右测试文本3|</span><br><span class="line">|居左测试文本11|居中测试文本22|居右测试文本33|</span><br><span class="line">|居左测试文本111|居中测试文本222|居右测试文本333|</span><br></pre></td></tr></table></figure>
<p>效果如下：</p>
<table>
<thead>
<tr>
<th style="text-align:left">标题</th>
<th style="text-align:center">标题</th>
<th style="text-align:right">标题</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">居左测试文本</td>
<td style="text-align:center">居中测试文本</td>
<td style="text-align:right">居右测试文本</td>
</tr>
<tr>
<td style="text-align:left">居左测试文本1</td>
<td style="text-align:center">居中测试文本2</td>
<td style="text-align:right">居右测试文本3</td>
</tr>
<tr>
<td style="text-align:left">居左测试文本11</td>
<td style="text-align:center">居中测试文本22</td>
<td style="text-align:right">居右测试文本33</td>
</tr>
<tr>
<td style="text-align:left">居左测试文本111</td>
<td style="text-align:center">居中测试文本222</td>
<td style="text-align:right">居右测试文本333</td>
</tr>
</tbody>
</table>
<hr>
<h3 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h3><p>在一行中用三个以上的*、-、_来建立一个分隔线，行内不能有其他东西。也可以在符号间插入空格。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">***</span><br><span class="line">---</span><br><span class="line">___</span><br><span class="line">* * *</span><br></pre></td></tr></table></figure>
<p>效果均为一条分割线：</p>
<hr>
<h3 id="换行"><a href="#换行" class="headerlink" title="换行"></a>换行</h3><p>在行尾添加两个空格加回车表示换行：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">这是一行后面加两个空格  换行</span><br></pre></td></tr></table></figure>
<p>效果如下：</p>
<p>这是一行后面加两个空格<br>换行</p>
<hr>
<h3 id="脚注-注解"><a href="#脚注-注解" class="headerlink" title="脚注(注解)"></a>脚注(注解)</h3><p>使用[^]来定义脚注：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">这是一个脚注的例子[^1]</span><br><span class="line"></span><br><span class="line">[^1]: 这里是脚注</span><br></pre></td></tr></table></figure>
<p>效果如下：</p>
<p>这是一个脚注的例子<a href="这里是脚注">^1</a></p>
<hr>
<p><br></p>
<h2 id="常用弥补Markdown的Html标签"><a href="#常用弥补Markdown的Html标签" class="headerlink" title="常用弥补Markdown的Html标签"></a>常用弥补Markdown的Html标签</h2><h3 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;font face=&quot;微软雅黑&quot; color=&quot;red&quot; size=&quot;6&quot;&gt;字体及字体颜色和大小&lt;/font&gt;</span><br><span class="line">&lt;font color=&quot;#0000ff&quot;&gt;字体颜色&lt;/font&gt;</span><br></pre></td></tr></table></figure>
<p>效果如下：</p>
<font face="微软雅黑" color="red" size="6">字体及字体颜色和大小</font><br><font color="#0000ff">字体颜色</font>

<hr>
<h3 id="换行-1"><a href="#换行-1" class="headerlink" title="换行"></a>换行</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">使用html标签`&lt;br/&gt;`&lt;br/&gt;换行</span><br></pre></td></tr></table></figure>
<p>效果如下：</p>
<p>使用html标签<br><br>换行</p>
<hr>
<h3 id="文本对齐方式"><a href="#文本对齐方式" class="headerlink" title="文本对齐方式"></a>文本对齐方式</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;p align=&quot;left&quot;&gt;居左文本&lt;/p&gt;</span><br><span class="line">&lt;p align=&quot;center&quot;&gt;居中文本&lt;/p&gt;</span><br><span class="line">&lt;p align=&quot;right&quot;&gt;居右文本&lt;/p&gt;</span><br></pre></td></tr></table></figure>
<p>效果如下：</p>
<p align="left">居左文本</p><br><p align="center">居中文本</p><br><p align="right">居右文本</p>

<hr>
<p>下划线</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;u&gt;下划线文本&lt;/u&gt;</span><br></pre></td></tr></table></figure>
<p>效果如下：</p>
<p><u>下划线文本</u></p>
<p><strong>That’s all, Enjoy it!</strong></p>
<p><strong>备注：文末有些html标签在有道云上不支持</strong></p>
]]></content>
      
        <categories>
            
            <category> Markdown </category>
            
        </categories>
        
        
        <tags>
            
            <tag> technology </tag>
            
            <tag> markdown </tag>
            
            <tag> html </tag>
            
            <tag> command </tag>
            
            <tag> grammer </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Hexo配置文件详细说明]]></title>
      <url>/2017/12/18/Hexo%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E7%BB%86%E8%AF%B4%E6%98%8E/</url>
      <content type="html"><![CDATA[<h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><p>您可以在 _config.yml 中修改大部份的配置。</p>
<h3 id="网站"><a href="#网站" class="headerlink" title="网站"></a>网站</h3><table>
<thead>
<tr>
<th style="text-align:left">参数</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">title</td>
<td style="text-align:left">网站标题</td>
</tr>
<tr>
<td style="text-align:left">subtitle</td>
<td style="text-align:left">网站副标题</td>
</tr>
<tr>
<td style="text-align:left">description</td>
<td style="text-align:left">网站描述</td>
</tr>
<tr>
<td style="text-align:left">author</td>
<td style="text-align:left">您的名字</td>
</tr>
<tr>
<td style="text-align:left">language</td>
<td style="text-align:left">网站使用的语言</td>
</tr>
<tr>
<td style="text-align:left">timezone</td>
<td style="text-align:left">网站时区。Hexo 默认使用您电脑的时区。时区列表。比如说：America/New_York, Japan, 和 UTC 。</td>
</tr>
</tbody>
</table>
<p>其中，description主要用于SEO，告诉搜索引擎一个关于您站点的简单描述，通常建议在其中包含您网站的关键词。author参数用于主题显示文章的作者。</p>
<h3 id="网址"><a href="#网址" class="headerlink" title="网址"></a>网址</h3><table>
<thead>
<tr>
<th style="text-align:left">参数</th>
<th style="text-align:left">描述</th>
<th style="text-align:left">默认值</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">url</td>
<td style="text-align:left">网址</td>
</tr>
<tr>
<td style="text-align:left">root</td>
<td style="text-align:left">网站根目录</td>
</tr>
<tr>
<td style="text-align:left">permalink</td>
<td style="text-align:left">文章的永久链接格式</td>
<td style="text-align:left">:year/:month/:day/:title/</td>
</tr>
<tr>
<td style="text-align:left">permalink_defaults</td>
<td style="text-align:left">永久链接中各部分的默认值</td>
</tr>
</tbody>
</table>
<a id="more"></a>
<h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><table>
<thead>
<tr>
<th style="text-align:left">参数</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">source_dir</td>
<td style="text-align:left">资源文件夹，这个文件夹用来存放内容。</td>
</tr>
<tr>
<td style="text-align:left">public_dir</td>
<td style="text-align:left">公共文件夹，这个文件夹用于存放生成的站点文件。</td>
</tr>
<tr>
<td style="text-align:left">tag_dir</td>
<td style="text-align:left">标签文件夹</td>
</tr>
<tr>
<td style="text-align:left">archive_dir</td>
<td style="text-align:left">归档文件夹</td>
</tr>
<tr>
<td style="text-align:left">category_dir</td>
<td style="text-align:left">分类文件夹</td>
</tr>
<tr>
<td style="text-align:left">code_dir</td>
<td style="text-align:left">Include code 文件夹</td>
</tr>
<tr>
<td style="text-align:left">i18n_dir</td>
<td style="text-align:left">国际化（i18n）文件夹</td>
</tr>
<tr>
<td style="text-align:left">skip_render</td>
<td style="text-align:left">跳过指定文件的渲染，您可使用 glob 表达式来匹配路径。</td>
</tr>
</tbody>
</table>
<h3 id="文章"><a href="#文章" class="headerlink" title="文章"></a>文章</h3><table>
<thead>
<tr>
<th style="text-align:left">参数</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">new_post_name</td>
<td style="text-align:left">新文章的文件名称</td>
</tr>
<tr>
<td style="text-align:left">default_layout</td>
<td style="text-align:left">预设布局</td>
</tr>
<tr>
<td style="text-align:left">auto_spacing</td>
<td style="text-align:left">在中文和英文之间加入空格</td>
</tr>
<tr>
<td style="text-align:left">titlecase</td>
<td style="text-align:left">把标题转换为 title case</td>
</tr>
<tr>
<td style="text-align:left">external_link</td>
<td style="text-align:left">在新标签中打开链接</td>
</tr>
<tr>
<td style="text-align:left">filename_case</td>
<td style="text-align:left">把文件名称转换为 (1) 小写或 (2) 大写</td>
</tr>
<tr>
<td style="text-align:left">render_drafts</td>
<td style="text-align:left">显示草稿</td>
</tr>
<tr>
<td style="text-align:left">post_asset_folder</td>
<td style="text-align:left">启动 Asset 文件夹</td>
</tr>
<tr>
<td style="text-align:left">relative_link</td>
<td style="text-align:left">把链接改为与根目录的相对位址</td>
</tr>
<tr>
<td style="text-align:left">future</td>
<td style="text-align:left">显示未来的文章</td>
</tr>
<tr>
<td style="text-align:left">highlight</td>
<td style="text-align:left">代码块的设置</td>
</tr>
</tbody>
</table>
<h3 id="分类-amp-标签"><a href="#分类-amp-标签" class="headerlink" title="分类&amp;标签"></a>分类&amp;标签</h3><table>
<thead>
<tr>
<th style="text-align:left">参数</th>
<th style="text-align:left">描述</th>
<th style="text-align:left">默认值</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">default_category</td>
<td style="text-align:left">默认分类</td>
<td style="text-align:left">uncategorized</td>
</tr>
<tr>
<td style="text-align:left">category_map</td>
<td style="text-align:left">分类别名</td>
</tr>
<tr>
<td style="text-align:left">tag_map</td>
<td style="text-align:left">标签别名</td>
</tr>
</tbody>
</table>
<h3 id="时间-日期格式"><a href="#时间-日期格式" class="headerlink" title="时间/日期格式"></a>时间/日期格式</h3><table>
<thead>
<tr>
<th style="text-align:left">参数</th>
<th style="text-align:left">描述</th>
<th style="text-align:left">默认值</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">date_format</td>
<td style="text-align:left">日期格式</td>
<td style="text-align:left">YYYY-MM-DD</td>
</tr>
<tr>
<td style="text-align:left">time_format</td>
<td style="text-align:left">时间格式</td>
<td style="text-align:left">H:mm:ss</td>
</tr>
</tbody>
</table>
<h3 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h3><table>
<thead>
<tr>
<th style="text-align:left">参数</th>
<th style="text-align:left">描述</th>
<th style="text-align:left">默认值</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">per_page</td>
<td style="text-align:left">每页显示的文章量 (0 = 关闭分页功能)</td>
<td style="text-align:left">10</td>
</tr>
<tr>
<td style="text-align:left">pagination_dir</td>
<td style="text-align:left">分页目录</td>
<td style="text-align:left">page</td>
</tr>
</tbody>
</table>
<h3 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h3><table>
<thead>
<tr>
<th style="text-align:left">参数</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">theme</td>
<td style="text-align:left">当前主题名称。值为false时禁用主题</td>
</tr>
<tr>
<td style="text-align:left">deploy</td>
<td style="text-align:left">部署部分的设置</td>
</tr>
</tbody>
</table>
]]></content>
      
        <categories>
            
            <category> Hexo </category>
            
        </categories>
        
        
        <tags>
            
            <tag> technology </tag>
            
            <tag> hexo </tag>
            
            <tag> blog </tag>
            
            <tag> config </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Hexo Blog搭建步骤详解]]></title>
      <url>/2017/12/18/Hexo-Blog%E6%90%AD%E5%BB%BA%E6%AD%A5%E9%AA%A4%E8%AF%A6%E8%A7%A3/</url>
      <content type="html"><![CDATA[<h3 id="搭建步骤"><a href="#搭建步骤" class="headerlink" title="搭建步骤:"></a>搭建步骤:</h3><ul>
<li><p>申请github账号,步骤此处省略一万字</p>
</li>
<li><p>新建仓库，仓库名称定义格式:访问主页时的用户名.github.io</p>
</li>
<li><p>仓库添加README.md文件，修改为index.html,添加内容”hello world”</p>
</li>
<li><p>访问步骤二定义的地址，即<a href="https://用户名.github.io,如果出现步骤三中的效果，则说明第一部分的设置已经成功完成" target="_blank" rel="noopener">https://用户名.github.io,如果出现步骤三中的效果，则说明第一部分的设置已经成功完成</a></p>
</li>
<li><p>访问hexo官网，可按照步骤进行创建本地hexo项目，也可继续按照本篇文档继续完成设置</p>
</li>
<li><p>安装nvm和npm,步骤此处省略一万字，安装完成后，可通过命令行指令nvm -v 和npm -v查看是否安装成功</p>
</li>
<li><p>命令行运行npm install hexo-cli -g，运行命令hexo -v查看安装是否成功</p>
</li>
<li><p>选择一个目录位置，运行hexo init blog 命令，创建hexo项目文件，cd blog进入项目</p>
</li>
<li><p>使用文本编辑器，这里推荐使用vscode,打开blog项目，修改根目录下的config配置文件，将title和author自定义进行修改，将文件最下方的发布信息type的值修改为git,添加属性repo，并赋值为第二步你所定义的仓库地址</p>
</li>
<li><p>命令行运行npm install hexo-deployer-git —save 命令</p>
</li>
<li><p>运行hexo &amp;&amp; hexo g &amp;&amp; hexo s在本地运行，查看博客的部署情况</p>
</li>
<li><p>运行hexo clean &amp;&amp; hexo g &amp;&amp; hexo d,分别代表着hexo clean，hexo generate，hexo deploy，hexo server，部署到github 上进行运行，访问第二步你所定义的仓库名称，查看效果</p>
</li>
<li><p>hexo官网已开源大量主题，可根据需要进行使用，进入相关主题的github项目中，复制仓库地址，进入本地blog项目的theme文件夹中，clone 复制的仓库地址，然后在根配置文件中修改theme的值，为clone下来的主题文件夹名称，至于不同主题下的详细配置，这里不再做一一介绍，详见每个主题的配置说明。配置完成后，同样使用步骤12的命令查看效果</p>
</li>
<li><p>运行hexo new “文章名称”命令进行创建新的文章</p>
</li>
<li><p>如果不想博文在首页全部显示, 并能出现阅读全文按钮效果, 需要在你想在首页显示的部分下添加 <code>&lt;!--more--&gt;</code></p>
</li>
</ul>
<a id="more"></a>
<p><br></p>
<h3 id="说明"><a href="#说明" class="headerlink" title="说明:"></a>说明:</h3><ul>
<li><p>使用步骤12命令时，需要注意，如果github上配置了本机生成的ssh key ，则需要在步骤9中，配置你仓库的ssh地址。反之，需要配置仓库的http地址，此时需要你每次发布的时候，输入github的用户名和密码，使用命令git config –global credential.helper store ，即可实现一次输入，以后免输的功能</p>
</li>
<li><p>如果npm install 模块，失败的话，可以尝试使用命令npm cache clean -f命令，先清除安装缓存，然后npm install，最后再次尝试安装命令</p>
</li>
</ul>
<p><br></p>
<h3 id="nbsp-nbsp-nbsp-版权声明：本文为博主原创文章，转载请标明作者和原链接"><a href="#nbsp-nbsp-nbsp-版权声明：本文为博主原创文章，转载请标明作者和原链接" class="headerlink" title="| &nbsp;&nbsp;&nbsp;版权声明：本文为博主原创文章，转载请标明作者和原链接"></a><font color="red"><b>| &nbsp;&nbsp;&nbsp;版权声明：本文为博主原创文章，转载请标明作者和原链接<br></b></font></h3>]]></content>
      
        <categories>
            
            <category> Hexo </category>
            
        </categories>
        
        
        <tags>
            
            <tag> technology </tag>
            
            <tag> hexo </tag>
            
            <tag> blog </tag>
            
            <tag> node </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Git常用命令总结(自己总结 超实用)]]></title>
      <url>/2017/12/18/Git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93/</url>
      <content type="html"><![CDATA[<h3 id="将本地代码关联到远程git仓库步骤："><a href="#将本地代码关联到远程git仓库步骤：" class="headerlink" title="将本地代码关联到远程git仓库步骤："></a>将本地代码关联到远程git仓库步骤：</h3><ul>
<li><p>初始化一个仓库</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git init</span><br></pre></td></tr></table></figure>
</li>
<li><p>将github上项目与本地项目进行关联</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git remote add origin github仓库地址</span><br></pre></td></tr></table></figure>
</li>
<li><p>添加本地代码到暂存区</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git add .</span><br></pre></td></tr></table></figure>
</li>
<li><p>提交本地代码到本地</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git commit -m <span class="string">"提交信息"</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>拉取远程仓库代码</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git pull origin 分支名称（如果报错的话，就添加后缀--allow unrelated histories）</span><br></pre></td></tr></table></figure>
</li>
<li><p>提交本地代码到远程仓库</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git push -u origin 分支名称</span><br></pre></td></tr></table></figure>
</li>
</ul>
<a id="more"></a>
<p><br></p>
<h3 id="其他常用的命令总结"><a href="#其他常用的命令总结" class="headerlink" title="其他常用的命令总结"></a>其他常用的命令总结</h3><ul>
<li><p>查看本地代码的状态信息</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git status</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看本地代码当前的分支</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git branch</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看远程仓库的所有分支</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git branch -a</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建一个新的分支</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git checkout -b <span class="string">"分支名称"</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>切换分支</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git checkout <span class="string">"分支名称"</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>合并分支</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git merge origin <span class="string">"分支名称"</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>查看提交记录</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">log</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>回退到历史版本</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git reset --hard <span class="string">"某一版本号"</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>使用https方式提交本地代码，避免重复登录用户名与密码</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git config --global credential.helper store</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><br></p>
<h3 id="nbsp-nbsp-nbsp-版权声明：本文为博主原创文章，转载请标明作者和原链接"><a href="#nbsp-nbsp-nbsp-版权声明：本文为博主原创文章，转载请标明作者和原链接" class="headerlink" title="| &nbsp;&nbsp;&nbsp;版权声明：本文为博主原创文章，转载请标明作者和原链接"></a><font color="red"><b>| &nbsp;&nbsp;&nbsp;版权声明：本文为博主原创文章，转载请标明作者和原链接<br></b></font></h3>]]></content>
      
        <categories>
            
            <category> Git </category>
            
        </categories>
        
        
        <tags>
            
            <tag> technology </tag>
            
            <tag> git </tag>
            
            <tag> terminal command </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[地铁随笔]]></title>
      <url>/2017/12/16/%E5%9C%B0%E9%93%81%E9%9A%8F%E7%AC%94/</url>
      <content type="html"><![CDATA[<p>掐指一算，来北京已经有两年时光。恍惚间，头顶多了几根白发，少了一撮黑发。</p>
<p>这是一趟开往北京南站的列车，此行的任务是接待本人媳妇的闺蜜，可谓是任重而道远。</p>
<p>对于一个刚踏入社会，即将开启北漂生活的妹子来说，这简直可以说是一种天上掉馅饼被爽死的幸福。行李托运、温馨提示、行程导航、美食招待、住所安排、行李托管、安全护送…</p>
<p>一切的一切，让本人的眼光不再清澈，恍然间，回到过去的某个时刻。</p>
<p>遥想铖哥当年，回到了解放前的某一天，也就是两年前的那一天，本人携内人初来帝都，可谓是人生地不熟，行李放到一个不靠谱的托管处，然后凭借高德地图强大的导航能力，拖着坐酸了一夜的老腰，来到了帝都恢弘气势的天安门广场。</p>
<p>匆匆过客，来不及欣赏百年沉淀的文化，便已踏入寻房苦途，经过了一番折腾和斗智斗勇的完美体验后，与次日凌晨入驻几平的小房间，期间包括与房东一窝战斗的情形，与中介讨价还价的心跳，这里不必细谈，因为均以战败告终。一把伤心泪，从此，开启了梦幻的北漂之旅。</p>
<p>房间的憋屈，环境的脏乱，地铁的拥堵，人与人之间的嫌弃，人心的浮躁，工作的忙碌等等，使得生活在这个灯红酒绿城市的人们看似没有光鲜亮丽外表的美好，使得人生观一度发生改变和扭曲。</p>
<p>时间在流逝，世界在变化！这个世界难道就因此而变得不美好了吗？答案是你知道。</p>
<p>细数一下，短短两年时光，住所已更换了数次，在每一次的迭代更新中，都慢慢熟悉了这里面满满的套路，经济实惠舒适的房子已然出现（相对而言)。十九大的顺利召开，蓝天白云不再是普通人心目中的完美车标，奢饰品你也值得拥有！每日运载上千万乘客的庞大地铁系统，承载了太多太多人的辛勤和汗水，共同维护着这座城中城。童叟无欺，主动让出身边的座位时常发生。同事的帮助和关怀，让你感觉自己不是一个人在奋斗！皎洁月光下的深夜，是如此的宁静，宁静的可以听到工位上微微的心跳，向仍在此刻奋斗的同僚们致敬！你们是专业的，你们是敬业的，你们是爱业的！沉淀自己，你们会成功的！</p>
<a id="more"></a>
<p>生活在这个城市是痛苦的，但是无数人却迷恋这个曾让他们痛恨和责骂的城市，并为之疯狂。因为这个城市是有魔力的，吸引着他们不忍离去。他们始终坚信，通过自己的不懈努力，自己不再是在这座城市生存，而是生活！</p>
<p>有喜欢做并激发内心强大欲望的事，是美好的;有计划并付诸实践，点滴实现的过程，是美好的;有一群志同道合，兴趣相投的朋友相互追随，是美好的。如果所有美好的事情相互碰撞与摩擦，那必定会有美好的事情发生！</p>
<p>感慨万千，也抵不过寥寥数笔。其中的辛酸苦辣，唯镜中人冷暖自知。谨以此，献给奋斗在一线的朋友们，心中所想，所盼之事，有朝一日，必会实现！</p>
<p>所以说，这位妹子是幸福的，是幸运的…</p>
<p><br></p>
<h3 id="nbsp-nbsp-nbsp-版权声明：本文为博主原创文章，转载请标明作者和原链接"><a href="#nbsp-nbsp-nbsp-版权声明：本文为博主原创文章，转载请标明作者和原链接" class="headerlink" title="| &nbsp;&nbsp;&nbsp;版权声明：本文为博主原创文章，转载请标明作者和原链接"></a><font color="red"><b>| &nbsp;&nbsp;&nbsp;版权声明：本文为博主原创文章，转载请标明作者和原链接<br></b></font></h3>]]></content>
      
        <categories>
            
            <category> 情感 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 北京 </tag>
            
            <tag> 记忆 </tag>
            
            <tag> 青春 </tag>
            
            <tag> 奋斗 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Hello World]]></title>
      <url>/2017/12/12/hello-world/</url>
      <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>
<!--将languages目录下面的zh-Hans.yml修改为zh-CN.yml或者按照文档中的修改根目录配置文件也行。-->
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>
]]></content>
      
        
        <tags>
            
            <tag> 示例 </tag>
            
        </tags>
        
    </entry>
    
  
  
</search>
