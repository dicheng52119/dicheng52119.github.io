<!DOCTYPE html>
<html lang="zh-cmn-Hans">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>基于redis分布式锁实现“秒杀 | CrazyIT</title>
  
  
  <!--link rel="stylesheet" href="//cdn.jsdelivr.net/highlight.js/9.10.0/styles/github-gist.min.css"-->
  <link rel="stylesheet" href="//cdn.jsdelivr.net/highlight.js/9.10.0/styles/github-gist.min.css">
  <link rel="stylesheet" href="/css/style.css">
</head>

<body>
<div class="Shell">
    <aside class='SideBar'>
    <section class='avatar' style="background-image: url(/assets/header.png)">
        <div class='av-pic' style="background-image: url(/assets/tree_small.png)">
        </div>
    </section>
    <section class='menu'>
        <div>CrazyIT</div>
        
            <div>Toss more than life</div>
        
        <ul>
          
            <a href="/" class="Btn">
              <li>Home</li>
            </a>  
          
            <a href="/archives/" class="Btn">
              <li>Archive</li>
            </a>  
          
            <a href="/tags/" class="Btn">
              <li>Tags</li>
            </a>  
          
            <a href="/categories/" class="Btn">
              <li>Categories</li>
            </a>  
          
            <a href="/about/" class="Btn">
              <li>About</li>
            </a>  
          
        </ul>
    </section>
    <section class="media">
        
            
                <a href="https://github.com/dicheng52119">
                    <img src="/assets/github.svg" />
                </a>
            
        
            
                <a href="https://www.facebook.com/profile.php?id=100023446571362">
                    <img src="/assets/facebook.svg" />
                </a>
            
        
            
                <a href="https://www.zhihu.com/people/yixie-zhi-qiu-16-96-61/activities">
                    <img src="/assets/zhihu.svg" />
                </a>
            
        
            
                <a href="https://www.csdn.net/">
                    <img src="/assets/csdn.svg" />
                </a>
            
        
    </section>
</aside>

    <div class="container">
        <div data-pager-shell>
            <div>
  <article class='ContentView'>
    <header class='PageTitle'>
        <h1>基于redis分布式锁实现“秒杀</h1>
    </header>

    <section>
      <p>最近在项目中遇到了类似“秒杀”的业务场景，在本篇博客中，我将用一个非常简单的demo，阐述实现所谓“秒杀”的基本思路。</p>
<h3 id="业务场景"><a href="#业务场景" class="headerlink" title="业务场景"></a>业务场景</h3><p>所谓秒杀，从业务角度看，是短时间内多个用户“争抢”资源，这里的资源在大部分秒杀场景里是商品；将业务抽象，技术角度看，秒杀就是多个线程对资源进行操作，所以实现秒杀，就必须控制线程对资源的争抢，既要保证高效并发，也要保证操作的正确。</p>
<h3 id="一些可能的实现"><a href="#一些可能的实现" class="headerlink" title="一些可能的实现"></a>一些可能的实现</h3><p>刚才提到过，实现秒杀的关键点是控制线程对资源的争抢，根据基本的线程知识，可以不加思索的想到下面的一些方法： </p>
<ol>
<li>秒杀在技术层面的抽象应该就是一个方法，在这个方法里可能的操作是将商品库存-1，将商品加入用户的购物车等等，在不考虑缓存的情况下应该是要操作数据库的。那么最简单直接的实现就是在这个方法上加上synchronized关键字，通俗的讲就是锁住整个方法； </li>
<li>锁住整个方法这个策略简单方便，但是似乎有点粗暴。可以稍微优化一下，只锁住秒杀的代码块，比如写数据库的部分； </li>
<li>既然有并发问题，那我就让他“不并发”，将所有的线程用一个队列管理起来，使之变成串行操作，自然不会有并发问题。</li>
</ol>
<p>上面所述的方法都是有效的，但是都不好。为什么？第一和第二种方法本质上是“加锁”，但是锁粒度依然比较高。什么意思？试想一下，如果两个线程同时执行秒杀方法，这两个线程操作的是不同的商品,从业务上讲应该是可以同时进行的，但是如果采用第一二种方法，这两个线程也会去争抢同一个锁，这其实是不必要的。第三种方法也没有解决上面说的问题。</p>
<p>那么如何将锁控制在更细的粒度上呢？可以考虑为每个商品设置一个互斥锁，以和商品ID相关的字符串为唯一标识，这样就可以做到只有争抢同一件商品的线程互斥，不会导致所有的线程互斥。分布式锁恰好可以帮助我们解决这个问题。</p>
<a id="more"></a>
<h3 id="何为分布式锁"><a href="#何为分布式锁" class="headerlink" title="何为分布式锁"></a>何为分布式锁</h3><p>分布式锁是控制分布式系统之间同步访问共享资源的一种方式。在分布式系统中，常常需要协调他们的动作。如果不同的系统或是同一个系统的不同主机之间共享了一个或一组资源，那么访问这些资源的时候，往往需要互斥来防止彼此干扰来保证一致性，在这种情况下，便需要使用到分布式锁。</p>
<p>我们来假设一个最简单的秒杀场景：数据库里有一张表，column分别是商品ID，和商品ID对应的库存量，秒杀成功就将此商品库存量-1。现在假设有1000个线程来秒杀两件商品，500个线程秒杀第一个商品，500个线程秒杀第二个商品。我们来根据这个简单的业务场景来解释一下分布式锁。 </p>
<p>通常具有秒杀场景的业务系统都比较复杂，承载的业务量非常巨大，并发量也很高。这样的系统往往采用分布式的架构来均衡负载。那么这1000个并发就会是从不同的地方过来，商品库存就是共享的资源，也是这1000个并发争抢的资源，这个时候我们需要将并发互斥管理起来。这就是分布式锁的应用。 </p>
<p>而key-value存储系统，如redis，因为其一些特性，是实现分布式锁的重要工具。</p>
<h3 id="具体的实现"><a href="#具体的实现" class="headerlink" title="具体的实现"></a>具体的实现</h3><p>先来看看一些redis的基本命令：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">SETNX key value</span><br></pre></td></tr></table></figure></p>
<p>如果key不存在，就设置key对应字符串value。在这种情况下，该命令和SET一样。当key已经存在时，就不做任何操作。SETNX是”SET if Not eXists”。 </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">expire KEY seconds</span><br></pre></td></tr></table></figure>
<p>设置key的过期时间。如果key已过期，将会被自动删除。 </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">del KEY</span><br></pre></td></tr></table></figure>
<p>删除key </p>
<h3 id="需要考虑的问题"><a href="#需要考虑的问题" class="headerlink" title="需要考虑的问题"></a>需要考虑的问题</h3><ol>
<li>用什么操作redis？幸亏redis已经提供了jedis客户端用于java应用程序，直接调用jedis API即可。 </li>
<li>怎么实现加锁？“锁”其实是一个抽象的概念，将这个抽象概念变为具体的东西，就是一个存储在redis里的key-value对，key是于商品ID相关的字符串来唯一标识，value其实并不重要，因为只要这个唯一的key-value存在，就表示这个商品已经上锁。 </li>
<li>如何释放锁？既然key-value对存在就表示上锁，那么释放锁就自然是在redis里删除key-value对。 </li>
<li>阻塞还是非阻塞？笔者采用了阻塞式的实现，若线程发现已经上锁，会在特定时间内轮询锁。 </li>
<li>如何处理异常情况？比如一个线程把一个商品上了锁，但是由于各种原因，没有完成操作（在上面的业务场景里就是没有将库存-1写入数据库），自然没有释放锁，这个情况笔者加入了锁超时机制，利用redis的expire命令为key设置超时时长，过了超时时间redis就会将这个key自动删除，即强制释放锁（可以认为超时释放锁是一个异步操作，由redis完成，应用程序只需要根据系统特点设置超时时间即可）。</li>
</ol>
<h3 id="talk-is-cheap-show-me-the-code"><a href="#talk-is-cheap-show-me-the-code" class="headerlink" title="talk is cheap,show me the code"></a>talk is cheap,show me the code</h3><p>在代码实现层面，注解有并发的方法和参数，通过动态代理获取注解的方法和参数，在代理中加锁，执行完被代理的方法后释放锁。</p>
<p>几个注解定义： </p>
<p>cachelock是方法级的注解，用于注解会产生并发问题的方法:<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target</span>(ElementType.METHOD)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> CacheLock &#123;</span><br><span class="line">    <span class="function">String <span class="title">lockedPrefix</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;<span class="comment">//redis 锁key的前缀</span></span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="title">timeOut</span><span class="params">()</span> <span class="keyword">default</span> 2000</span>;<span class="comment">//轮询锁的时间</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">expireTime</span><span class="params">()</span> <span class="keyword">default</span> 1000</span>;<span class="comment">//key在redis里存在的时间，1000S</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>lockedObject是参数级的注解，用于注解商品ID等基本类型的参数：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target</span>(ElementType.PARAMETER)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> LockedObject &#123;</span><br><span class="line">    <span class="comment">//不需要值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>LockedComplexObject也是参数级的注解，用于注解自定义类型的参数：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target</span>(ElementType.PARAMETER)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> LockedComplexObject &#123;</span><br><span class="line">    <span class="function">String <span class="title">field</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;<span class="comment">//含有成员变量的复杂对象中需要加锁的成员变量，如一个商品对象的商品ID</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>CacheLockInterceptor实现InvocationHandler接口，在invoke方法中获取注解的方法和参数，在执行注解的方法前加锁，执行被注解的方法后释放锁：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CacheLockInterceptor</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> ERROR_COUNT  = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> Object proxied;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CacheLockInterceptor</span><span class="params">(Object proxied)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.proxied = proxied;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line"></span><br><span class="line">        CacheLock cacheLock = method.getAnnotation(CacheLock.class);</span><br><span class="line">        <span class="comment">//没有cacheLock注解，pass</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">null</span> == cacheLock)&#123;</span><br><span class="line">            System.out.println(<span class="string">"no cacheLock annotation"</span>);          </span><br><span class="line">            <span class="keyword">return</span> method.invoke(proxied, args);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//获得方法中参数的注解</span></span><br><span class="line">        Annotation[][] annotations = method.getParameterAnnotations();</span><br><span class="line">        <span class="comment">//根据获取到的参数注解和参数列表获得加锁的参数</span></span><br><span class="line">        Object lockedObject = getLockedObject(annotations,args);</span><br><span class="line">        String objectValue = lockedObject.toString();</span><br><span class="line">        <span class="comment">//新建一个锁</span></span><br><span class="line">        RedisLock lock = <span class="keyword">new</span> RedisLock(cacheLock.lockedPrefix(), objectValue);</span><br><span class="line">        <span class="comment">//加锁</span></span><br><span class="line">        <span class="keyword">boolean</span> result = lock.lock(cacheLock.timeOut(), cacheLock.expireTime());</span><br><span class="line">        <span class="keyword">if</span>(!result)&#123;<span class="comment">//取锁失败</span></span><br><span class="line">            ERROR_COUNT += <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> CacheLockException(<span class="string">"get lock fail"</span>);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">//加锁成功，执行方法</span></span><br><span class="line">            <span class="keyword">return</span> method.invoke(proxied, args);</span><br><span class="line">        &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">            lock.unlock();<span class="comment">//释放锁</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> annotations</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> args</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> CacheLockException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Object <span class="title">getLockedObject</span><span class="params">(Annotation[][] annotations,Object[] args)</span> <span class="keyword">throws</span> CacheLockException</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">null</span> == args || args.length == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> CacheLockException(<span class="string">"方法参数为空，没有被锁定的对象"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">null</span> == annotations || annotations.length == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> CacheLockException(<span class="string">"没有被注解的参数"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//不支持多个参数加锁，只支持第一个注解为lockedObject或者lockedComplexObject的参数</span></span><br><span class="line">        <span class="keyword">int</span> index = -<span class="number">1</span>;<span class="comment">//标记参数的位置指针</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; annotations.length;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; annotations[i].length;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(annotations[i][j] <span class="keyword">instanceof</span> LockedComplexObject)&#123;<span class="comment">//注解为LockedComplexObject</span></span><br><span class="line">                    index = i;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="keyword">return</span> args[i].getClass().getField(((LockedComplexObject)annotations[i][j]).field());</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (NoSuchFieldException | SecurityException e) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> CacheLockException(<span class="string">"注解对象中没有该属性"</span> + ((LockedComplexObject)annotations[i][j]).field());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(annotations[i][j] <span class="keyword">instanceof</span> LockedObject)&#123;</span><br><span class="line">                    index = i;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//找到第一个后直接break，不支持多参数加锁</span></span><br><span class="line">            <span class="keyword">if</span>(index != -<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(index == -<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> CacheLockException(<span class="string">"请指定被锁定参数"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> args[index];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>最关键的RedisLock类中的lock方法和unlock方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 加锁</span></span><br><span class="line"><span class="comment">     * 使用方式为：</span></span><br><span class="line"><span class="comment">     * lock();</span></span><br><span class="line"><span class="comment">     * try&#123;</span></span><br><span class="line"><span class="comment">     *    executeMethod();</span></span><br><span class="line"><span class="comment">     * &#125;finally&#123;</span></span><br><span class="line"><span class="comment">     *   unlock();</span></span><br><span class="line"><span class="comment">     * &#125;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> timeout timeout的时间范围内轮询锁</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> expire 设置锁超时时间</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 成功 or 失败</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">lock</span><span class="params">(<span class="keyword">long</span> timeout,<span class="keyword">int</span> expire)</span></span>&#123;</span><br><span class="line">        <span class="keyword">long</span> nanoTime = System.nanoTime();</span><br><span class="line">        timeout *= MILLI_NANO_TIME;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//在timeout的时间范围内不断轮询锁</span></span><br><span class="line">            <span class="keyword">while</span> (System.nanoTime() - nanoTime &lt; timeout) &#123;</span><br><span class="line">                <span class="comment">//锁不存在的话，设置锁并设置锁过期时间，即加锁</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">this</span>.redisClient.setnx(<span class="keyword">this</span>.key, LOCKED) == <span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="keyword">this</span>.redisClient.expire(key, expire);<span class="comment">//设置锁过期时间是为了在没有释放</span></span><br><span class="line">                    <span class="comment">//锁的情况下锁过期后消失，不会造成永久阻塞</span></span><br><span class="line">                    <span class="keyword">this</span>.lock = <span class="keyword">true</span>;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">this</span>.lock;</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">"出现锁等待"</span>);</span><br><span class="line">                <span class="comment">//短暂休眠，避免可能的活锁</span></span><br><span class="line">                Thread.sleep(<span class="number">3</span>, RANDOM.nextInt(<span class="number">30</span>));</span><br><span class="line">            &#125; </span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"locking error"</span>,e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">this</span>.lock)&#123;</span><br><span class="line">                redisClient.delKey(key);<span class="comment">//直接删除</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>上述的代码是框架性的代码，现在来讲解如何使用上面的简单框架来写一个秒杀函数。 </p>
<p>先定义一个接口，接口里定义了一个秒杀方法：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">SeckillInterface</span> </span>&#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*现在暂时只支持在接口方法上注解</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    <span class="comment">//cacheLock注解可能产生并发的方法</span></span><br><span class="line">    <span class="meta">@CacheLock</span>(lockedPrefix=<span class="string">"TEST_PREFIX"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">secKill</span><span class="params">(String userID,@LockedObject Long commidityID)</span></span>;<span class="comment">//最简单的秒杀方法，参数是用户ID和商品ID。可能有多个线程争抢一个商品，所以商品ID加上LockedObject注解</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上述SeckillInterface接口的实现类，即秒杀的具体实现：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SecKillImpl</span> <span class="keyword">implements</span> <span class="title">SeckillInterface</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> Map&lt;Long, Long&gt; inventory ;</span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        inventory = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        inventory.put(<span class="number">10000001L</span>, <span class="number">10000l</span>);</span><br><span class="line">        inventory.put(<span class="number">10000002L</span>, <span class="number">10000l</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">secKill</span><span class="params">(String arg1, Long arg2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//最简单的秒杀，这里仅作为demo示例</span></span><br><span class="line">        reduceInventory(arg2);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//模拟秒杀操作，姑且认为一个秒杀就是将库存减一，实际情景要复杂的多</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Long <span class="title">reduceInventory</span><span class="params">(Long commodityId)</span></span>&#123;</span><br><span class="line">        inventory.put(commodityId,inventory.get(commodityId) - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> inventory.get(commodityId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>模拟秒杀场景，1000个线程来争抢两个商品：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSecKill</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> threadCount = <span class="number">1000</span>;</span><br><span class="line">        <span class="keyword">int</span> splitPoint = <span class="number">500</span>;</span><br><span class="line">        CountDownLatch endCount = <span class="keyword">new</span> CountDownLatch(threadCount);</span><br><span class="line">        CountDownLatch beginCount = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</span><br><span class="line">        SecKillImpl testClass = <span class="keyword">new</span> SecKillImpl();</span><br><span class="line"></span><br><span class="line">        Thread[] threads = <span class="keyword">new</span> Thread[threadCount];</span><br><span class="line">        <span class="comment">//起500个线程，秒杀第一个商品</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i= <span class="number">0</span>;i &lt; splitPoint;i++)&#123;</span><br><span class="line">            threads[i] = <span class="keyword">new</span> Thread(<span class="keyword">new</span>  Runnable() &#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">//等待在一个信号量上，挂起</span></span><br><span class="line">                        beginCount.await();</span><br><span class="line">                        <span class="comment">//用动态代理的方式调用secKill方法</span></span><br><span class="line">                        SeckillInterface proxy = (SeckillInterface) Proxy.newProxyInstance(SeckillInterface.class.getClassLoader(), </span><br><span class="line">                            <span class="keyword">new</span> Class[]&#123;SeckillInterface.class&#125;, <span class="keyword">new</span> CacheLockInterceptor(testClass));</span><br><span class="line">                        proxy.secKill(<span class="string">"test"</span>, commidityId1);</span><br><span class="line">                        endCount.countDown();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            threads[i].start();</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//再起500个线程，秒杀第二件商品</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i= splitPoint;i &lt; threadCount;i++)&#123;</span><br><span class="line">            threads[i] = <span class="keyword">new</span> Thread(<span class="keyword">new</span>  Runnable() &#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">//等待在一个信号量上，挂起</span></span><br><span class="line">                        beginCount.await();</span><br><span class="line">                        <span class="comment">//用动态代理的方式调用secKill方法</span></span><br><span class="line">                        SeckillInterface proxy = (SeckillInterface) Proxy.newProxyInstance(SeckillInterface.class.getClassLoader(), </span><br><span class="line">                            <span class="keyword">new</span> Class[]&#123;SeckillInterface.class&#125;, <span class="keyword">new</span> CacheLockInterceptor(testClass));</span><br><span class="line">                        proxy.secKill(<span class="string">"test"</span>, commidityId2);</span><br><span class="line">                        <span class="comment">//testClass.testFunc("test", 10000001L);</span></span><br><span class="line">                        endCount.countDown();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            threads[i].start();</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> startTime = System.currentTimeMillis();</span><br><span class="line">        <span class="comment">//主线程释放开始信号量，并等待结束信号量，这样做保证1000个线程做到完全同时执行，保证测试的正确性</span></span><br><span class="line">        beginCount.countDown();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//主线程等待结束信号量</span></span><br><span class="line">            endCount.await();</span><br><span class="line">            <span class="comment">//观察秒杀结果是否正确</span></span><br><span class="line">            System.out.println(SecKillImpl.inventory.get(commidityId1));</span><br><span class="line">            System.out.println(SecKillImpl.inventory.get(commidityId2));</span><br><span class="line">            System.out.println(<span class="string">"error count"</span> + CacheLockInterceptor.ERROR_COUNT);</span><br><span class="line">            System.out.println(<span class="string">"total cost "</span> + (System.currentTimeMillis() - startTime));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>在正确的预想下，应该每个商品的库存都减少了500，在多次试验后，实际情况符合预想。如果不采用锁机制，会出现库存减少499，498的情况。 </p>
<p>这里采用了动态代理的方法，利用注解和反射机制得到分布式锁ID，进行加锁和释放锁操作。当然也可以直接在方法进行这些操作，采用动态代理也是为了能够将锁操作代码集中在代理中，便于维护。 </p>
<p>通常秒杀场景发生在web项目中，可以考虑利用spring的AOP特性将锁操作代码置于切面中，当然AOP本质上也是动态代理。</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>这篇文章从业务场景出发，从抽象到实现阐述了如何利用redis实现分布式锁，完成简单的秒杀功能，也记录了笔者思考的过程，希望能给阅读到本篇文章的人一些启发。</p>


      

    </section>
    
      <section class='ArticleMeta'>
          <div>
            发布于&nbsp;
            <time datetime="2018-01-07T13:32:37.000Z" itemprop="datePublished">
              2018-01-07
            </time>
          </div>
          
            <div>
              tags: 
  <li class="meta-text">
  { <a href="/tags/technology/">technology</a> }
  </li>

  <li class="meta-text">
  { <a href="/tags/redis-thread/">redis thread</a> }
  </li>


            </div>
          
      </section>
    
    
</article>

  
</div>

            <footer>
    <div>© 2015 - Mr.CrazyDC </div>
    <div>
    Powered by Hexo
    </div>
</footer>

        </div>
    </div>
</div>
<script src="/js/pager/dist/singlepager.js"></script>
<!-- 网页动态背景——随鼠标变换的动态线条 -->
<script src="/js/pager/canvas-nest/canvas-nest.js"></script>
<script>
var sp = new Pager('data-pager-shell')
</script>
</body>
</html>