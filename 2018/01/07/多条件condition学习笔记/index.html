<!DOCTYPE html>
<html lang="zh-cmn-Hans">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>多条件condition学习笔记(生产者消费者模式实例) | CrazyIT</title>
  
  
  <!--link rel="stylesheet" href="//cdn.jsdelivr.net/highlight.js/9.10.0/styles/github-gist.min.css"-->
  <link rel="stylesheet" href="//cdn.jsdelivr.net/highlight.js/9.10.0/styles/github-gist.min.css">
  <link rel="stylesheet" href="/css/style.css">

  <!-- 音频插件css -->
  <link rel="stylesheet" href="/css/audio/audioplayer.css">
</head>

<body>
<div class="Shell">
    <aside class='SideBar'>
    <section class='avatar' style="background-image: url(/assets/header.png)">
        <div class='av-pic' style="background-image: url(/assets/tree_small.png)">
        </div>
    </section>
    <section class='menu'>
        <div>CrazyIT</div>
        
            <div>Toss more than life</div>
        
        <ul>
          
            <a href="/" class="Btn">
              <li>Home</li>
            </a>  
          
            <a href="/archives/" class="Btn">
              <li>Archive</li>
            </a>  
          
            <a href="/tags/" class="Btn">
              <li>Tags</li>
            </a>  
          
            <a href="/categories/" class="Btn">
              <li>Categories</li>
            </a>  
          
            <a href="/about/" class="Btn">
              <li>About</li>
            </a>  
          
        </ul>
    </section>
    <section class="media">
        
            
                <a href="https://github.com/dicheng52119">
                    <img src="/assets/github.svg" />
                </a>
            
        
            
                <a href="https://www.facebook.com/profile.php?id=100023446571362">
                    <img src="/assets/facebook.svg" />
                </a>
            
        
            
                <a href="https://www.zhihu.com/people/yixie-zhi-qiu-16-96-61/activities">
                    <img src="/assets/zhihu.svg" />
                </a>
            
        
            
                <a href="https://www.csdn.net/">
                    <img src="/assets/csdn.svg" />
                </a>
            
        
    </section>
</aside>

    <div class="container">
        <div data-pager-shell>
            <div>
  <article class='ContentView'>
    <header class='PageTitle'>
        <h1>多条件condition学习笔记(生产者消费者模式实例)</h1>
    </header>

    <section>
      <h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>Java 并发包下的提供Lock，Lock相对于Synchronized可以更好的解决线程同步问题，更加的灵活和高效，并且ReadWriteLock锁还能实现读、写的分离。但线程间仅仅互斥是不够的，还需要通信，本篇的内容是基于上篇之上，使用Lock如何处理线程通信。阻塞队列(BlockingQueue)就是使用condition的和lock实现的。</p>
<h3 id="Condition介绍"><a href="#Condition介绍" class="headerlink" title="Condition介绍"></a>Condition介绍</h3><p>那么引入本篇的主角，Condition，Condition 将 Object的通信方法（wait、notify 和 notifyAll）分解成截然不同的对象，以便通过将这些对象与任意 Lock 实现组合使用，为每个对象提供多个等待 set （wait-set）。其中，Lock 替代了 synchronized 方法和语句的使用，Condition 替代了 Object 通信方法的使用。</p>
<p>在Condition中，用await()替换wait()，用signal()替换notify()，用signalAll()替换notifyAll()，传统线程的通信方式，Condition都可以实现，这里注意，Condition是被绑定到Lock上的，要创建一个Lock的Condition必须用newCondition()方法。</p>
<p>Condition的强大之处在于它可以为多个线程间建立不同的Condition， 使用synchronized/wait()只有一个阻塞队列，notifyAll会唤起所有阻塞队列下的线程，而使用lock/condition，可以实现多个阻塞队列，signalAll只会唤起某个阻塞队列下的阻塞线程。</p>
<a id="more"></a>
<h3 id="两种方式实现生产者消费者模式"><a href="#两种方式实现生产者消费者模式" class="headerlink" title="两种方式实现生产者消费者模式"></a>两种方式实现生产者消费者模式</h3><ul>
<li><p>使用synchronized/wait()实现生产者消费者模式如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//模拟生产和消费的对象</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Buffer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> maxSize;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Date&gt; storage;</span><br><span class="line">    Buffer(<span class="keyword">int</span> size)&#123;</span><br><span class="line">        maxSize=size;</span><br><span class="line">        storage=<span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//生产方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">()</span>  </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (storage.size() ==maxSize )&#123;<span class="comment">//如果队列满了</span></span><br><span class="line">                System.out.print(Thread.currentThread().getName()+<span class="string">": wait \n"</span>);;</span><br><span class="line">                wait();<span class="comment">//阻塞线程</span></span><br><span class="line">            &#125;</span><br><span class="line">            storage.add(<span class="keyword">new</span> Date());</span><br><span class="line">            System.out.print(Thread.currentThread().getName()+<span class="string">": put:"</span>+storage.size()+ <span class="string">"\n"</span>);</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            notifyAll();<span class="comment">//唤起线程</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;       </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//消费方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">take</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123; </span><br><span class="line">            <span class="keyword">while</span> (storage.size() ==<span class="number">0</span> )&#123;<span class="comment">//如果队列满了</span></span><br><span class="line">                System.out.print(Thread.currentThread().getName()+<span class="string">": wait \n"</span>);;</span><br><span class="line">                wait();<span class="comment">//阻塞线程</span></span><br><span class="line">            &#125;</span><br><span class="line">            Date d=((LinkedList&lt;Date&gt;)storage).poll();</span><br><span class="line">            System.out.print(Thread.currentThread().getName()+<span class="string">": take:"</span>+storage.size()+ <span class="string">"\n"</span>);</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            notifyAll();<span class="comment">//唤起线程</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;       </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//生产者</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Producer</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Buffer buffer;</span><br><span class="line">    Producer(Buffer b)&#123;</span><br><span class="line">        buffer=b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            buffer.put();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//消费者</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Buffer buffer;</span><br><span class="line">    Consumer(Buffer b)&#123;</span><br><span class="line">        buffer=b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            buffer.take();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//测试主函数</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] arg)</span></span>&#123;</span><br><span class="line">        Buffer buffer=<span class="keyword">new</span> Buffer(<span class="number">10</span>);</span><br><span class="line">        Producer producer=<span class="keyword">new</span> Producer(buffer);</span><br><span class="line">        Consumer consumer=<span class="keyword">new</span> Consumer(buffer);</span><br><span class="line">        <span class="comment">//创建线程执行生产和消费</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(producer,<span class="string">"producer-"</span>+i).start();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(consumer,<span class="string">"consumer-"</span>+i).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用lock/condition实现生产者消费者模式如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Condition;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Buffer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span>  <span class="keyword">final</span> Lock lock;</span><br><span class="line">    <span class="keyword">private</span>  <span class="keyword">final</span> Condition notFull;</span><br><span class="line">    <span class="keyword">private</span>  <span class="keyword">final</span> Condition notEmpty;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> maxSize;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Date&gt; storage;</span><br><span class="line">    Buffer(<span class="keyword">int</span> size)&#123;</span><br><span class="line">        <span class="comment">//使用锁lock，并且创建两个condition，相当于两个阻塞队列</span></span><br><span class="line">        lock=<span class="keyword">new</span> ReentrantLock();</span><br><span class="line">        notFull=lock.newCondition();</span><br><span class="line">        notEmpty=lock.newCondition();</span><br><span class="line">        maxSize=size;</span><br><span class="line">        storage=<span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">()</span>  </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;   </span><br><span class="line">            <span class="keyword">while</span> (storage.size() ==maxSize )&#123;<span class="comment">//如果队列满了</span></span><br><span class="line">                System.out.print(Thread.currentThread().getName()+<span class="string">": wait \n"</span>);;</span><br><span class="line">                notFull.await();<span class="comment">//阻塞生产线程</span></span><br><span class="line">            &#125;</span><br><span class="line">            storage.add(<span class="keyword">new</span> Date());</span><br><span class="line">            System.out.print(Thread.currentThread().getName()+<span class="string">": put:"</span>+storage.size()+ <span class="string">"\n"</span>);</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);         </span><br><span class="line">            notEmpty.signalAll();<span class="comment">//唤醒消费线程</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span>&#123;   </span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">take</span><span class="params">()</span> </span>&#123;       </span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;  </span><br><span class="line">            <span class="keyword">while</span> (storage.size() ==<span class="number">0</span> )&#123;<span class="comment">//如果队列满了</span></span><br><span class="line">                System.out.print(Thread.currentThread().getName()+<span class="string">": wait \n"</span>);;</span><br><span class="line">                notEmpty.await();<span class="comment">//阻塞消费线程</span></span><br><span class="line">            &#125;</span><br><span class="line">            Date d=((LinkedList&lt;Date&gt;)storage).poll();</span><br><span class="line">            System.out.print(Thread.currentThread().getName()+<span class="string">": take:"</span>+storage.size()+ <span class="string">"\n"</span>);</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);         </span><br><span class="line">            notFull.signalAll();<span class="comment">//唤醒生产线程</span></span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Producer</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Buffer buffer;</span><br><span class="line">    Producer(Buffer b)&#123;</span><br><span class="line">        buffer=b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            buffer.put();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Buffer buffer;</span><br><span class="line">    Consumer(Buffer b)&#123;</span><br><span class="line">        buffer=b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            buffer.take();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] arg)</span></span>&#123;</span><br><span class="line">        Buffer buffer=<span class="keyword">new</span> Buffer(<span class="number">10</span>);</span><br><span class="line">        Producer producer=<span class="keyword">new</span> Producer(buffer);</span><br><span class="line">        Consumer consumer=<span class="keyword">new</span> Consumer(buffer);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(producer,<span class="string">"producer-"</span>+i).start();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(consumer,<span class="string">"consumer-"</span>+i).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li>当生产者执行put方法时，调用notEmpty.signalAll()只会唤醒notEmpty.await()下的消费者线程。 </li>
<li>当消费者执行塔克方法时，调用notFull.signalAll()只会唤醒notFull.await()下的消费者线程。</li>
</ul>


      

    </section>
    
      <section class='ArticleMeta'>
          <div>
            发布于&nbsp;
            <time datetime="2018-01-07T11:16:03.000Z" itemprop="datePublished">
              2018-01-07
            </time>
          </div>
          
            <div>
              tags: 
  <li class="meta-text">
  { <a href="/tags/technology/">technology</a> }
  </li>

  <li class="meta-text">
  { <a href="/tags/Condition/">Condition</a> }
  </li>


            </div>
          
      </section>
    
    
</article>

  
</div>

            <footer>
    <div>© 2015 - Mr.CrazyDC </div>
    <div>
    Powered by Hexo
    </div>
</footer>

        </div>
        
        <!-- 底部音频插件 begin -->
        <div id="wrapper" style="width:40%;padding-bottom:10px;padding-left:800px;">
            <audio preload="auto" controls>
                <source src="/mp3/说散就散.mp3">
            </audio>
            <script src="js/pager/audio/jquery.js"></script>
            <script src="js/pager/audio/audioplayer.js"></script>
            <script>$( function() { $( 'audio' ).audioPlayer(); } );</script>
        </div>
        <!-- 底部音频插件 end -->
    </div>
</div>
<script src="/js/pager/dist/singlepager.js"></script>
<!-- 网页动态背景——随鼠标变换的动态线条 -->
<script src="/js/pager/canvas-nest/canvas-nest.js"></script>
<script>
var sp = new Pager('data-pager-shell')
</script>
</body>
</html>